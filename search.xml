<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2019总结</title>
    <url>/2019/12/31/2019%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>又到了一年一度的总结时间。其实写多了，也没什么好说的。前年的时候是苦于入职不顺，内心深处有感而发，写了《迷茫》；辞职后买了本心心念念的徐璐的书看，感慨颇多，写了《那些文字》；在杭州鬼混了三个月，回到家思考人生，写了《2018总结》。那时候三个阶段都很迷茫，无所适从，无处可去。如今混的还算可以，起码可以自给自足，整日有活干活，无事划水，且不表入职初始的艰辛，如今也算是个游刃有余了。</p>
<a id="more"></a>
<p>那我现在要考虑什么方面的？职业？感情？兴趣爱好？还有，人生方向？</p>
<h1 id="职业"><a href="#职业" class="headerlink" title="职业"></a>职业</h1><p>职业和工作自不必多说。我确实需要着手准备一些进阶的学习了。我完成了第一个自己的APP，虽然功能简陋，但初步完成了我要的两个标准：Material Design界面标准与符合预期设计的功能。这让我自己还是感到挺满意的。不足之处自然存在，但我在想出下一个很好的idea之前，我是不会改动这个应用了。除此之外，Android和Java方面，我需要学习很多东西：有些是早有耳闻不曾涉及，如今突发兴趣的，还有一些就是职业所必需了。我还是希望，我所学的，是我感兴趣的，这样才会更有动力。</p>
<h1 id="感情"><a href="#感情" class="headerlink" title="感情"></a>感情</h1><p>若是此刻让我在一张白纸上写一个喜欢的人的名字，除了小钰，我怕是写不出其他人了，哈哈。先附一张壁纸：</p>
<p><img src="/2019/12/31/2019%E6%80%BB%E7%BB%93/xiaoyu_bg.jpg" alt></p>
<p>哇，果然，黑长直还是我的最爱啊。要说理想伴侣的话，徐璐笔下的陆希与狄夏，则完全满足了我的所有幻想，这也是我的新网名的由来。</p>
<p><strong>但如果未来想遇到这样的女孩子，我要做到多优秀呢？或者，我又需要去做到什么呢？</strong></p>
<h1 id="兴趣爱好"><a href="#兴趣爱好" class="headerlink" title="兴趣爱好"></a>兴趣爱好</h1><p>我依然还在坚持着去年立下的读书计划，去年只读了15本，距离预期目标差了5本。而且，读什么样的书，很是让我困惑。若要说，这几个月来我读的感触最深的，是柴静的《看见》。上半年内我读的基本都是东野圭吾的书，起初很好看，《解忧杂货店》甚至在我迷茫之时指导了我一二；但在看完《恶意》那本书之后，再读他的其他悬疑向作品，总有一种相形见绌的感觉。所以，我打算换几本书看了，但外文题材的作品，我也很是忌惮，《哈姆雷特》《乱世佳人》《局外人》，开篇读起来实在是味同嚼蜡。到底还是文化底蕴的不同，完全不能接受西方的文笔描写，所以接下来的时间，我打算挑几部国内作者的书看一看。</p>
<p>至于游戏，在年末，我终于玩到了朝夕相念的黑暗之魂3。黑魂大名果真当之无愧，称作史诗又未有不可！</p>
<h1 id="人生"><a href="#人生" class="headerlink" title="人生"></a>人生</h1><p>说人生，就要谈一下优秀的人。要说今年令我感触最大的几个人，当属B站的老菊、老番茄和微小微了。</p>
<h2 id="阅历丰富，善于思考，行事踏实有章法"><a href="#阅历丰富，善于思考，行事踏实有章法" class="headerlink" title="阅历丰富，善于思考，行事踏实有章法"></a>阅历丰富，善于思考，行事踏实有章法</h2><p>老菊，很有自己的一套想法，不论是在长篇的游戏视频中的体现，能把rgb游戏kenshi做出一个七月霸权——奴隶阿飞系列，好看到爆，能玩梗，能创造梗，更能把一个生硬的游戏背景故事经营得有血有肉，用自己的理解和想法玩出自己的一套东西；更是在兼顾做视频的同时，迈出自己勇敢的一步——成立工作室，做自己的独立游戏，有自己对于游戏开发的初步预想，好结果坏结果都已经做好承受的准备了。转念一想，老菊的独立游戏计划，从太吾绘卷就开始酝酿了。他从来不缺游戏的创意，缺的是经验，所以才会几度与太吾绘卷的核心人员茄子接触，慢慢敲定了这项计划。</p>
<p>他在年初曾接受过采访，后来有微信号出过一篇文章——<a href="https://mp.weixin.qq.com/s?__biz=MzIzNzM3NzE2MA==&amp;mid=2247526741&amp;idx=1&amp;sn=6e6e8b248d59ab74e89e2dfef5aa24a6&amp;scene=21&amp;token=2118450709&amp;lang=zh_CN#wechat_redirect">《王老菊的多重身份》</a>，这篇文章我很喜欢。幽默风趣，行事随机，敢于破格，这是老菊在多个系列游戏视频中表现出的一贯形象；严肃认真，行事努力，按部就班，这是文章的采访描述，或者说是老菊对自己的标准或评价。而<strong>我印象最深的还是那句“普通人最多只能做好一件事”</strong>，而他，把自己归为普通人。</p>
<h2 id="认真与幽默两兼顾"><a href="#认真与幽默两兼顾" class="headerlink" title="认真与幽默两兼顾"></a>认真与幽默两兼顾</h2><p>老番茄是我去年才开始关注的，因为之前他发的多是些我不太感冒的游戏的视频。我对此人有耳闻，是看了b站故事王第二季，他是冠军得主。毕业之际他发了一个vlog——<a href="https://www.bilibili.com/video/BV1rx411o74x">《我毕业啦》</a>，这个认真优秀又幽默风趣的人一下子就把我吸引到了。之后的个人vlog，深深地让我感慨：这个人怎么会这么优秀又有才华啊！还TM长得帅！惊了！老番茄还有一个视频我也很喜欢，就是他的生日vlog——<a href="https://www.bilibili.com/video/BV1V4411S7Hf">《我过生日啦》</a>。</p>
<p>其实B站也有很多优秀的学霸，老菊，C菌，散人等等，无一不是优秀之才。</p>
<p>我确实看不到，以我的懒散也很难体会得到，他们的努力有多少；<strong>但我很羡慕，老番茄登场的那一瞬间，是多么耀眼</strong>。这，就足以当作我的告诫和动力了。</p>
<p>我不羡人前发光，我只羡能将一件事做到自己问心无愧。</p>
<h2 id="自信"><a href="#自信" class="headerlink" title="自信"></a>自信</h2><p>提前微小微，4个字，羞耻女王，经常在公众场合跳舞拍视频，即使是看视频，也不禁让人面红耳搔，略感不适。<br>但在看到她的视频后，就关注了她。<strong>因为我知道，我最缺自信，我需要从她身上，学到这一点。</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看完了自己写的东西，有一种自己根本没有进步的感觉，我依然没有习得良好的语言表达能力，归纳能力。还是多读点书罢。</p>
<p><strong>到底还是自己一穷二白，孤独时刻的慌张一如既往。</strong></p>
]]></content>
      <categories>
        <category>Book</category>
      </categories>
  </entry>
  <entry>
    <title>2021 报告</title>
    <url>/2021/12/28/2021/</url>
    <content><![CDATA[<p>接受我自己什么都做不到的事实，是一件很困难的事。</p>
<a id="more"></a>
<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><blockquote>
<p>建议在 PC 端右键点击图片，在新标签页中查看</p>
</blockquote>
<p><img src="/2021/12/28/2021/2021.png" alt></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类别</th>
<th style="text-align:center">实际完成数量</th>
<th style="text-align:center">计划目标数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">游戏</td>
<td style="text-align:center">10</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">阅读</td>
<td style="text-align:center">11</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:center">影视</td>
<td style="text-align:center">46</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
</div>
<h1 id="我今年在做什么"><a href="#我今年在做什么" class="headerlink" title="我今年在做什么"></a>我今年在做什么</h1><p>我像是个一无所知的孩子，在这个世界里，通过看书、游戏和电影，重新寻找着很多事情的定义，诸如，死与生，生活与梦想。</p>
<h2 id="影视"><a href="#影视" class="headerlink" title="影视"></a>影视</h2><p>你能想象到，我是在25岁，2021年才看《肖申克的救赎》和《千与千寻》的吗？</p>
<p>我很喜欢安迪为他的“同事们”争取来那一桶冰啤酒的那一幕，“阳光洒肩头，仿佛自由人”。</p>
<p>我不记得《千与千寻》里的哪一幕特别深刻。我只是感受到，千寻她成长地好快。从最开始的孤独无助，很快就变得坚强。她的幸运，都是她的努力所应得的。</p>
<p>除这两部之外，还很喜欢的一部是《Joker》。</p>
<p>印象深刻的一幕是，亚瑟在家里拿起枪，预演射击的时候。那一刻，我整个人切实地感受到了恐惧。</p>
<h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><p>年初上班第一天心跳突然过速且高血压，适逢拼多多女孩猝死事件，我对于死亡便有了恐惧。年末时奶奶一时重病，回家的路上和陪伴奶奶好起来的过程中，对老年生活又有了新的疑问。</p>
<p>于是，我去找了几本书《我与地坛》《天蓝色的彼岸》《当呼吸化为空气》《最好的告别：关于衰老与死亡》。虽然大多内容已经遗忘，但总能在手机里找到几句零零碎碎的书摘来。</p>
<blockquote>
<ul>
<li>你总是决定活下来，这说明什么？人为什么活着？因为人想活着。说到底就是那么回事，人真正的名字叫作：欲望。不怕死和想去死是两回事，有时候不怕死的人是有的，一生下来就不怕死的人是没有的。   ——《我与地坛》</li>
<li>死是一件无须乎着急去做的事，是一件无论怎样耽搁也不会错过了的事，一个必然会降临的节日。  ——《我与地坛》</li>
<li>要么去研究生命的意义，要么就去亲自经历和体验生命的意义。        ——《当呼吸化为空气》</li>
<li>我特别怀念那种感觉。风吹在脸上。也许你还活着，根本没把这当回事。但我真的很想那种感觉。  ——《天蓝色的彼岸》</li>
<li>谁都不明白自己死后应该做点什么。<br>——就像人们不知道自己活着应该干什么一样。 ——《天蓝色的彼岸》</li>
<li>我想知道，没有我，他们可怎么办。<br>我特别怀念那种感觉，风吹在脸上。<br>我想，我可能就像转学走路一样，渐渐地就被人们给忘了。一天有一天的，就没有人想起我了。这让我很难过，真的很难过。    ——《天蓝色的彼岸》</li>
</ul>
</blockquote>
<p>我最推荐的还是《天蓝色的彼岸》。因为人之所以恐惧死亡，是源于未知，源于对死后世界的未知，正如同对来到这个世界前的未知。</p>
<p><del>若全是书摘，显得没有自己思考的内容；但若是总结，又哪有书摘的话鞭辟入里呢？</del></p>
<h2 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h2><p>今年没玩什么新游戏，一心想着达成蔚蓝全关卡的一命通关（游戏圈内称 202），不过至今也才 201。虽说还差一关，不过能否做到这最后一步却是云泥之别。全世界达成的人，至今年年末，也才不过 241 人而已；国内也仅有 40 人。希望明年我能有空达成这一步。</p>
<p>在 11 月达成 201 之后，我终于有空去玩了一些新游戏，其中最主要的是，号称 3D 游戏教科书的 1998 年神作《塞尔达传说  时之笛》。</p>
<p>在 3A 大作愈发注重画质、薄弱游戏玩法和剧情合理性的今天，回顾一些神作是很有必要的。</p>
<blockquote>
<ul>
<li>游戏内容上：时之笛的主线扎实，支线有趣有用（给的奖励都是很有用的，不像很多游戏，奖励了一些可有可无的材料什么的）且不费时。</li>
<li>剧情上：时之笛的剧情可谓是明朗清晰，却在末尾又留有无限悲伤。</li>
</ul>
</blockquote>
<p>此外，我特别喜欢刚进游戏时的主题曲：</p>
<iframe frameborder="no" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=405485028&auto=0&height=66"></iframe>

<p>今年我明白了一个道理，好玩的游戏已经不多了，我以后就倚靠任天堂、宫崎英高和独立游戏过活了。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>还能健康（也可能不健康）地活着，说实话，这感觉很好。</p>
<p>这不是胡言乱语。整天被失眠困扰，每夜 3 点、 5 点必醒两次，如此易醒少眠，我的睡眠已经算不得好了。就连在这最后一天，我又从 3 点醒来，直到 5 点半才又睡着。</p>
<p>罢了，习惯了。明年一定多锻炼，强身健体，也好改善一下睡眠。</p>
<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><p>今年没有特别多想说的了，就这样吧。</p>
]]></content>
      <categories>
        <category>Book</category>
      </categories>
  </entry>
  <entry>
    <title>Activity的生命周期</title>
    <url>/2020/06/15/Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p><a href="https://developer.android.google.cn/guide/components/activities/activity-lifecycle">Activity生命周期</a></p>
<p>了解Activity的生命周期，在一定程度上，对修正或完善代码内 <strong>各种情况下</strong> <em>业务的执行顺序与发生时机</em> ，会有很大的帮助。</p>
<a id="more"></a>
<h1 id="先行知识"><a href="#先行知识" class="headerlink" title="先行知识"></a>先行知识</h1><p><img src="/2020/06/15/Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/activity_lifecycle.png" alt="Android开发官网的生命周期图例"></p>
<h2 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate"></a>onCreate</h2><p>在创建activity时触发，生命周期中第一个调用的方法，在整个生命周期内也只应发生一次（存在打破此规则的可行性操作）。<strong>此时还在后台，对用户不可见</strong>。</p>
<p>在这一步，应该初始化布局资源，绑定数据，还有所有静态资源。要注意此时视图还在构建，是无法调用布局动画以及获取或设置布局的长宽及位置信息的。</p>
<h2 id="onStart"><a href="#onStart" class="headerlink" title="onStart"></a>onStart</h2><p>activity进入“已启动”状态。对于这个阶段的描述，各博客的说法不一。我的理解为，<strong>此时对用户可见，但不处于前台，无法与用户进行交互</strong>。这个阶段很短，大概像是activity的整个界面在初现到完整展现中的过渡阶段，这个阶段的确符合“可见，不处于前台，无法交互”三个要素。</p>
<p>在这一步，可以尝试检测一些必要条件，比如检查一些权限等。</p>
<h2 id="onResume"><a href="#onResume" class="headerlink" title="onResume"></a>onResume</h2><p>调用此方法后，activity可与用户进行交互。<strong>此时位于前台，对用户可见，且可进行交互</strong>。</p>
<p>在这一步，初始化一些“独占设备”（比如相机、录音机等）的相关设置。</p>
<h2 id="onPause"><a href="#onPause" class="headerlink" title="onPause"></a>onPause</h2><p>activity失去焦点，并进入“已暂停”状态。<strong>此时尚且位于前台，对用户可见，但已不可进行交互</strong>。一般来说，如果当前方法在500ms内未执行完毕，会强制关闭当前activity。</p>
<p>此时，考虑到<strong>各种情况</strong>，调用的下一个方法会是onResume或onStop；当然，杀进程这种特别少见的情况也是有可能存在的。这里的<strong>各种情况</strong>，会在下面尝试通过操作实现。</p>
<p>在这一步，只能释放一些必要资源，以防下一个activity会用到，比如上文刚提过的“独占设备”资源。考虑到onPause有默认限时，这一步最好不要做很多操作，以防业务提前中断，造成崩溃或数据丢失等。</p>
<h2 id="onStop"><a href="#onStop" class="headerlink" title="onStop"></a>onStop</h2><p>activity已停止。<strong>此时已位于后台，对用户不可见</strong>。但此时activity还存在于内存中，尚未被销毁。</p>
<p>在这一步，可以着重做很多资源的回收工作。阿里巴巴的Android规范手册要求，尽量不要在onDestroy中释放资源，因为onDestroy的执行时机可能较晚。所以，一些线程资源的释放，数据的保存，都可以在这一步做。</p>
<h2 id="onDestroy"><a href="#onDestroy" class="headerlink" title="onDestroy"></a>onDestroy</h2><p>activity被销毁。<strong>此时对用户不可见</strong>。</p>
<p>在这一步，释放其他未释放的资源，特别是onCreate中初始化的静态资源等。</p>
<h2 id="onRestart"><a href="#onRestart" class="headerlink" title="onRestart"></a>onRestart</h2><p>处于“已停止”状态即将重启时，会调用此方法。此回调后面总跟着onStart。</p>
<h1 id="状态变更"><a href="#状态变更" class="headerlink" title="状态变更"></a>状态变更</h1><p>在使用应用的过程中，用户总会做出些令人意想不到的预料外的操作，这样一来，就需要了解一下状态变更的详情，以便开发者整理出一套趋于完美的业务逻辑。</p>
<p>以下是我所能设想到的所有操作。这其中有两种操作，属于配置更改。这类操作会重新创建activity。</p>
<h2 id="activity的切换"><a href="#activity的切换" class="headerlink" title="activity的切换"></a>activity的切换</h2><h3 id="activity-A-启动-activity-B"><a href="#activity-A-启动-activity-B" class="headerlink" title="activity A 启动 activity B"></a>activity A 启动 activity B</h3><p>onPause()(A) -&gt; onCreate()(B) -&gt; onStart()(B) -&gt; onResume()(B) -&gt; onStop()(A) -&gt; onSaveInstanceState()(A)</p>
<h3 id="activity-B-返回-activity-A"><a href="#activity-B-返回-activity-A" class="headerlink" title="activity B 返回 activity A"></a>activity B 返回 activity A</h3><p>onPause()(B) -&gt; onRestart()(A) -&gt; onStart()(A) -&gt; onResume()(A) -&gt; onStop()(B) -&gt; onDestroy()(B)</p>
<h2 id="息亮屏"><a href="#息亮屏" class="headerlink" title="息亮屏"></a>息亮屏</h2><h3 id="息屏"><a href="#息屏" class="headerlink" title="息屏"></a>息屏</h3><p>onPause() -&gt; onStop() -&gt; onSaveInstanceState()</p>
<h3 id="亮屏"><a href="#亮屏" class="headerlink" title="亮屏"></a>亮屏</h3><p>onRestart() -&gt; onStart() -&gt; onResume()</p>
<h2 id="来电"><a href="#来电" class="headerlink" title="来电"></a>来电</h2><p>一般来说，现在的手机系统很少会有不经用户允许直接切换至电话接听界面的操作了。相对以往来说，这里的操作其实也无特别之处了。</p>
<h3 id="切换至接听界面"><a href="#切换至接听界面" class="headerlink" title="切换至接听界面"></a>切换至接听界面</h3><p>onPause() -&gt; onStop() -&gt; onSaveInstanceState()</p>
<h3 id="拒绝来电"><a href="#拒绝来电" class="headerlink" title="拒绝来电"></a>拒绝来电</h3><p>onRestart() -&gt; onStart() -&gt; onResume()</p>
<h2 id="横竖屏切换（第一类配置更改操作）"><a href="#横竖屏切换（第一类配置更改操作）" class="headerlink" title="横竖屏切换（第一类配置更改操作）"></a>横竖屏切换（第一类配置更改操作）</h2><p>onPause() -&gt; onStop() -&gt; onSaveInstanceState() -&gt; onDestroy() -&gt; onCreate() -&gt; onStart() -&gt; onRestoreInstanceState() -&gt; onResume()</p>
<h2 id="窗口模式"><a href="#窗口模式" class="headerlink" title="窗口模式"></a>窗口模式</h2><h3 id="按下任务键，应用变为窗口"><a href="#按下任务键，应用变为窗口" class="headerlink" title="按下任务键，应用变为窗口"></a>按下任务键，应用变为窗口</h3><p>onPause() -&gt; onStop() -&gt; onSaveInstanceState()</p>
<h3 id="选中窗口，应用变为全屏"><a href="#选中窗口，应用变为全屏" class="headerlink" title="选中窗口，应用变为全屏"></a>选中窗口，应用变为全屏</h3><p>onRestart() -&gt; onStart() -&gt; onResume()</p>
<h3 id="切换至多窗口（即分屏）模式（第二类配置更改操作）"><a href="#切换至多窗口（即分屏）模式（第二类配置更改操作）" class="headerlink" title="切换至多窗口（即分屏）模式（第二类配置更改操作）"></a>切换至多窗口（即分屏）模式（第二类配置更改操作）</h3><p>onDestroy() -&gt; onCreate() -&gt; onStart() -&gt; onRestoreInstanceState() -&gt; onResume() -&gt; onPause()</p>
<p>这让我发现了一个有趣的东西。在切换至分屏且未添加第二个分屏应用时，主activity的生命周期会运行至onPause()。此时若是点击应用，会发现应用不响应点击事件，似是获取不到用户输入，即失去焦点。</p>
<p><strong>添加第二个分屏应用之后，测试应用调用 onResume()</strong>，此时可以响应点击事件。</p>
<p>接下来可有两种操作。</p>
<h4 id="1、将测试应用拉至全屏"><a href="#1、将测试应用拉至全屏" class="headerlink" title="1、将测试应用拉至全屏"></a>1、将测试应用拉至全屏</h4><p>onPause() -&gt; onStop() -&gt; onSaveInstanceState() -&gt; onDestroy() -&gt; onCreate() -&gt; onStart() -&gt; onRestoreInstanceState() -&gt; onResume()</p>
<h4 id="2-1、将另一个分屏应用拉至全屏"><a href="#2-1、将另一个分屏应用拉至全屏" class="headerlink" title="2-1、将另一个分屏应用拉至全屏"></a>2-1、将另一个分屏应用拉至全屏</h4><p>onPause() -&gt; onStop() -&gt; onSaveInstanceState()</p>
<h4 id="2-2、再切换至测试应用"><a href="#2-2、再切换至测试应用" class="headerlink" title="2-2、再切换至测试应用"></a>2-2、再切换至测试应用</h4><p>onDestroy() -&gt; onCreate() -&gt; onStart() -&gt; onRestoreInstanceState() -&gt; onResume()</p>
<h1 id="本章相关知识点"><a href="#本章相关知识点" class="headerlink" title="本章相关知识点"></a>本章相关知识点</h1><blockquote>
<ul>
<li><a href="https://developer.android.google.cn/topic/libraries/architecture/saving-states">保存界面状态</a></li>
<li><a href="https://developer.android.google.cn/guide/topics/ui/multi-window">多窗口支持</a></li>
<li><a href="https://developer.android.google.cn/topic/libraries/architecture/lifecycle">生命周期感知能力的组件</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android时钟动画实现</title>
    <url>/2018/11/21/Android%E6%97%B6%E9%92%9F%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>依自己的使用来看，小米手机的自身很多应用在动画处理和界面处理上都很圆滑舒服，所以估计在未来一段时间内，我都会以小米应用作为模仿练手的目标，这次就先模仿实现一下小米时钟的动画。小米时钟有很多动画，我暂时只完成了一个界面，而且还不完善，所以还会持续改进。</p>
<a id="more"></a>
<p>先放上我已经实现的效果图<del>(录制采用的是免费版的icecream，功能很不错，就是水印有点大）</del>。</p>
<p><img src="/2018/11/21/Android%E6%97%B6%E9%92%9F%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/1.gif" alt></p>
<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>这个动画中需要绘制的一共有6个部分：中心环，时针，分针，秒针，内环，外环刻度盘，如下图：</p>
<p><img src="/2018/11/21/Android%E6%97%B6%E9%92%9F%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/2.jpg" alt></p>
<p>在这6个部分中，中心环、内环属于静态，一经绘制便不需要再作处理；时针、分针、秒针和外环刻度盘则是属于时时刻刻都在运动的部分，是需要重点处理的部分。</p>
<h1 id="代码实现部分"><a href="#代码实现部分" class="headerlink" title="代码实现部分"></a>代码实现部分</h1><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>既然是要绘制时钟，就一定需要获取到时间。时间的精度一定要高，要以毫秒为单位，这样才能使动画的变化更加圆滑一些，而不是一秒一跳那样的动画。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获取当前总时间（超出1970年1月1日的时间）</span><br><span class="line">long time &#x3D; System.currentTimeMilllis();</span><br><span class="line">&#x2F;&#x2F;获取当前时间（超出当天0点的时间）</span><br><span class="line">long overtime;</span><br><span class="line">&#x2F;&#x2F;获取当前系统时间</span><br><span class="line">SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">&#x2F;&#x2F;除以1000，得到的会是以秒为单位的时间；不除，则以毫秒为单位</span><br><span class="line">try &#123;</span><br><span class="line">	overtime &#x3D; (time - (simpleDateFormat.parse(simpleDateFormat.format(time)).getTime()));</span><br><span class="line">&#125;catch (Exception e)&#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;时钟最多展示12个小时的时间，所以只需要留下一个小于12个小时的数据；一天共有12x60x60&#x3D;86400秒，半天则为43200秒</span><br><span class="line">if(overtime &gt;&#x3D; 43200000) &#123;</span><br><span class="line">	overtime &#x3D; overtime - 43200000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中心环与内环"><a href="#中心环与内环" class="headerlink" title="中心环与内环"></a>中心环与内环</h2><p>中心环与内环的实现很简单，只需要绘制两个中心圆就可以了，一个半径小一些且画笔宽度粗一些，一个半径大一些且画笔宽度细一些：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;绘制中心环画笔</span><br><span class="line">paints[0].setStyle(Paint.Style.STROKE);</span><br><span class="line">paints[0].setStrokeWidth(centerCircleWidth);</span><br><span class="line">paints[0].setColor(Color.WHITE);</span><br><span class="line">paints[0].setAntiAlias(true);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;绘制内环画笔</span><br><span class="line">paints[1].setStyle(Paint.Style.STROKE);</span><br><span class="line">paints[1].setStrokeWidth(innerCircleWidth);</span><br><span class="line">paints[1].setColor(Color.WHITE);</span><br><span class="line">paints[1].setAntiAlias(true);</span><br><span class="line"></span><br><span class="line">······</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;绘制中心环</span><br><span class="line">canvas.drawCircle(centerX,centerY,centerCircleRadius,paints[0]);</span><br><span class="line">&#x2F;&#x2F;绘制内环</span><br><span class="line">canvas.drawCircle(centerX,centerY,innerCircleRadius,paints[1]);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/11/21/Android%E6%97%B6%E9%92%9F%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/3.jpg" alt></p>
<h2 id="时针"><a href="#时针" class="headerlink" title="时针"></a>时针</h2><p>时针的实现有两点：1、时针的形状绘制；2、时针的指向角度绘制</p>
<p>时针的形状，我采用了一个等腰三角形来绘制。绘制等腰三角形，需要计算出三个点的位置。考虑到点的位置是时刻都在变化的，所以要先计算出指针应当指向的角度。</p>
<p><img src="/2018/11/21/Android%E6%97%B6%E9%92%9F%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/4.jpg" alt></p>
<p>如图所示，A点是左底点，B点是右底点，C点是顶点。其中，∠β是偏差角度，我设定为60度，∠α是时针整体的指向角度，底距是两个底点距原点的距离，时针的臂长则是顶点C距原点的距离。有了这些参数，计算各个点的变化规律就简单多了。比如：</p>
<p>$A_x = O_x + 底距 * sin(∠α - ∠β)$</p>
<p>$A_y = O_y + 底距 * cos(∠α - ∠β)$</p>
<p><strong>但是，Android界面的坐标系y轴与数学系的y轴在正方向上是相反的。所以，第二个算式中，要把”+”变为”-“。</strong></p>
<p>底点的计算已经有了，顶点的计算更简单了，自不用说。不过，计算中的∠β是个未知数，是需要我们自己去计算的。</p>
<p>前面代码中已经给过了overtime这个变量的计算，它代表的是超出当天0点的时间。计算时针的角度，只需要计算overtime能占到一个表格所表示的最大时间的比例，即占12个小时的比例。要注意的是，这里的比例计算要以毫秒为考虑角度，才能使计算出的角度尽可能的细致入微，而不是每过一个小时，跳格30度。代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;绘制时针底部时用到的偏差角度，用于计算底部点</span><br><span class="line">hourHandDeviation &#x3D; 60;</span><br><span class="line">······</span><br><span class="line">&#x2F;&#x2F;绘制时针</span><br><span class="line">&#x2F;&#x2F;以下是简化的公式，原公式为overtime&#x2F;(12 * 3600 * 1000) * (360 &#x2F; 1000)</span><br><span class="line">&#x2F;&#x2F;即先计算当前时间（单位为秒）占12个小时的总时间的多少，再乘以整个圈的度数，即可得到当前时针应该指向的角度</span><br><span class="line">double degree &#x3D; Math.toRadians(((double)overtime) &#x2F; 120000.00);</span><br><span class="line">double leftPointX &#x3D; centerX + handRadius * Math.sin(degree - Math.toRadians(hourHandDeviation));</span><br><span class="line">double leftPointY &#x3D; centerY - handRadius * Math.cos(degree - Math.toRadians(hourHandDeviation));</span><br><span class="line">double rightPointX &#x3D; centerX + handRadius * Math.sin(degree + Math.toRadians(hourHandDeviation));</span><br><span class="line">double rightPointY &#x3D; centerY - handRadius * Math.cos(degree + Math.toRadians(hourHandDeviation));</span><br><span class="line">double topPointX &#x3D; centerX + hourHandLength * Math.sin(degree);</span><br><span class="line">double topPointY &#x3D; centerY - hourHandLength * Math.cos(degree);</span><br><span class="line">&#x2F;&#x2F;通过绘制一个等腰三角形的类似图形来绘制时针</span><br><span class="line">Path path &#x3D; new Path();</span><br><span class="line">path.moveTo((float)leftPointX,(float)leftPointY);</span><br><span class="line">path.lineTo((float)topPointX,(float)topPointY);</span><br><span class="line">path.lineTo((float)rightPointX,(float)rightPointY);</span><br><span class="line">path.close();</span><br><span class="line">canvas.drawPath(path,paints[3]);</span><br></pre></td></tr></table></figure>
<h2 id="分针"><a href="#分针" class="headerlink" title="分针"></a>分针</h2><p>分针的绘制如同时针，只不过偏差角度小一些，臂长长一些，原理上都是一样的。代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;绘制分针</span><br><span class="line">&#x2F;&#x2F;以下为简化的公式，原公式为overtime mod (3600 * 1000) &#x2F; 3600 * (360 &#x2F; 1000)，计算当前时间除去小时后，剩余时间占一个小时的多少，再乘以总度数</span><br><span class="line">degree &#x3D; Math.toRadians(overtime % 3600000 * 0.0001);</span><br><span class="line">leftPointX &#x3D; centerX + handRadius * Math.sin(degree - Math.toRadians(minuteHandDeviation));</span><br><span class="line">leftPointY &#x3D; centerY - handRadius * Math.cos(degree - Math.toRadians(minuteHandDeviation));</span><br><span class="line">rightPointX &#x3D; centerX + handRadius * Math.sin(degree + Math.toRadians(minuteHandDeviation));</span><br><span class="line">rightPointY &#x3D; centerY - handRadius * Math.cos(degree + Math.toRadians(minuteHandDeviation));</span><br><span class="line">topPointX &#x3D; centerX + minuteHandLength * Math.sin(degree);</span><br><span class="line">topPointY &#x3D; centerY - minuteHandLength * Math.cos(degree);</span><br><span class="line">path &#x3D; new Path();</span><br><span class="line">path.moveTo((float)leftPointX,(float)leftPointY);</span><br><span class="line">path.lineTo((float)topPointX,(float)topPointY);</span><br><span class="line">path.lineTo((float)rightPointX,(float)rightPointY);</span><br><span class="line">path.close();</span><br><span class="line">canvas.drawPath(path,paints[4]);</span><br></pre></td></tr></table></figure>
<h2 id="秒针"><a href="#秒针" class="headerlink" title="秒针"></a>秒针</h2><p>秒针的绘制实际上也可以跟以上两个是一样的，不过我为了绘制一个等边三角形，本可以直接给定值的底距，在这里我是通过给定的秒针三角形的高secondHandHeight和底边中心到原点的距离secondHandRadius，间接计算而得出。这样的计算比较麻烦，但能得到一个等边三角形，我觉得还是可以的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;绘制一个三角形指针</span><br><span class="line">&#x2F;&#x2F;以下为简化的公式，原公式为overtime mod (60 * 1000) &#x2F; 60 * (360 &#x2F; 1000)</span><br><span class="line">degree &#x3D; Math.toRadians(overtime % 60000 * 0.006);</span><br><span class="line">&#x2F;&#x2F;计算三角形另外两顶点的偏差角度</span><br><span class="line">double deviation &#x3D; Math.atan(Math.tan(Math.toRadians(30))*secondHandHeight&#x2F;secondHandRadius);</span><br><span class="line">&#x2F;&#x2F;计算三个顶点的坐标变化</span><br><span class="line">topPointX &#x3D; centerX + (secondHandRadius + secondHandHeight) * Math.sin(degree);</span><br><span class="line">topPointY &#x3D; centerY - (secondHandRadius + secondHandHeight) * Math.cos(degree);</span><br><span class="line">double secondRadius &#x3D; Math.tan(Math.toRadians(30))*secondHandHeight&#x2F;Math.sin(deviation);</span><br><span class="line">leftPointX &#x3D; centerX + secondRadius * Math.sin(degree - deviation);</span><br><span class="line">leftPointY &#x3D; centerY - secondRadius * Math.cos(degree - deviation);</span><br><span class="line">rightPointX &#x3D; centerX + secondRadius * Math.sin(degree + deviation);</span><br><span class="line">rightPointY &#x3D; centerY - secondRadius * Math.cos(degree + deviation);</span><br><span class="line">path &#x3D; new Path();</span><br><span class="line">path.moveTo((float)topPointX,(float)topPointY);</span><br><span class="line">path.lineTo((float)leftPointX,(float)leftPointY);</span><br><span class="line">path.lineTo((float)rightPointX,(float)rightPointY);</span><br><span class="line">path.close();</span><br></pre></td></tr></table></figure>
<p>这里有一个小插曲：我这里直接简化了公式，得到的角度是精度很高，类型为double的度数，所以动画看起来很平滑，但最开始的时候，我的算式是这样的:overtime % 60000 * 6 / 1000 ，得到的是这样的：</p>
<p><img src="/2018/11/21/Android%E6%97%B6%E9%92%9F%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/8.gif" alt></p>
<p>由于gif的丢帧问题，这里表现的不是很明显，但可以告知的是，因为这样的算式最后计算出的值类型为int，所以表现上会是那种持续跳动的动画，而不是圆滑过渡的动画。这给了我一个教训：<strong>动画的过渡要想平滑，数值的精度一定要高</strong>。</p>
<h2 id="外环刻度盘"><a href="#外环刻度盘" class="headerlink" title="外环刻度盘"></a>外环刻度盘</h2><p>外环刻度盘有两种实现方法，一是通过设定绘制区域不变，边旋转画布边绘制刻度的方法；二是通过计算每个刻度的起点和终点并绘制来实现。讲道理按实现容易度来讲，应该按第一种来实现比较简单，不过因为我前几个实现全采用的三角函数计算，所以这里我的思维还是采用三角函数的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;绘制外环刻度</span><br><span class="line">for(float i &#x3D;0;i&lt;360;i&#x3D;i+2)&#123;</span><br><span class="line">	degree &#x3D; Math.toRadians(i);</span><br><span class="line">    double x1 &#x3D; centerX + outerCircleRadius * Math.sin(degree);</span><br><span class="line">    double y1 &#x3D; centerY - outerCircleRadius * Math.cos(degree);</span><br><span class="line">    double x2 &#x3D; centerX + (outerCircleRadius - outerCircleWidth) * Math.sin(degree);</span><br><span class="line">    double y2 &#x3D; centerY - (outerCircleRadius - outerCircleWidth) * Math.cos(degree);</span><br><span class="line">    if(i &gt;&#x3D; 270 &amp;&amp; i &lt;&#x3D; 360)&#123;</span><br><span class="line">    	paints[2].setAlpha((int)((i-270)*1.5+100));</span><br><span class="line">	&#125;else if(i &#x3D;&#x3D; 0)&#123;</span><br><span class="line">    	paints[2].setAlpha(240);</span><br><span class="line">	&#125;else &#123;</span><br><span class="line">    	paints[2].setAlpha(100);</span><br><span class="line">	&#125;</span><br><span class="line">    canvas.drawLine((float)x1,(float)y1,(float)x2,(float)y2,paints[2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以绘制出来一个静态的刻度盘，这个刻度盘有180道刻度，且为了赋予刻度盘一个动画的效果，最后的45道刻度以及第一道刻度赋予不同的透明度，造成淡化的效果。那么接下来，只要让刻度盘转起来就行了。</p>
<p>在最开始我想仿制分针的转动实现，但想了想，计算量大，考虑的东西有点多，后来就转为了转动画布的想法。不过，刻度盘的绘制以及转动的实现一定要放在其他三个指针的实现之前，不然会带动三个指针一起转动，这样，指针的指向就与当前时间不符了。</p>
<p>有了方向，实现转动效果就可以了。转动效果包括两点：1、每秒转动3次，即每333ms为一次转动契机；2、每次都比上次的转动角度大2度。所以，角度计算如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;计算当前时间是（几时几分）几秒</span><br><span class="line">long overSecond &#x3D; overtime % 60000;</span><br><span class="line">&#x2F;&#x2F;每秒跨格6度，每333ms跨格2度</span><br><span class="line">double degree &#x3D; overSecond &#x2F; 1000 * 6 + overSecond % 1000 &#x2F; 333 * 2;</span><br></pre></td></tr></table></figure>
<p>计算完了，就是画布的旋转。画布的旋转跟想象中的很不一样，但我也不会在这里详解，只贴出来使用流程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas.save();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;计算角度</span><br><span class="line">&#x2F;&#x2F;以圆心为中心旋转</span><br><span class="line">canvas.rotate((float)degree,centerX,centerY);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;绘制刻度盘</span><br><span class="line"></span><br><span class="line">canvas.restore();</span><br></pre></td></tr></table></figure>
<p>这样就可以实现刻度盘的转动了。</p>
<p><del>（神特么这个转动角度让我钻了牛角尖，想了整整一天才想出来怎么计算）</del></p>
<h2 id="3D视角的转动"><a href="#3D视角的转动" class="headerlink" title="3D视角的转动"></a>3D视角的转动</h2><p>3D视角的转动主要借助于camera和matrix的结合实现。这个部分的动画功能设想是，当点击时钟周围，时钟会侧向点击方向；手指松开屏幕时，时钟会重新回到原来的位置，实现效果如下：</p>
<p><img src="/2018/11/21/Android%E6%97%B6%E9%92%9F%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/9.gif" alt></p>
<p>实现思路：给view类添加点击事件的监听，当手指按下时，获取点击点的坐标，与中心点对比后判断时钟旋转方向并旋转；手指松开时，加一个时钟恢复原位的动画，这样就算完成了。</p>
<p>代码实现如下：</p>
<p>1、添加点击事件监听。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private ValueAnimator shakeAnim;</span><br><span class="line">...</span><br><span class="line">@Override</span><br><span class="line">public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">	switch (event.getAction())&#123;</span><br><span class="line">    	case MotionEvent.ACTION_DOWN:       &#x2F;&#x2F;手指按下时，而非向下的手势</span><br><span class="line">        	if(shakeAnim !&#x3D; null &amp;&amp; shakeAnim.isRunning())&#123;</span><br><span class="line">            	shakeAnim.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">			&#x2F;&#x2F;获取点击点的坐标并进行处理</span><br><span class="line">            getCameraRotate(event);</span><br><span class="line">            break;</span><br><span class="line">        case MotionEvent.ACTION_MOVE:       &#x2F;&#x2F;手指移动时</span><br><span class="line">            getCameraRotate(event);</span><br><span class="line">            break;</span><br><span class="line">        case MotionEvent.ACTION_UP:         &#x2F;&#x2F;手指抬起时，而非向上的手势</span><br><span class="line">			&#x2F;&#x2F;抬起后进行时钟恢复原位的动画</span><br><span class="line">            startShakeAnim();</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、获取点击点坐标并进行角度判断。与中心点坐标进行对比，为防止时钟偏移角度过大，设定最大旋转角度为30度，最后获取到角度后，在onDraw()方法中对视图进行视角的旋转操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private float cameraRotateX;				&#x2F;&#x2F;camera视角中x轴转动的角度</span><br><span class="line">private float cameraRotateY;				&#x2F;&#x2F;camera视角中y轴转动的角度</span><br><span class="line">private final maxCameraRotate &#x3D; 30;			&#x2F;&#x2F;最大旋转角度</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F;获取点击点</span><br><span class="line">private void getCameraRotate(MotionEvent event)&#123;</span><br><span class="line">	if(shakeAnim !&#x3D; null &amp;&amp; shakeAnim.isRunning())&#123;</span><br><span class="line">    	shakeAnim.cancel();</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;与中心点坐标进行对比</span><br><span class="line">    float rotateX &#x3D; -(event.getY() - 640);</span><br><span class="line">    float rotateY &#x3D; (event.getX() - 360);</span><br><span class="line">    &#x2F;&#x2F;求出此时旋转的大小与半径之比</span><br><span class="line">    float percentX &#x3D; rotateX &#x2F; outerCircleRadius;</span><br><span class="line">    float percentY &#x3D; rotateY &#x2F; outerCircleRadius;</span><br><span class="line">    if(percentX &gt; 1)&#123;</span><br><span class="line">    	percentX &#x3D; 1;</span><br><span class="line">	&#125;else if(percentX &lt; -1)&#123;</span><br><span class="line">    	percentX &#x3D; -1;</span><br><span class="line">	&#125;</span><br><span class="line">    if(percentY &gt; 1)&#123;</span><br><span class="line">    	percentX &#x3D; 1;</span><br><span class="line">	&#125;else if(percentY &lt; -1)&#123;</span><br><span class="line">    	percentY &#x3D; -1;</span><br><span class="line">	&#125;</span><br><span class="line">    &#x2F;&#x2F;最终旋转的大小按比例匀称改变</span><br><span class="line">    cameraRotateX &#x3D; percentX * maxCameraRotate;</span><br><span class="line">    cameraRotateY &#x3D; percentY * maxCameraRotate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置3D时钟效果</span><br><span class="line">private void setCameraRotate()&#123;</span><br><span class="line">    cameraMatrix.reset();</span><br><span class="line">	&#x2F;&#x2F;camera的旋转与canvas的旋转用法很相似，先save()再旋转最后restore()</span><br><span class="line">    camera.save();</span><br><span class="line">    camera.rotateX(cameraRotateX);</span><br><span class="line">    camera.rotateY(cameraRotateY);</span><br><span class="line">    camera.getMatrix(cameraMatrix);</span><br><span class="line">    camera.restore();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;时钟旋转后视图会发生很大的视角偏差，所以需要通过平移来设定旋转后的时钟中心点</span><br><span class="line">    cameraMatrix.preTranslate(-getWidth()&#x2F;2,-getHeight()&#x2F;2);</span><br><span class="line">    cameraMatrix.postTranslate(getWidth()&#x2F;2,getHeight()&#x2F;2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、时钟恢复原位的动画。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void startShakeAnim()&#123;</span><br><span class="line">    PropertyValuesHolder cameraRotateXHolder &#x3D; PropertyValuesHolder.ofFloat(&quot;cameraRotateX&quot;,cameraRotateX,0);</span><br><span class="line">    PropertyValuesHolder cameraRotateYHolder &#x3D; PropertyValuesHolder.ofFloat(&quot;cameraRotateY&quot;,cameraRotateY,0);</span><br><span class="line">    shakeAnim &#x3D; ValueAnimator.ofPropertyValuesHolder(cameraRotateXHolder,cameraRotateYHolder);</span><br><span class="line">    shakeAnim.setInterpolator(new OvershootInterpolator(10));</span><br><span class="line">    shakeAnim.setDuration(500);</span><br><span class="line">    shakeAnim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">            cameraRotateX &#x3D; (float) animation.getAnimatedValue(&quot;cameraRotateX&quot;);</span><br><span class="line">            cameraRotateY &#x3D; (float) animation.getAnimatedValue(&quot;cameraRotateY&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    shakeAnim.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的ValueAnimator.ofPropertyValuesHolder(PropertyValuesHolder… values)方法可以同时管理多个动画属性，比起之前的分散式管理，代码量少，也更好阅读。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>终于把3D效果的实现部分补上了。沉迷了几天的Win10 UWP应用，这才回来补上没写完的部分。</p>
<p>哦对了，PPT的绘画真好用，以后就用PPT画图好了。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android盖章动画实现</title>
    <url>/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>毕设做完这么久了，我终于回来填我自己挖下的第一个坑了。话不多说，直奔主题。</p>
<a id="more"></a>
<p>在毕设中，有一个模块是赛程数据模块,如下图：</p>
<p><img src="/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/lol_match_data.png" alt></p>
<p>那个胜利图标的显示，其实我是想用一个章印落下的动画来实现的，只不过那时忙于后台，没来得及去细看动画方面的学习。不过这几天得了些兴致，就回来填一下坑。</p>
<p>先贴效果图，如下：</p>
<p><img src="/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/sample.gif" alt></p>
<p>接下来就讲一下实现的过程。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Android动画分为视图动画与属性动画，视图动画又分为逐帧动画与补间动画。逐帧动画的工作原理类似于动画片，将一张张拆分开来的动画通过连续播放的操作，形成动画的效果。补间动画则是对view进行一系列动画操作，包括平移（Translate）、透明度（Alpha）、旋转度（Rotate）与缩放（Scale）。属性动画与补间动画类似，但是这两者有一个最大的不同。比如说，一个仅占手机界面中间一部分的按钮，我们对它进行两种动画操作：一，补间动画，将按钮放大至铺满屏幕，点击屏幕边缘，发现并没有触发按钮点击事件，这是因为补间动画仅仅是将按钮绘制为铺满屏幕而已，按钮本身的大小、位置属性并没有发生变化；而第二种，属性动画，就是为了弥补补间动画的这一缺点，属性动画放大的按钮，大小和位置属性也会发生变化，铺满屏幕后仍然可以点击。</p>
<p>除此之外，补间动画只能实现上述的四种操作，且对象仅针对于可写于布局中的view对象。属性动画可以实现背景颜色的渐变等，且对canvas、point等有一定的支持。所以，说属性动画在一定程度上可以代替补间动画。</p>
<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>先搞清楚这个动画过程中都用到了什么操作，操作的顺序或触发时机是怎样的。</p>
<ul>
<li><p>章印本身是从无到有的，即透明度是从透明过渡到不透明的。</p>
</li>
<li><p>章印是从大到小落下去的，即用到了缩放。</p>
</li>
<li><p>章印在这个过程中有一定角度的旋转。</p>
</li>
<li><p>章印落下后，为给人一种有力的感觉，整个页面布局需要有一定的抖动效果实现，而抖动，就是多个方向的平移的组合实现。</p>
</li>
</ul>
<p>这下就很清楚了。章印在落下的过程中，调用了透明度、缩放、旋转的属性动画；落下后，整个布局调用了平移的属性动画。那么接下来，只要搞清楚每个属性动画怎么实现就行了。</p>
<h1 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h1><h2 id="ValueAnimator"><a href="#ValueAnimator" class="headerlink" title="ValueAnimator"></a>ValueAnimator</h2><p>这个类是Android的属性动画机制中最核心的一个类。属性动画的运行机制，是通过对变化属性的值进行不断的运算，并赋予视图属性来实现的。它使得整个动画过程过渡得比较平滑，使人看起来很舒服。我们可以通过调用这个类，来观察值的变化规律。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ValueAnimator anim &#x3D; ValueAnimator.ofFloat(0f, 1f);</span><br><span class="line">                anim.setDuration(500);</span><br><span class="line">                anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">                        float currentValue &#x3D; (float) animation.getAnimatedValue();</span><br><span class="line">                        Log.d(&quot;TAG&quot;, &quot;cuurent value is &quot; + currentValue);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                anim.start();</span><br></pre></td></tr></table></figure>
<p>值的变化如下：</p>
<p><img src="/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/1.png" alt></p>
<p>通过值的变化可以看出，类似于正弦函数y=sinx位于-π/2到π/2之间的曲线图的变化，很贴近，起步缓，中期变化快，最后缓。不过，ofFloat方法中不止可以只传入两个值，大家可以自行传入更多的值观察变化。</p>
<p>这个类相比于表层的ObjectAnimator类，我们对后者会接触的更多一些。下面就会对效果做一些实现和演示。</p>
<h2 id="透明度-Alpha"><a href="#透明度-Alpha" class="headerlink" title="透明度 Alpha"></a>透明度 Alpha</h2><p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectAnimator animator &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;alpha&quot;,1f,0f,1f,0f,1f);</span><br><span class="line">animator.setDuration(5000);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure>
<p>实现效果：</p>
<p><img src="/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/2.gif" alt></p>
<p>可以看到，这里通过调用ofFloat()方法创建了一个ObjectAnimator的实例，其他效果的实现也大多与此类似。对于alpha属性来说，0表示透明，1表示不透明。对于ofFloat来说，属性后的数值个数传入是没有限制的。这里传入三个值是可以的，传入五个或者更多也是可以的。setDuration方法设置整个动画的时长，注意，是整个，而不是每个变化之间的时长。</p>
<p>还有，在这次实现效果中，可以看到第一次隐去和第二次显现的过程较长，而第一次显示和第二次隐去的过程较短。这就与上面提到的ValueAnimator的值的变化规律有关了。</p>
<h2 id="旋转-rotation"><a href="#旋转-rotation" class="headerlink" title="旋转 rotation"></a>旋转 rotation</h2><p>接下来的其他属性动画代码，不一样的大概就是关键字了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectAnimator animator &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;rotation&quot;,0f,360f);</span><br><span class="line">                animator.setDuration(5000);</span><br><span class="line">                animator.start();</span><br></pre></td></tr></table></figure>
<p>实现效果：</p>
<p><img src="/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/3.gif" alt></p>
<h2 id="平移-translation"><a href="#平移-translation" class="headerlink" title="平移 translation"></a>平移 translation</h2><p>这就要先说一下Android的坐标系了，如下：</p>
<p><img src="/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/4.jpg" alt></p>
<p>以我们要操作的view控件为中心，向右x增加，向下y增加。掌握这个规律后，对view操作就比较好用了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float curTranslationX &#x3D; vicImg.getTranslationX();</span><br><span class="line">                float curTranslationY &#x3D; vicImg.getTranslationY();</span><br><span class="line">                ObjectAnimator animatorX &#x3D; ObjectAnimator.ofFloat(vicImg, &quot;translationX&quot;, curTranslationX, -500f, curTranslationX);</span><br><span class="line">                ObjectAnimator animatorY &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;translationY&quot;, curTranslationY, -500f,curTranslationY);</span><br><span class="line">                animatorX.setDuration(5000);</span><br><span class="line">                animatorY.setDuration(5000);</span><br><span class="line">                animatorX.start();</span><br><span class="line">                animatorY.start();</span><br></pre></td></tr></table></figure>
<p>实现效果：</p>
<p><img src="/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/5.gif" alt></p>
<h2 id="缩放-scale"><a href="#缩放-scale" class="headerlink" title="缩放 scale"></a>缩放 scale</h2><p>缩放也同平移一样，也有x方向和y方向上的缩放。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectAnimator animatorX &#x3D; ObjectAnimator.ofFloat(vicImg, &quot;scaleX&quot;, 1f,3f,1f);</span><br><span class="line">                ObjectAnimator animatorY &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;scaleY&quot;, 1f,3f,1f);</span><br><span class="line">                animatorX.setDuration(2000);</span><br><span class="line">                animatorY.setDuration(2000);</span><br><span class="line">                animatorX.start();</span><br><span class="line">                animatorY.start();</span><br></pre></td></tr></table></figure>
<p>实现效果：</p>
<p><img src="/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/6.gif" alt></p>
<p>这样，基本就学到了每个属性动画的简单用法。</p>
<h2 id="动画组合"><a href="#动画组合" class="headerlink" title="动画组合"></a>动画组合</h2><p>独立的属性动画很难出彩，但如果将多个结合到一起，那就很不错了。而AnimatorSet类整合实现了组合动画的功能。它主要包括了以下四个方法：</p>
<ul>
<li><p>after(Animator anim)：将现有动画插入到传入的动画之后执行</p>
</li>
<li><p>after(long delay)：将现有动画延迟指定时间后执行</p>
</li>
<li><p>before(Animator anim)：将现有动画插入到传入的动画之前执行</p>
</li>
<li><p>with(Animator anim)：将现有动画与传入动画同时执行</p>
</li>
</ul>
<p>有了这个类，我们就可以完成组合动画了。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectAnimator animatorAlpha &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;alpha&quot;,1f,0f,1f);</span><br><span class="line">                ObjectAnimator rotationAnimator &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;rotation&quot;,0f,360f);</span><br><span class="line">                ObjectAnimator animatorX &#x3D; ObjectAnimator.ofFloat(vicImg, &quot;scaleX&quot;, 1f,3f,1f);</span><br><span class="line">                ObjectAnimator animatorY &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;scaleY&quot;, 1f,3f,1f);</span><br><span class="line">                AnimatorSet animatorSet &#x3D; new AnimatorSet();</span><br><span class="line">                animatorSet.play(animatorX).with(animatorY).with(animatorAlpha).before(rotationAnimator);</span><br><span class="line">                animatorSet.setDuration(2000);</span><br><span class="line">                animatorSet.start();</span><br></pre></td></tr></table></figure>
<p>代码可以看出来，组合出来的动画是，x方向和y方向同时放大3倍再缩小回原大小，同时还由不透明变为透明再变为不透明。这三个动画组合播放结束后，再旋转360度。<strong>注意，before和after是相对play和with的动画而言的，传入before的动画，会在最后执行，传入after的动画，会在最开始执行。</strong></p>
<p>效果如下：</p>
<p><img src="/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/7.gif" alt></p>
<h2 id="Xml动画配置"><a href="#Xml动画配置" class="headerlink" title="Xml动画配置"></a>Xml动画配置</h2><p>通过ObjectAnimator类可以完成动画编写，xml格式也可以完成。对于属性配置，我们优先选择xml文件进行编写。我们也可以写动画静态类，不过一般静态类我们用来写业务方面的方法。所以，xml格式的配置学习也是必要的。</p>
<ul>
<li>scale</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;set xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;</span><br><span class="line">    &lt;scale android:duration&#x3D;&quot;2000&quot;</span><br><span class="line">        android:fromXScale&#x3D;&quot;1.0&quot;</span><br><span class="line">        android:fromYScale&#x3D;&quot;1.0&quot;</span><br><span class="line">        android:toXScale&#x3D;&quot;2.0&quot;</span><br><span class="line">        android:toYScale&#x3D;&quot;2.0&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;set&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>rotate</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;set xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;</span><br><span class="line">    &lt;rotate android:duration&#x3D;&quot;2000&quot;</span><br><span class="line">        android:fromDegrees&#x3D;&quot;0&quot;</span><br><span class="line">        android:toDegrees&#x3D;&quot;30&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;set&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>translate</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;set xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;</span><br><span class="line">    &lt;translate android:duration&#x3D;&quot;2000&quot;</span><br><span class="line">        android:fromXDelta&#x3D;&quot;-50&quot;</span><br><span class="line">        android:fromYDelta&#x3D;&quot;-50&quot;</span><br><span class="line">        android:toXDelta&#x3D;&quot;50&quot;</span><br><span class="line">        android:toYDelta&#x3D;&quot;50&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;set&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>alpha</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;set xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;</span><br><span class="line">    &lt;translate android:duration&#x3D;&quot;2000&quot;</span><br><span class="line">        android:fromXDelta&#x3D;&quot;-50&quot;</span><br><span class="line">        android:fromYDelta&#x3D;&quot;-50&quot;</span><br><span class="line">        android:toXDelta&#x3D;&quot;50&quot;</span><br><span class="line">        android:toYDelta&#x3D;&quot;50&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;set&gt;</span><br></pre></td></tr></table></figure>
<p>四种标签属性的代码的基本属性代码如上所示（效果图我就不贴出了，太麻烦了，录制MP4还得转换在线格式）。</p>
<p>不过，在查资料的过程中，还有这么一个基本属性：pivotX、pivotY</p>
<p>这个属性的值有三种：数值、百分数、百分数p，分别比如：50、50%、50%p。当为数值时，表示在当前View的左上角，即原点处加上50px，做为起始缩放点；如果是50%，表示在当前View的左上角加上自己宽度的50%做为起始点；如果是50%p，那么就是表示在当前的左上角加上父控件宽度的50%做为起始点x轴坐标，这个父控件，可以是整个布局，也可以只是一个横行布局等。</p>
<p>标签属性毕竟是跟Animation类一样的，所以它也有如下属性：</p>
<ul>
<li><p>duration：动画时长，单位毫秒</p>
</li>
<li><p>fillAfter：可设置，若为true，则动画结束时，保持动画的结束状态</p>
</li>
<li><p>fillBefore：可设置，若为true，则动画结束时，还原到动画开始前的状态</p>
</li>
<li><p>repeatMode：重复类型，有reverse和restart两个值，前者表示倒序回放，后者表示重放一遍。</p>
</li>
<li><p>interpolator：设定插值器，即指定的动画效果。在此处只用到了CycleInterpolator，用于指定动画循环次数。</p>
</li>
</ul>
<p>其他博客上挂出来的其他属性，我在当前版本的AndroidStudio上是没办法使用的。这种情况遇到过很多次了，很多别人挂出来的代码并不能用，自己还得去找新的实现办法。所以以后如果我觉得有必要的话，挂一下开发环境，省的自己和别人为不能重用代码的问题烦恼。</p>
<p>话题说远了，不过用到的知识差不多也就剩下CycleInterpolator和别的一点东西了。它的用法也很简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;cycleInterpolator xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    android:cycles&#x3D;&quot;2&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>一目了然。cycles属性指定重复动作次数，且这个插值器使用时，动画的值会按照正弦函数一样变化。以后若是需要用到其他的插值器，我再去做深入的了解。</p>
<p>对了，差点忘记了set标签。在单个动画动作xml文件中，其实可以存放多组动作标签，而set就负责对它们的执行顺序进行排列和组合。主要属性：ordering，值有两种：Sequentially（顺序执行）和together（同时执行）。用法也很简单，会直接在实现代码中贴出来。</p>
<h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><p>我采用了两种代码结合的办法。<del>别问我为什么，我也想只用xml，但特喵的就是不抖动，只好还是用原来的两种形式结合的代码了</del></p>
<p>Activity.java:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void gaizhang()&#123;</span><br><span class="line">        &#x2F;&#x2F;透明度渐变动画</span><br><span class="line">        ObjectAnimator alphaAnimator &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;alpha&quot;,0f,1f,1f);</span><br><span class="line">        alphaAnimator.setDuration(1000);</span><br><span class="line">        alphaAnimator.start();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;旋转渐变动画</span><br><span class="line">        ObjectAnimator rotationAnimator &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;rotation&quot;,-30f,0f);</span><br><span class="line">        rotationAnimator.setDuration(500);</span><br><span class="line">        rotationAnimator.start();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;大小变化动画</span><br><span class="line">        ObjectAnimator yAnimator &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;scaleY&quot;,5f,1f,1f);</span><br><span class="line">        ObjectAnimator xAnimator &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;scaleX&quot;,5f,1f,1f);</span><br><span class="line">        yAnimator.setDuration(1000);</span><br><span class="line">        xAnimator.setDuration(1000);</span><br><span class="line">        yAnimator.start();</span><br><span class="line">        xAnimator.start();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;界面抖动动画</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(500);</span><br><span class="line">                &#125;catch (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                handler.sendEmptyMessage(20);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private Handler handler &#x3D; new Handler()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            switch (msg.what)&#123;</span><br><span class="line">                case 20:</span><br><span class="line">                    &#x2F;&#x2F;界面抖动动画</span><br><span class="line">                    Animation shake &#x3D; AnimationUtils.loadAnimation(getApplicationContext(),R.anim.myanim);</span><br><span class="line">                    constraintLayout.startAnimation(shake);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>shake_anim.xml:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;set xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    android:interpolator&#x3D;&quot;@anim&#x2F;cycle_2&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration&#x3D;&quot;100&quot;</span><br><span class="line">        android:fromXDelta&#x3D;&quot;-10&quot;</span><br><span class="line">        android:fromYDelta&#x3D;&quot;0&quot;</span><br><span class="line">        android:toXDelta&#x3D;&quot;0&quot;</span><br><span class="line">        android:toYDelta&#x3D;&quot;-10&quot; &#x2F;&gt;&lt;!--向上十个单位--&gt;</span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration&#x3D;&quot;100&quot;</span><br><span class="line">        android:fromXDelta&#x3D;&quot;0&quot;</span><br><span class="line">        android:fromYDelta&#x3D;&quot;-10&quot;</span><br><span class="line">        android:startOffset&#x3D;&quot;100&quot;</span><br><span class="line">        android:toXDelta&#x3D;&quot;10&quot;</span><br><span class="line">        android:toYDelta&#x3D;&quot;0&quot; &#x2F;&gt;&lt;!--向右十个单位--&gt;</span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration&#x3D;&quot;100&quot;</span><br><span class="line">        android:fromXDelta&#x3D;&quot;10&quot;</span><br><span class="line">        android:fromYDelta&#x3D;&quot;0&quot;</span><br><span class="line">        android:startOffset&#x3D;&quot;200&quot;</span><br><span class="line">        android:toXDelta&#x3D;&quot;0&quot;</span><br><span class="line">        android:toYDelta&#x3D;&quot;10&quot; &#x2F;&gt;&lt;!--向下十个单位--&gt;</span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration&#x3D;&quot;100&quot;</span><br><span class="line">        android:fromXDelta&#x3D;&quot;0&quot;</span><br><span class="line">        android:fromYDelta&#x3D;&quot;10&quot;</span><br><span class="line">        android:startOffset&#x3D;&quot;300&quot;</span><br><span class="line">        android:toXDelta&#x3D;&quot;-10&quot;</span><br><span class="line">        android:toYDelta&#x3D;&quot;0&quot; &#x2F;&gt;&lt;!--向左是个单位--&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;set&gt;</span><br></pre></td></tr></table></figure>
<p>cycleIntepolator.xml：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;cycleInterpolator xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">android:cycles&#x3D;&quot;2&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这篇博客前半部分，即xml属性章节之前，我花了一天就写出来了，但因为个人极度讨厌网页标签这种代码（布局代码还行，但属性xml就特别烦），xml一直拖着不想写，9号了才耐着性子把它写出来。希望，之后的动画学习，不会有太多的xml文件代码。</p>
<p>参考博客：<a href="https://blog.csdn.net/guolin_blog/article/details/43536355">Android属性动画完全解析(上)，初识属性动画的基本用法</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>《小情歌》读后感</title>
    <url>/2018/09/22/%E3%80%8A%E5%B0%8F%E6%83%85%E6%AD%8C%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<p>此文写于2018年，早于新博客建成时间。想不到还能找到最初的博客的备份，就搬过来了。其实文笔很糟糕，但我依然想把这篇珍藏起来。</p>
<a id="more"></a>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>如果你用悲情贿赂过读者，那你也一定用悲情贿赂过自己。    ——2020 回顾《看见》留</p>
<p>（愿你能听着这首我最喜欢的钢琴曲读这篇文章）</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="430" height="86" src="//music.163.com/outchain/player?type=2&id=22829937&auto=0&height=66"></iframe>

<p>辞职几天后，我买的《小情歌》终于到手了，花了四天时间，我终于读完了这本本该高中就应该拜读的作品。</p>
<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>我一向不喜欢谈到我的高中青春，只因我的高中生活过得实在不是很欢喜，或者说，至今为止，我看待高中生活的角度，也只有情愫而已。我知道自己的眼光狭隘了些，大概是因为此事有逆所以格外上心。在那段时间内，我曾有幸读到徐璐的一篇文章《忽然长大》。那是迄今为止我读过的，描述那时我的心境最细腻贴切，最能打动我的文字。文中的陆希，遥远地，怯懦地，卑微地，喜欢着她所欣赏的高远。她有过初次谈话时的欢喜，有过期盼却不得的失落，有过遇见心上人与他人约会时的难过，有过日日夜夜的自我折磨，也有时间磨平后的淡然心态。最后，大概为了迎合那些俗套的桥段，陆希和高远重逢后在一起了（笑）。后来我曾找到这篇文章的出处，是徐璐的大学毕设自选的自写短篇小说集《从此尽情飞翔》（真是羡慕作者的勇气）。可失望的是，我通读了全文，再没能看到一篇能更打动我的文章。这怪不得徐璐，我想只是时间久了，初尝的美好与感动太过强烈，反复回味后，便尝不出当初的味道。</p>
<p>是我感情类小说读的太少，也或是我已经拿不出全部精力去揣摩所有角色的心境，读完全书，我竟觉得这本书像是在记流水账，得不出一丝真情实感；但这账目的条款却写得细致分明，比我记忆中的高中青春更像是一个真实世界。高中同学的身影，在这些角色的故事中重现，但我的脑袋里一片混沌，始终想不起所有人；我活在了自己的世界中，只想找到像极了自己的那一个角色，寻求一丝丝最后的触感和安慰。</p>
<h1 id="缘生"><a href="#缘生" class="headerlink" title="缘生"></a>缘生</h1><p>《忽然长大》是一篇美好的，包含遗憾与圆满的童话故事；《小情歌》是一篇人物色彩与情感丰富、有血有肉的现实故事。《忽然长大》，只是《小情歌》中那一个，女主角最符合我的扮演角色的，缩影而已。</p>
<p>一谈到感情，我就会把世界过的很独。段晴、柳清清、尹冰心等等角色，不过是高中那些同学的一个个写照，这些与我无甚关系。我只关心自己，和她而已。可偏偏最不幸的是，从高二开始，我的眼界就变得愈发狭隘，只剩下了自己的感情世界。</p>
<p>每每此时，思绪乱做一团，我不知道故事该从哪里讲起，也不知道情绪该怎么宣泄才算合理。</p>
<p>像陆希一样，高远足够优秀，才吸引了她的注意力。《忽然长大》的故事过于真实，即使是暗恋的陆希，也会被高远和韩若雪的暧昧伤到痛彻心扉；但结局也过于美好，两个几年不见的人，会因为当初两个人埋在心底的相互喜欢而在一起。当然，我后来去拜读《似是故人来》，才知道陆希和高远最后还是曲终人散。不过，他们也算是圆了当初的这一份遗憾；但会不会，他们也正是因为遗憾的实现，而淡了感情呢？这些我就不得而知了。</p>
<p>最让我意外的，发展却又在情理之中的角色，是费鸣飞这个人。他平常那么大大咧咧，爱打听别人的八卦，跟同学都玩的很开，却不想，他也是一个把心事藏在肚子里的家伙。《忽然长大》里，他只是一个喜欢嘲笑陆希，跟陆希打闹的一个路人角色。可在《小情歌》里，他的形象，真正的饱满了起来。他在很早的时候，就喜欢陆希了，但却埋在心里，从来不说。高三出国临走前半年，他向陆希表白，陆希碍于友谊，也或许有些许的原因是还喜欢着高远，没有接受他。费鸣飞因此沉沦半个月，但很快就恢复了当初的模样。一张写有“I like Lucy”的纸条，会藏在一张书桌里两年，直到他出国后，才告诉陆希这个秘密。他也像那些诗一样，“看你看过的风景”，陆希说过的喜欢的国外的词句，他会去细致的拜读一遍出处。表面看起来粗犷的男孩，竟然也会有如此细腻的心思，真是叫我惊诧不已。</p>
<p>到底还是过于自我，整本书我只记得了与陆希感情相关的人，其他人已经从我的记忆中淡去了。</p>
<h1 id="缘落"><a href="#缘落" class="headerlink" title="缘落"></a>缘落</h1><p>我像极了陆希。我不觉得说自己像一个女孩有什么羞愧。我和陆希一样内向，远观所喜欢的人却不敢靠近。我与她的想法都很多，很相近，甚至有时候我的想法会变得更快，委实不是一个男子汉的作风。</p>
<p>在某个晚上，我曾做过一个梦。在梦里，喜欢的女孩却反过来向我委婉表白。一时间，梦里的我竟然被这突如其来的幸福感击昏了头脑。她说出那句话的那一刻，我简直不敢置信，吃惊地望向她。她也显得慌乱了些，马上说“那要不算了……”。我反抱住她，说“我接受”。</p>
<p>梦醒了，现实与梦境的割裂感猛地向我袭来，一时间不禁淌了几滴泪。</p>
<p>我从来没有像身边的人一样，能体验一次恋爱的感觉。从高中刚懂得喜欢一个人开始，围绕着我的主题，就只有卑微的单相思。喜欢一个人，从来不难；可若是要再走一步，就难如登天了。</p>
<p>我也曾为情流泪有几回，但这些不过都是一个人的孤单罢了。</p>
<p>一次是晚上听许嵩的《幻听》；两次是表白被拒后；而最凶狠的一次，呵，竟然是在梦里，醒来以后，发现枕头竟然湿了大半，可梦里的事情，我现在已经全然不记得了。</p>
<p>呵，原来我自己不止是忽略了别人的世界，连自以为重视的自己的事情，都开始渐渐淡忘了。呵，还真是讽刺。</p>
<p>我很想讲述自己喜欢的女生的故事，但这段文字删写了多遍后，我决定写的不那么详细。</p>
<p>我第一个喜欢的女孩A，把我曾经鼓足勇气送的几瓶饮料，在高中毕业那天，如数奉还。她的婉拒之意已经很明显了，现在仔细想来，很感激她的做法，她不想影响到我学习的注意力吧；可她不知道的是，但我想她又不会看不出来，整个高三，我根本没有办法把所有的精力放在学习上。那时候每天回去宿舍，晚上开着台灯，一个人对着日记本，写下了很多挣扎难过的文字。</p>
<p>啊~，很多不美好的回忆都浮现了出来，令我现在很不愉快。</p>
<p>那时候身边的朋友估计已经察觉到了我的异变，想来也是，不可能察觉不到。那时候的我，表现得的确很不正常，整天沉迷于听BigBang的歌，写自己的东西，课也不会好好听。那时候的我，有没有现在这般颓废，我不清楚。我很羡慕费鸣飞，他的心态调整能力很强，半个月而已，就恢复如初；而我，不知不觉已经颓废几年有余了。</p>
<p>高三时，我拜读了太宰治的《人间失格》。心之所想，目之所见。因我整个高三的情绪基调是低落的，整本小说读下来，我感受到的，只是满溢而出的绝望。不，不是绝望，倒不如说，那是一潭死水。整本书在我看来，主人公根本像是逆来顺受，或是“心安理得”地接受着发生在身边的所有糟糕的事情，尤其在妻子被拜访的商人凌辱，不，也可能是通奸，他竟也能很快接受。整本书用一个成语来形容最适合不过了，“味同嚼蜡”。</p>
<p>我不想去讲我在喜欢A的过程中有过多少令人失落的事情，即使是现在，我也能感受得到当初的那份痛苦。失落到一定深处，就会变成绝望。绝望是会积攒的。它从来不会消失，只是被暂时掩埋。不确定哪一次，也许只是被挖开了一角，就会整个爆发出来。慢慢地，我开始怀疑自己。我始终觉得，是我自己不够优秀。我渐渐地丢掉了自信，慢慢开始变得自卑自微。</p>
<p>我为A做过的最后一件事情，就是那该死的一百道C语言指针练习题了。</p>
<p>那时候是大一末了，6月份。我很清楚地记着，达哥、祥哥和茂江三个人在玩内测的天涯明月刀，而我，用了一个星期，从早到晚，都在做那一百道指针题。那是她的期末作业，而那段时间她很忙，无暇顾及。虽然那时候我指针学得很烂，当然现在不用也忘得差不多了，但我还是“主动请缨”，接下了这个任务。那个星期，我跟玩游戏的达哥他们一样很忙，我也像达哥他们一样，忙得很开心。</p>
<p>交完任务之后没几天，我就把A的所有联系方式都删掉了。</p>
<p>那一次帮忙，是我最后对A的一点补偿。那时候的我，比现在的我，要直男得多。我自觉之前说了很多对不起A的话，在几次挣扎之后，觉得无颜面对，完成任务之后，就再无联系了。</p>
<p>依我这优柔寡断的性格，我竟然也会有说离开就离开的一次。</p>
<p>现在想来，那时候少了一句“对不起”。</p>
<h1 id="缘灭"><a href="#缘灭" class="headerlink" title="缘灭"></a>缘灭</h1><p>第一次看完《秒速五厘米》、《言叶之庭》和《你的名字》的我，我的内心没有一丝波动。我的确已经变成了自己当初想要的模样。</p>
<p>任何一个脑子清醒的人，都不应该，也不会选择爱这个时候的我，包括现在。</p>
<p>我不是丧失了喜欢一个人的能力，恰恰相反，我很容易喜欢上一个人，但时间都不会长久了。可能一天，一周，一个月，但很难会再是三年。我已经没有了全部气力，去投入到下一份喜欢了。</p>
<p>而且，自此之后，我都在怀疑自己的每一份喜欢，到底有没有资格，称得上是“喜欢”。</p>
<p>我没那么乐观。既然我已经认为自己不够资格，我就不应该再去喜欢什么人。只是这颗心一直无所适从，也想有处地方，能让我觉得舒适，觉得温暖。</p>
<p>我知道逃避不是最好的方法，可我自甘逃避。就像那句话，明知堕落误人，却自甘堕落。</p>
<p>实在是没有面对的勇气。</p>
<p>躲在角落自生自灭罢了。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>很久没有写过这样的东西了，兜兜转转竟然写了一个月，写完竟然还觉得有一点满足感。大概自己真的是一个喜欢心理自虐、自我沉沦与自我麻痹的人吧。</p>
]]></content>
      <categories>
        <category>Book</category>
      </categories>
  </entry>
  <entry>
    <title>任务和返回堆栈</title>
    <url>/2020/07/08/%E4%BB%BB%E5%8A%A1%E5%92%8C%E8%BF%94%E5%9B%9E%E5%A0%86%E6%A0%88/</url>
    <content><![CDATA[<p>了解任务与返回堆栈的内容，对于合适地设置activity的启动模式，有很大的启发作用。</p>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>任务</strong>，是用户在使用时，产生的一系列activity的集合。一般来说，当启动一个新的activity时，系统会创建一个activity的新实例，并将这个实例放到一个堆栈中，这个堆栈即是<strong>返回堆栈</strong>。一般情况下，在第一次启动应用时，一个应用会创建一个相对应的任务和返回堆栈；同时，该应用的主activity也会作为返回堆栈的根activity。</p>
<p>返回堆栈的特点是，activity遵循<strong>“先进后出”（也可为“后进先出”）</strong>的原则，而且不会被重新排列。</p>
<p><img src="/2020/07/08/%E4%BB%BB%E5%8A%A1%E5%92%8C%E8%BF%94%E5%9B%9E%E5%A0%86%E6%A0%88/1.png" alt></p>
<p>图示即演示了新activity是如何添加到返回堆栈的。当用户按返回按钮时，当前activity会销毁，上一个activity将恢复。当堆栈中所有activity被移除后，任务也将不复存在。</p>
<p>Activity和任务的默认行为总结如下：（这段官网的描述很详细）</p>
<ul>
<li><p>当 Activity A 启动 Activity B 时，Activity A 会停止，但系统会保留其状态（例如滚动位置和输入到表单中的文本）。如果用户在 Activity B 中按返回按钮，系统会恢复 Activity A 及其状态。</p>
</li>
<li><p>当用户通过按主屏幕按钮离开任务时，当前 Activity 会停止，其任务会转到后台。系统会保留任务中每个 Activity 的状态。如果用户稍后通过点按该任务的启动器图标来恢复该任务，该任务会进入前台并恢复堆栈顶部的 Activity。</p>
</li>
<li><p>如果用户按返回按钮，当前 Activity 将从堆栈中退出并销毁。堆栈中的上一个 Activity 将恢复。Activity 被销毁后，系统不会保留该 Activity 的状态。</p>
</li>
<li><p>Activity 可以多次实例化，甚至是从其他任务对其进行实例化。</p>
</li>
</ul>
<h1 id="launchMode"><a href="#launchMode" class="headerlink" title="launchMode"></a>launchMode</h1><h2 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h2><p><strong>Activity的默认模式</strong>，这种模式下activity可以多次实例化。<strong>每个实例可以属于不同的任务，一个任务可以拥有多个实例。</strong></p>
<p>适用场景：大多数应用场景</p>
<h2 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h2><p><strong>栈顶复用模式</strong>。若堆栈的顶部已为当前activity实例，系统则会调用onNewIntent()方法获取已有实例；若栈顶不为当前activity实例，则会创建新的activity实例。</p>
<p>适用场景：通知消息打开的页面；登录页面等。</p>
<p>反面教材：<strong>微博</strong>：在A用户主页，<em>不进入单条微博详情</em>，点击任意一条微博的A用户头像，都会再次进入A用户主页，即生成新的Activity实例，进入一种“俄罗斯套娃”的怪圈。</p>
<p>正面教材：<strong>QQ</strong>和<strong>微博国际版</strong>：同样是在主页进行以上操作，QQ不会再次进入用户主页，微博国际版更是有屏幕抖动的效果来提醒当前已是目标用户主页。</p>
<h2 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h2><p><strong>栈内复用模式</strong>。与singleTop不同的是，此模式会检索栈内所有activity实例，而非仅限于栈顶。若存在对应实例，则调用onNewIntent()方法获取已有实例，并将其之上的所有activity实例出栈；若不存在对应实例，则新建实例。</p>
<p>适用场景：大多数APP的主页。这样的话，在退至主页时，之上的activity都会出栈，保证了退出应用时所有activity都会被销毁。</p>
<h2 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h2><p><strong>单一实例模式</strong>。这种模式下，activity实例会<strong>单独占用一个栈</strong>，在系统中具有全局唯一性。与前两者的区别在于，此模式的检索范围要扩大至整个系统。</p>
<p>适用场景：呼叫来电、闹钟响铃等界面。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>二载成就杂谈</title>
    <url>/2020/12/20/%E4%BA%8C%E8%BD%BD%E6%88%90%E5%B0%B1%E6%9D%82%E8%B0%88/</url>
    <content><![CDATA[<p>我活的太过随心所欲，生活便迷失了方向。</p>
<p>我活的又太过急于求成，乐趣便也被剥夺了。</p>
<a id="more"></a>
<h1 id="写在最前面的"><a href="#写在最前面的" class="headerlink" title="写在最前面的"></a>写在最前面的</h1><p>原本标题为“2020 总结”，但这些话翻来覆去，感觉完全没有生活的气息，委实算不得年度总结，却像是一篇针对自己纠正方向的分析报告。没有对过去的怀念，没有对未来的展望；没有对好友说些什么祝福的话语，也没对自己提些什么批评的建议。很庆幸在年底发布前一天发现了这一点，希望不会披着“年度总结”这样的幌子使得读者读完全篇才发现被欺骗了。故综上，先给读者打一剂预防针。<strong>这不是一张祝福清单，也不是一篇年度总结</strong>，只是一份不太有趣的报告罢了。</p>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>在前一两个月，我偶然发现了 Aeon Timeline 这款软件。它完美实现了我的预期效果：能以时间线的方式标注出一件事件的完成跨度，以此方便记录与观察我的行事轨迹。</p>
<h2 id="为什么要记录"><a href="#为什么要记录" class="headerlink" title="为什么要记录"></a>为什么要记录</h2><p>我想通过完成这些事情来给自己一些成就感，以填补一些空虚感。</p>
<h2 id="记录什么样的事情"><a href="#记录什么样的事情" class="headerlink" title="记录什么样的事情"></a>记录什么样的事情</h2><p>2018 年末有这个想法的时候，第一个想到的就是游戏。其次便是受身边朋友的感染，觉得自己胸无点墨，款学寡闻，几乎从不去读书，也不去看番和电影，感觉自己活在一个别的世界。</p>
<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>借助 Aeon Timeline，我将这两年记录下来的事件做了两张表：</p>
<blockquote>
<p>建议在 PC 端右键点击图片，在新标签页中查看</p>
</blockquote>
<p><img src="/2020/12/20/%E4%BA%8C%E8%BD%BD%E6%88%90%E5%B0%B1%E6%9D%82%E8%B0%88/2019-横版.png" alt></p>
<p><img src="/2020/12/20/%E4%BA%8C%E8%BD%BD%E6%88%90%E5%B0%B1%E6%9D%82%E8%B0%88/2020-横版.png" alt></p>
<h2 id="2019-年"><a href="#2019-年" class="headerlink" title="2019 年"></a>2019 年</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类别</th>
<th style="text-align:center">实际完成数量</th>
<th style="text-align:center">计划目标数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">游戏</td>
<td style="text-align:center">14</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:center">阅读</td>
<td style="text-align:center">15</td>
<td style="text-align:center">20</td>
</tr>
<tr>
<td style="text-align:center">影视</td>
<td style="text-align:center">15</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:center">项目</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
</div>
<h2 id="2020-年"><a href="#2020-年" class="headerlink" title="2020 年"></a>2020 年</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类别</th>
<th style="text-align:center">实际完成数量</th>
<th style="text-align:center">计划目标数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">游戏</td>
<td style="text-align:center">11</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">阅读</td>
<td style="text-align:center">9</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">影视</td>
<td style="text-align:center">14</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">项目</td>
<td style="text-align:center">0</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
</div>
<h1 id="分析与感受"><a href="#分析与感受" class="headerlink" title="分析与感受"></a>分析与感受</h1><p>结合图表与实际体验，这两年间存在以下问题：</p>
<blockquote>
<ul>
<li><strong>目标数量不明确</strong>，未在年初立下过具体目标</li>
<li><strong>存在空档时期</strong>，可能是迷茫无目标或有任务中途弃坑</li>
<li><strong>事件在时间上的跨度重合变高</strong>，说明专注度和耐心存在问题</li>
</ul>
</blockquote>
<p>此外还有一个问题：那就是每一类记录的<strong>事件的标准线</strong>。其实两年以来一直模糊不定，借此对事件做一些明确的定义：</p>
<h2 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h2><blockquote>
<ul>
<li>初玩的<strong>单机游戏</strong>为主，网游和已玩过的游戏不记录在内</li>
<li>完成度：至少要求<strong>主线通关</strong>。</li>
</ul>
</blockquote>
<p>我也曾玩了 DOTA2、黑魂 2（完成度大概 2/3）、刺客信条奥德赛、死亡细胞、上古卷轴 5 等等，但未达条件其一</p>
<h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><p>我阅读资历尚浅，还在摸索阶段，从这两年的书单可以看得出很杂，且要求并不高</p>
<blockquote>
<ul>
<li><strong>已出版</strong>的著作</li>
<li><strong>已完结</strong>的网文。借出版社之手，可以帮我筛选掉很多质量不过关的小说</li>
</ul>
</blockquote>
<h2 id="影视"><a href="#影视" class="headerlink" title="影视"></a>影视</h2><p>这是我之前定义最模糊的一个分类</p>
<blockquote>
<ul>
<li><strong>口碑</strong>要好</li>
<li>已完结或即将完结的<strong>二次元番剧</strong></li>
<li>非院线的<strong>电影</strong>。我看电影太太太太太少了，因此要求也很低；去影院看的电影不计在内</li>
<li>非国产连续电视剧。主要还是现在的国产剧大部分又臭又长，看的也不爽，时间也浪费了</li>
</ul>
</blockquote>
<p>总体感受上 20 年比 19 年要差一些</p>
<blockquote>
<ul>
<li>游戏：20 年玩的游戏比 19 年玩的游戏要好一些，得益于新主机的添置与宫崎英高。<strong>最值得的事情是大致玩了魂系列三部曲以及只狼</strong></li>
<li>阅读：20 年试图跳脱于东野圭吾单个作者，尝试向其他方向扩展，但似乎不太成功，而且很惭愧，9 月份之后再也没读过书了。<strong>最值得的事情是第一次阅读完了一本名著——《围城》，挑战了自己的耐性</strong></li>
<li>影视：20 年比起 19 年差了很多，二次元番剧看的极少，总感觉今年缺失了一些什么。<strong>最值得的事情是补了《青春猪头不会梦到兔女郎学姐》这部番</strong></li>
</ul>
</blockquote>
<h1 id="思考与改变"><a href="#思考与改变" class="headerlink" title="思考与改变"></a>思考与改变</h1><p>在第二年，我“如期”体验到了预想中的得与失。得，为了完成目标数量，我努力地去寻找、体验、完成很多事情；但同时，为了数量，我需要尽快完成，但有时这会意味着冲突，我的体验开始被一点点破坏掉了。这使得它在一定程度上从美好变成了阻碍。这是一件很悲哀的事情，但也需要我努力去感受、去跳脱的事情。我不知道该怎么去概括，大概就是<strong>已知结果美好时依旧努力，已知结果糟糕时依旧享受</strong>吧。</p>
<p>返回来说些在意的，那就是时长方面。</p>
<p>比如电影，一般是 2 小时；而一部番剧，通常为 12 集，即 6 小时；再长一点的民工番，如《犬夜叉》共 178 集，我在 8 月份的时候是很想补一下这部没看过的番，但看了 30 集后觉得花费时间真的太长了，就弃坑不计了，这是件很可惜的事。</p>
<p>再比如阅读，说起这个我就很羡慕别人读书的速度，半天或者几天就能很快看完一本书。而我的话短则两天，长则如围城花费时间将近一个月，一方面是围城长，一方面是开始阅读没几天后沉迷旷野之息便被搁置了。</p>
<p>而游戏，短如 Gorogoa，全成就也就 4 个小时；长如旷野之息，一周目时长为 200 多小时，双周目加起来为 330 多小时。</p>
<p>所以我在想，要不要在某些计量上做出一些改变。</p>
<h2 id="游戏-1"><a href="#游戏-1" class="headerlink" title="游戏"></a>游戏</h2><p>我想对游戏的标准作出一些改变，因为此时我的需求已不再是单单去扩展视野，多了解新游戏了。作为一名成就党，有一些游戏没有得到全成就让我有些遗憾；而有一些游戏我更想去突破自己的极限。这些意味着要付出更多的时间，而它们却无法记录在表内，比如：</p>
<p>黑魂 3：我只记录了通关一周目的一个月；我没记录在 20 年初的一个月又用了 50 个小时打了黑魂 3 两个周目以及全成就</p>
<p><img src="/2020/12/20/%E4%BA%8C%E8%BD%BD%E6%88%90%E5%B0%B1%E6%9D%82%E8%B0%88/DarkSouls-1.jpg" alt></p>
<p><img src="/2020/12/20/%E4%BA%8C%E8%BD%BD%E6%88%90%E5%B0%B1%E6%9D%82%E8%B0%88/DarkSouls.jpg" alt></p>
<center style="font-size:15px;color:#C0C0C0">附一张最喜欢的防火女</center>

<p>鬼泣 5：我只记录了 DH 难度通关的一周；我没记录我后面一个月在打 DH 的全 S 评价以及其他难度的评价（哎，果然是我太菜了）</p>
<p><img src="/2020/12/20/%E4%BA%8C%E8%BD%BD%E6%88%90%E5%B0%B1%E6%9D%82%E8%B0%88/DMC5-1.jpg" alt></p>
<p><img src="/2020/12/20/%E4%BA%8C%E8%BD%BD%E6%88%90%E5%B0%B1%E6%9D%82%E8%B0%88/DMC5-2.jpg" alt></p>
<p>DOTA2：从接触 DOTA2，被疯狂人机血虐，到现在基本可以正常对线疯狂人机</p>
<p>现在我有一些想要额外去实现的目标<del><strong>（也可能会成为主目标）</strong></del>。我也不知道以自己的实力去做这些事情会花费多少时间。我把这些目标按我自认为的难度从难到易排列如下，除<strong>第一个极有可能是永久目标</strong>：</p>
<blockquote>
<ul>
<li><a href="https://www.bilibili.com/video/BV1Fh411f7Ka">蔚蓝 全金草莓</a>（一命通关）（C 面短但容错率极低，B 面又长又难，还有最不想提及的第 9 关）（完成进度 201 / 202）</li>
<li>鬼泣 5 DMD 全 S （DMD 都还做不到通关）</li>
<li>空洞骑士 全辐辉（BOSS 战全无伤） （已于 2021/03/30 完成）</li>
<li>武士刀零 速通成就</li>
<li>只狼 全成就（已于 2021/08/29 完成）</li>
<li>奥日与萤火意志 全成就</li>
<li>塞尔达传说 旷野之息 大师模式 剑之试炼（已于 2021/01/26 完成）</li>
</ul>
</blockquote>
<p>前两件事情，是我不太认为自己能完成的事情。如果这些事情能做到的话，或许我就能在心理上突破自己的信心极限；但如果没能做到，我也难免会有觉得自己已经到此为止的心情。</p>
<p>我想在 B 站发布视频记录下完成第一件事情的过程，因为它值得我去挑战，其他的暂不考虑。<strong>如果</strong>完成度达到了我的满意度，我会在这里更个链接（<a href="https://www.bilibili.com/video/BV1Fh411f7Ka">【Celeste|蔚蓝】- 官图金草莓收集</a>）。但愿我能按时，甚至提前在明年年底前完成这个目标。</p>
<h2 id="阅读-1"><a href="#阅读-1" class="headerlink" title="阅读"></a>阅读</h2><p>这方面，我认为还是提前定下读哪些书比较好，这样就省去了寻找的时间。这其中有些书纯粹是当下时事使然，让我觉得应该去拜读一下，比如《史记》与《血疫：埃博拉的故事》。我按阅读的欲望和分类的不同将阅读顺序打乱，以免增加疲倦感。<strong>如果</strong>年末能读完这些书，就再去找两本凑个 12，但我感觉<strong>这些对我来说够多了</strong>。</p>
<blockquote>
<ul>
<li>《平均分》 （中途弃读）</li>
<li>《基督山伯爵》</li>
<li>《史记》</li>
<li>《血疫：埃博拉的故事》</li>
<li>《呼啸山庄》</li>
<li>《任天堂·征服全球史》 （在读）</li>
<li>《活着》</li>
<li>《小王子》 （已读）</li>
<li>《我与地坛》</li>
<li>《岩田先生》 （已读）</li>
<li>《天蓝色的彼岸》 （已读）</li>
<li>《当呼吸化为空气》 （已读）</li>
<li>《小情歌》 （旧书再读）</li>
<li>《滴答》 （旧书再读）</li>
</ul>
</blockquote>
<h2 id="影视-1"><a href="#影视-1" class="headerlink" title="影视"></a>影视</h2><p>这东西总是很难说，基本靠朋友的推荐，我自己发现的往往比较少。</p>
<p>我最喜欢的三部短番，是《紫罗兰永恒花园》《来自多彩世界的明天》《青春猪头不会梦到兔女郎学姐》。我想，这或许可以定义一下我喜欢的番。</p>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>20 年基本没什么想做项目的想法以及欲望，想了一下，不如在新的一年花点时间和功夫在丰富博客上，一个月至少一篇，这样也算有所收获。</p>
<h1 id="一些题外话"><a href="#一些题外话" class="headerlink" title="一些题外话"></a>一些题外话</h1><p>其实，在定下这些目标后，还是有些惴惴不安的。因为我在一个不该任性的年纪，还在一如既往地任性。不过，生活的圈子总会告诉我风向的，只不过，我总是走在队伍的尾巴里罢了。</p>
<p>还有的话，就是这一年成就虽少，却身心俱疲。总是在一个目标还没完成的时候就跳到下一个目标去了。希望来年能合理安排。</p>
<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><p>先定下所有目标，而后去完成，这是刺客信条·奥德赛。这个游戏我只玩了不到 30 个小时。</p>
<p>沿途发现并完成目标，这是塞尔达传说·旷野之息。这个游戏我玩了 300 多个小时。</p>
<p>我突然想起《良医》里的一句话：Everything’s a game.Just sometimes the stakes are higher.</p>
<p>新的一年到了，这次早一点出发吧。</p>
]]></content>
      <categories>
        <category>Book</category>
      </categories>
  </entry>
  <entry>
    <title>做时钟动画遇到的小问题</title>
    <url>/2022/04/14/%E5%81%9A%E6%97%B6%E9%92%9F%E5%8A%A8%E7%94%BB%E9%81%87%E5%88%B0%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>最近在回忆时钟动画的代码实现，然后遇到一些有趣的小问题，借此记录一下。</p>
<a id="more"></a>
<h1 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a>获取时间</h1><h2 id="System-currentTimeMillis"><a href="#System-currentTimeMillis" class="headerlink" title="System.currentTimeMillis()"></a>System.currentTimeMillis()</h2><p>该方法获取的是从 1970 年 1 月 1 日午夜，到当前时间的时间差，单位为毫秒数。使用该方法可以方便地计算小时、分钟、秒与毫秒，计算方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long hour &#x3D; time &#x2F; 1000 &#x2F; 60 &#x2F; 60 % 24;         &#x2F;&#x2F;小时</span><br><span class="line">long minute &#x3D; time &#x2F; 1000 &#x2F; 60 % 60;            &#x2F;&#x2F;分</span><br><span class="line">long second &#x3D; time &#x2F; 1000 % 60;                 &#x2F;&#x2F;秒</span><br><span class="line">long millisSecond &#x3D; time % 1000;                &#x2F;&#x2F;毫秒</span><br></pre></td></tr></table></figure>
<p>打印下此时获取到的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Log.d(&quot;Time&quot;, &quot;当前时间：&quot; + hourStr + &quot;:&quot; + minuteStr + &quot;:&quot; + secondStr);</span><br><span class="line"></span><br><span class="line">当前时间：02:46:21</span><br></pre></td></tr></table></figure>
<p>这时会发现，获取到的时间，与我的本地时间相差了 8 个小时。这是怎么回事？</p>
<p>这个时候就要涉及到一些有趣的知识了。</p>
<h3 id="GMT-与-UTC"><a href="#GMT-与-UTC" class="headerlink" title="GMT 与 UTC"></a>GMT 与 UTC</h3><p>详细原文：<a href="https://zhuanlan.zhihu.com/p/135951778">彻底弄懂GMT、UTC、时区和夏令时</a></p>
<p>在一个我常用的<a href="https://time.is">时间网站</a>，可以看到这样的信息：</p>
<p><img src="/2022/04/14/%E5%81%9A%E6%97%B6%E9%92%9F%E5%8A%A8%E7%94%BB%E9%81%87%E5%88%B0%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/1.png" alt></p>
<p>UTC，英文全名 Coordinated Universal Time，名为协调世界时（与英文全名的简称顺序 CUT 不同，是因为法文全名为 TUC，最后双方妥协使用 UTC）。该时间由 GMT、地轴运动修正后的时间与原子时间三者综合计算而来。</p>
<p>GMT，全名 Greenwich Means Time，即格林尼治时间。格林尼治是英国伦敦南郊原皇家格林尼治天文台所在地，地球本初子午线的标界处，世界计算时间和经度的起点。北京时间 = GMT 时间 + 8 小时。</p>
<p>不过，GMT 是前世界标准时，UTC 是现世界标准时，划分时间线为 1972 年。在不精确到秒的情况下，UTC 时间与 GMT 时间可视为一致。</p>
<p>这么一看就明白了，System.currentTimeMillis() 方法返回的就是 UTC 时间。而 UTC 时间是基于 GMT 时间的，故此产生了 8 个小时的时差。该方法获取到的时间是一定的，与时区无关。</p>
<p>那这里就有个问题了，为什么伦敦的时差是 7 个小时呢？这是因为英国现在处于夏令时（3 月最后一个星期日开始，10月最后一个星期日结束），时间均提前了一个小时。</p>
<h2 id="DateFormat"><a href="#DateFormat" class="headerlink" title="DateFormat"></a>DateFormat</h2><p><a href="https://www.jianshu.com/p/c63160a7c55c">SimpleDateFormat.getInstance 格式化</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Locale locale &#x3D; new Locale(Locale.SIMPLIFIED_CHINESE.getLanguage(), Locale.CHINA.getCountry());</span><br><span class="line">DateFormat format &#x3D; DateFormat.getTimeInstance(DateFormat.FULL, locale);</span><br><span class="line">Date date &#x3D; new Date(time);</span><br><span class="line">Log.d(&quot;Time&quot;, &quot;格式化时间：&quot; + format.format(date));</span><br></pre></td></tr></table></figure>
<p>打印下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">中国标准时间 下午12:22:15</span><br></pre></td></tr></table></figure>
<p>这个类在格式化 time 的时候，默认会根据系统的时区来生成对应的当地时间。由于这个经常与 System.currentTimeMillis() 方法结合使用，所以<strong>要特别注意下，是在哪个过程中发生了本地化</strong>。</p>
<h2 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h2><p>使用 Calendar 获取时间方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Calendar calendar &#x3D; Calendar.getInstance();</span><br><span class="line">long hour &#x3D; calendar.get(Calendar.HOUR_OF_DAY);</span><br><span class="line">long minute &#x3D; calendar.get(Calendar.MINUTE);</span><br><span class="line">long second &#x3D; calendar.get(Calendar.SECOND);</span><br><span class="line">long millisSecond &#x3D; calendar.get(Calendar.MILLISECOND);</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>拟态UI</title>
    <url>/2021/11/03/%E6%8B%9F%E6%80%81UI/</url>
    <content><![CDATA[<p>先来两篇原文与机翻：</p>
<a id="more"></a>
<h1 id="关于拟态的几篇文章"><a href="#关于拟态的几篇文章" class="headerlink" title="关于拟态的几篇文章"></a>关于拟态的几篇文章</h1><h2 id="用户界面的拟态"><a href="#用户界面的拟态" class="headerlink" title="用户界面的拟态"></a>用户界面的拟态</h2><p>原文：<a href="https://uxdesign.cc/neumorphism-in-user-interfaces-b47cef3bf3a6">用户界面的拟态</a></p>
<p>如何在现实世界中获取 UI 趋势的灵感，以及我们必须要解决哪些问题才能使得它们发挥作用。</p>
<p><img src="/2021/11/03/%E6%8B%9F%E6%80%81UI/1.png" alt></p>
<p>上周我们探讨了 UI 设计的一些潜在新趋势，其中一种特殊趋势最近在 Dribbble 和 Instagram 上引起了很多关注。这种“新拟物化”在评论中被 Jason Kalley 称为拟态（Neuomorphism）。我决定跳过 “o”，这样 Neuomorphism 这个名字就活跃起来了。</p>
<p>（也感谢所有很棒的评论———我知道拟物化总是“就在角落里”，但这就是关于设计师感知到的趋势和现实。）</p>
<p>你也可以看看<a href="https://www.youtube.com/c/malewiczhype">我的 Youtube 视频</a>，其中涵盖了许多设计趋势，包括此项。</p>
<p><strong>有人知道拟物化吗？</strong></p>
<p>虽然各种形式的拟物化仍然存在于 UI 中（例如桌面操作系统的垃圾桶），但这种风格的特定部分的趋势更加明显。</p>
<p>比如</p>
<p>Kamil Falana 指出，从毫无生气的“表现”到某种中途的现实主义的转变开始发生。</p>
<p><img src="/2021/11/03/%E6%8B%9F%E6%80%81UI/2.png" alt></p>
<p>我们不久前还注意到，这种变化开始在我们周围发生—— Apple 就是一个很好的例子，对“超级扁平和极简”的推动受到了阻力，最终获得了更多那种无纹理的 3D 感觉。人们似乎也喜欢这种。</p>
<p><strong>事半功倍？</strong></p>
<p>整个炒作始于一个迅速走红的 Dribble 图片。</p>
<p><img src="/2021/11/03/%E6%8B%9F%E6%80%81UI/3.png" alt></p>
<p>这张图片开启了一个趋势，虽然其中的一部分没有多大意义（一个滑动后退箭头？），但这正是我们再次对 UI 感到兴奋所需要的。谢谢 Alex！</p>
<p><strong>有什么不同？</strong></p>
<p>由于按钮没有太大变化，所以我们关注一下实际的卡片概念，从而创造出如此出色的视觉风格。</p>
<p><img src="/2021/11/03/%E6%8B%9F%E6%80%81UI/4.jpeg" alt></p>
<p><strong>Modern / Material Cards</strong></p>
<p>Modern / Material（升级）Cards 通常是一个漂浮在我们感知的背景之上的表面层，并在其下投下阴影。阴影不仅赋予它深度，而且在很多情况下也定义了形状本身——因为它通常是无边界的。</p>
<p><strong>拟物化卡片</strong></p>
<p>然而，拟物化卡片假装从背景中挤出来。这是一个凸起的形状，由与背景完全相同的材料制成。当我们从侧面看它时，我们会看到它并没有“漂浮”。</p>
<p>这个效果很容易通过使用两个阴影来实现，一个在负值，另一个在正值。但是为了让它工作，我们的背景不能是全黑或全白。它至少需要一点点色调，以便可以看到深色和“浅色”阴影。你可以为背景使用任意色调，根据你的选择，它可以是更暖的或更冷的。但白色和黑色的阴影必须是可见的，即使很轻微。</p>
<p>秘诀就在这里——根据你的喜好来调整：</p>
<p><img src="/2021/11/03/%E6%8B%9F%E6%80%81UI/5.jpeg" alt></p>
<p><strong>利与弊</strong></p>
<p>这种风格的主要好处是“新鲜”（至少在这种趋势持续的时间内）。它为界面带来了“新感觉”并使其脱颖而出。它也可以与其他样式混合使用，因此它不会到处都是“软挤压塑料”。</p>
<p>然而，它也有一些需要解决的问题。到目前为止我们发现的两个主要问题（但我们仍在寻找）是：</p>
<ul>
<li>可访问性</li>
<li>有效编码的方法</li>
</ul>
<p><strong>可见性——可访问性</strong></p>
<p>图形与背景对比度的主要问题是，当它们都是相同的颜色时，就没有要测量的对比度;-)。客观上有存在一个阴影，以便我们可以近似并尝试测量它外面的第一个像素。在我们上面的例子中，我们最终得到了这些对比度值。</p>
<p><img src="/2021/11/03/%E6%8B%9F%E6%80%81UI/6.jpeg" alt></p>
<p>正如你所看到的，Material Cards 和拟物化卡的对比度都非常低。当然，这部分是它们的吸引力，而且卡片本身并不用于活动元素——所以只要我们保持按钮突出并具有足够高的对比度，我们就应该没问题。</p>
<p>他们之间的差异很小，如果我们想对卡片使用更好的对比度，我们必须这样做：</p>
<p><img src="/2021/11/03/%E6%8B%9F%E6%80%81UI/7.jpeg" alt></p>
<p>而且由于几乎没有人将阴影设置得如此强烈，这意味着剩下的 UI 元素必须是可访问的。这个假设得出的结论是，如果我们通过排版、接近度和与重要元素的对比来进行正确的层次结构，那么这些卡片/挤压塑料卡片并不是那么重要。</p>
<p>这还亟待测试（我会尽量找时间去做），但现在我们假设下面元素的两个“版本”都是“OK”的。即使有些人没有看到它上面的柔和阴影，仍然有足够的对比度让他们看到图标并“使用它”。</p>
<p><img src="/2021/11/03/%E6%8B%9F%E6%80%81UI/8.jpeg" alt></p>
<p><strong>可访问性</strong></p>
<p>虽然“按钮”应该看起来像一个按钮，但如果图标本身与背景的对比足够好，它仍然可以工作。 所以这里要记住的主要事情是，如果你采用这种风格，请将所有重要元素保持在足够高的对比度上。</p>
<p>毕竟大多数“现代”卡片视图也没有通过其阴影的对比度测试。</p>
<p><strong>只有卡片？</strong></p>
<p>但是，如果我们决定将组件用作按钮而不是卡片，则会出现可访问性的主要问题。</p>
<p>我们可以轻松地创建具有倒置内部阴影的按下状态，如下例所示。</p>
<p><img src="/2021/11/03/%E6%8B%9F%E6%80%81UI/9.jpeg" alt></p>
<p>这里的问题其实很严重。</p>
<p>这种按下状态的对比度太小，无法表示差异。如果界面的其余部分提供，卡片可以“消失”，则活动元素需要始终传达其状态。</p>
<p>这里有几个想法，比如使用轮廓和填充图标、下划线甚至用颜色填充按下状态。</p>
<p><img src="/2021/11/03/%E6%8B%9F%E6%80%81UI/10.jpeg" alt></p>
<p>设计时请记住这一点。 我们都喜欢“漂亮”，但我们也需要记住它是每个人都可以使用的。</p>
<p><strong>编码</strong></p>
<p>让我们在这里将编码视为一种奖励，因为在 CSS 中实现“软塑料”外观实际上比我们想象的要容易。 我们还没有研究 Swift 和 Kotlin，但我认为这应该不是问题。</p>
<p><img src="/2021/11/03/%E6%8B%9F%E6%80%81UI/11.jpeg" alt></p>
<p>当然，你可以用逗号将两个框阴影合在一起。</p>
<p>如果你想要一个方便的生成器，一位创意 Web 开发人员在 <a href="https://neumorphism.io">https://neumorphism.io</a> 上制作了一个。</p>
<p><strong>其他效果</strong></p>
<p>然而，背景形状是一回事。这种新风格还带有更多“图形密集”的按钮和开关。在许多情况下，我们只需要回到“过去的美好时光”并使用位图。这似乎是一种回归，但不要担心——这没有必要。您可以轻松地将现代的、完全可编码的按钮与那些卡片形状结合起来，而且效果很好。</p>
<p><img src="/2021/11/03/%E6%8B%9F%E6%80%81UI/12.jpeg" alt></p>
<p><strong>我们真的需要这些吗？</strong></p>
<p>虽然这种新趋势肯定激发了很多设计师的灵感，但与以前使用的卡片组件的可访问性问题相比，它的问题并不是那么大。</p>
<p>所以去野吧！玩转这种趋势，并对其进行调整，以使其成为您的趋势。UI 设计师的工作是移动这些框框，所以每次框框变得有点“不同”和“新”时，它都会带回一些乐趣。如果没有这种不断的探索，所有的产品都会重新看起来一样。</p>
<p><strong>让我们找点乐子！</strong></p>
<p>但也要记住，每一个新趋势都伴随着警告，必须经过精心设计才能使用。</p>
<h2 id="Android-上的拟态"><a href="#Android-上的拟态" class="headerlink" title="Android 上的拟态"></a>Android 上的拟态</h2><p>原文：<a href="https://fornewid.medium.com/neumorphism-in-android-9cf15e2122dc">Android 上的拟态</a></p>
<p>自去年年底以来，我就已经看到了几篇关于 Neumorphism 设计的帖子。就我个人而言，我对一种新设计很感兴趣，所以我想把它应用到 Android 上。但是，由于平台限制，我找不到这样的库。所以我简单地实现了一下它。（<a href="https://github.com/fornewid/neumorphism">Github 存储库</a>）</p>
<p>我写这篇文章是为了分享库并获得更多反馈。 🤣</p>
<p>在开始之前，你们中的一些人可能不熟悉术语 Neumorphism。它是类似 Material Design 的 UI 概念，在绘制阴影上是有区别的。如果您想了解更多关于 Neumorphism 的信息，请阅读上文。</p>
<p>在 Material Design 中，<a href="https://material.io/design/environment/light-shadows.html#light">表面在阻挡光源时会投射阴影</a>。</p>
<p>在 Neumorphism 中，对象似乎是从背景中挤出来的。</p>
<p><img src="https://miro.medium.com/max/2400/1*ZmOxKYNFSPAZuDZZgyq6Vw.gif" alt></p>
<p><strong>如何实现它?</strong></p>
<p>实现起来很简单。在左上角和右下角画两个阴影。阴影应该平滑地展开。所以使用 RenderScript 模糊阴影。</p>
<p><img src="https://miro.medium.com/max/640/1*-0qEq5AuadrpE7EQqM8AtQ.gif" alt></p>
<p>但是，简单地应用它会导致渲染问题。 如果在视图区域外绘制阴影，则阴影会被切断。 ✂️</p>
<p><img src="https://miro.medium.com/max/640/1*RafVUj-OpvmO31EyO5VrJw.gif" alt></p>
<p>作为一种解决方法，首先，我尝试在 root 上使用 android:clipChilderen=”false”。但是由于操作系统版本不同或者在某些 ViewGroup 比如 RelativeLayout 中，属性不能正常工作，所以问题没有完全解决。 🤔</p>
<p>所以最后我使用 View 的 android:padding 属性解决了它。要在视图区域内绘制，请正确设置填充。 🎉</p>
<p><img src="https://miro.medium.com/max/2400/1*mCXyV0pMee_nAwciSyMQ_Q.jpeg" alt></p>
<p><strong>互动：按压效果</strong></p>
<p>移动 UI 看起来漂亮很重要。按钮按下等交互也很重要。如何在 Neumorphism 中实现按钮按下效果？</p>
<p>首先想到的是如何根据 MotionEvent 以不同方式显示形状。 这实际上是一些人建议的方式。 不幸的是，这种方式的交互不够自然。 🤔</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun onTouchEvent(event: MotionEvent): Boolean &#123;</span><br><span class="line">    when (event.action) &#123;</span><br><span class="line">        MotionEvent.ACTION_DOWN -&gt;</span><br><span class="line">            setShapeType(ShapeType.PRESSED)</span><br><span class="line">        MotionEvent.ACTION_UP -&gt;</span><br><span class="line">            setShapeType(ShapeType.FLAT)</span><br><span class="line">    &#125;</span><br><span class="line">    return super.onTouchEvent(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么像 Material Button 一样使用 StateListAnimator 怎么样？如果根据 TranslationZ 使阴影移动，则按钮按下效果会更自然地显示。 🥳</p>
<p><img src="https://miro.medium.com/max/640/1*eUn4Pxv8WFliFLdKEIfysg.gif" alt></p>
<p><strong>入门</strong></p>
<p>我通过实现我到目前为止所讨论的内容构建了一个库。 它提供了 CardView、Button、ImageView 等 View 组件。</p>
<p>以下是使用该库的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;soup.neumorphism.NeumorphCardView</span><br><span class="line">    style&#x3D;&quot;@style&#x2F;Widget.Neumorph.CardView&quot;&gt;</span><br><span class="line">    &lt;ConstraintLayout&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;&#x2F;ConstraintLayout&gt;</span><br><span class="line">&lt;&#x2F;soup.neumorphism.NeumorphCardView&gt;</span><br></pre></td></tr></table></figure>
<p>👏 完成！ （基本上，使用布局 XML。）</p>
<p>接下来，让我们看看小部件提供了哪些属性。</p>
<p><strong>特点：阴影</strong></p>
<p>你可以调整阴影的颜色和高度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;soup.neumorphism.NeumorphCardView</span><br><span class="line">    app:neumorph_shadowElevation&#x3D;&quot;6dp&quot;</span><br><span class="line">    app:neumorph_shadowColorLight&#x3D;&quot;@color&#x2F;light_color&quot;</span><br><span class="line">    app:neumorph_shadowColorDark&#x3D;&quot;@color&#x2F;dark_color&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p><strong>特征：形状</strong></p>
<p>你可以更改视图表面和角的形状。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;soup.neumorphism.NeumorphCardView</span><br><span class="line">    app:neumorph_shapeType&#x3D;&quot;&#123;flat|pressed|basin&#125;&quot;</span><br><span class="line">    app:neumorph_shapeAppearance&#x3D;&quot;@style&#x2F;ShapeAppearance&quot; &#x2F;&gt;</span><br><span class="line">&lt;style name&#x3D;&quot;ShapeAppearance&quot;&gt;</span><br><span class="line">    &lt;item name&#x3D;&quot;neumorph_cornerFamily&quot;&gt;&#123;rounded|oval&#125;&lt;&#x2F;item&gt;</span><br><span class="line">    &lt;item name&#x3D;&quot;neumorph_cornerSize&quot;&gt;32dp&lt;&#x2F;item&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/03/%E6%8B%9F%E6%80%81UI/13.jpeg" alt></p>
<p><strong>特点：颜色</strong></p>
<p>你可以指定视图的背景和边框颜色。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;soup.neumorphism.NeumorphCardView</span><br><span class="line">    app:neumorph_backgroundColor&#x3D;&quot;@color&#x2F;background_color&quot;</span><br><span class="line">    app:neumorph_strokeColor&#x3D;&quot;@color&#x2F;stroke_color&quot;</span><br><span class="line">    app:neumorph_strokeWidth&#x3D;&quot;@dimen&#x2F;stroke_width&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/03/%E6%8B%9F%E6%80%81UI/14.jpeg" alt></p>
<p><strong>特征：填充</strong></p>
<p>最后，支持 android padding 属性以防止切断阴影。 预定义的样式具有默认值。(=12dp)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;soup.neumorphism.NeumorphCardView</span><br><span class="line">    android:padding&#x3D;&quot;12dp&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>当然，所有属性都可以动态更改。</p>
<p>它是用 Drawable 实现编写的。很容易将相同的功能应用到多个 View。因此，它可以很容易地应用于 CustomView。</p>
<center>——————————</center>

<p>我们已经看到了如何在 Android 平台上实现 Neumorphism 以及如何使用该库。</p>
<p>我认为，新设计对开发人员来说是一个有趣的灵感。Neumorphism 给了我一种新的感觉，实现起来也很有趣。</p>
<p>但是，与 Material Design 相比，Neumorphism 有很多地方的原则和指南并不明确。也就是说，虽然实现了，但我觉得还不足以应用到生产中。</p>
<p>因此，如果您对 Neumorphism 感兴趣，请尝试使用该库作为测试！🧪 请在图书馆评论任何事情。（欢迎功能请求！）要达到生产级别，需要各种意见。 🧑‍💻</p>
<p>如果需要，请转到 <a href="https://github.com/fornewid/neumorphism">Github 存储库</a>！ 👀</p>
<h2 id="为什么拟物化不曾落实"><a href="#为什么拟物化不曾落实" class="headerlink" title="为什么拟物化不曾落实"></a>为什么拟物化不曾落实</h2><p><a href="https://www.uisdc.com/neumorphism-ui">为什么 2020 年初爆火的新拟物化设计，完全无法落地使用？</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>沉浸式状态栏的实现</title>
    <url>/2022/05/16/%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E6%A0%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>面试时的问题</title>
    <url>/2019/03/13/%E9%9D%A2%E8%AF%95%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Activity之间传递数据的方式"><a href="#Activity之间传递数据的方式" class="headerlink" title="Activity之间传递数据的方式"></a>Activity之间传递数据的方式</h1><p><a href="https://pennhan.github.io/2019/04/14/Android-Activity%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/">Android Activity之间的通信方式</a></p>
<blockquote>
<ul>
<li>Activity 之间跳转或者是发送广播</li>
</ul>
</blockquote>
<p>通过 putExtra() 或 Bundle() 的方法传递数据，对于对象则采用序列化的方式</p>
<blockquote>
<ul>
<li><p>借助于类的静态变量，或者是全局变量</p>
</li>
<li><p>借助于其他存储方式</p>
</li>
</ul>
</blockquote>
<p>比如 SharedPreference ，SQLite 或者 文件，剪切板等等。</p>
<h1 id="Activity-launchMode-启动模式"><a href="#Activity-launchMode-启动模式" class="headerlink" title="Activity launchMode (启动模式)"></a>Activity launchMode (启动模式)</h1><p><a href="https://www.lookingforxixia.cn/2020/07/08/%E4%BB%BB%E5%8A%A1%E5%92%8C%E8%BF%94%E5%9B%9E%E5%A0%86%E6%A0%88/">任务和返回堆栈</a></p>
<h2 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h2><p><strong>默认模式</strong>，可多次实例化。<strong>每个实例可属于不同的任务，一个任务可拥有多个实例。</strong></p>
<p>适用场景：大多数应用场景</p>
<h2 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h2><p><strong>栈顶复用模式</strong>。若堆栈栈顶已经是当前实例，则获取已有实例；否则创建新的实例。</p>
<p>适用场景：通知消息打开的页面。</p>
<p>反面教材：<strong>微博</strong></p>
<p>正面教材：<strong>QQ的空间</strong>和<strong>微博国际版</strong></p>
<h2 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h2><p><strong>栈内复用模式</strong>。检索栈内所有实例，若存在对应实例，则获取已有实例，并将之上的实例出栈；不存在，则新建实例。</p>
<p>适用场景：大多数APP的主页。</p>
<h2 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h2><p><strong>单一实例模式</strong>。实例会<strong>单独占用一个栈，在系统中具有全局唯一性</strong>。此模式的检索范围扩大至整个系统。</p>
<p>适用场景：呼叫来电、闹钟响铃等界面。</p>
<h1 id="横竖屏切换时的生命周期"><a href="#横竖屏切换时的生命周期" class="headerlink" title="横竖屏切换时的生命周期"></a>横竖屏切换时的生命周期</h1><p><a href="https://www.lookingforxixia.cn/2020/06/15/Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">Activity的生命周期</a></p>
<p>onPause() -&gt; onStop() -&gt; onSaveInstanceState() -&gt; <strong>onDestroy()</strong> -&gt; <strong>onCreate()</strong> -&gt; onStart() -&gt; onRestoreInstanceState() -&gt; onResume()</p>
<p>最主要还是要记住<strong>横竖屏切换是会调用到 onDestroy() 这一步的</strong>，因为它涉及到了布局重构 (onCreate() 方法)。</p>
<p>此外比如<strong>切换至分屏</strong>这种情况，也会走到onDestroy() 这一步。不过</p>
<p>像息屏亮屏、接听电话均只到达了 onStop() 这一步便进入了 onRestart()。</p>
<h1 id="组件之间的通信方式"><a href="#组件之间的通信方式" class="headerlink" title="组件之间的通信方式"></a>组件之间的通信方式</h1><p><a href="https://juejin.cn/post/6844903480927207437#heading-1">一文详尽 Android 通信</a></p>
<h2 id="Activity-通信"><a href="#Activity-通信" class="headerlink" title="Activity 通信"></a>Activity 通信</h2><blockquote>
<ul>
<li>通过 Intent 和 Bundle 传递基本类型和可序列化的数据，大小在 40K。</li>
</ul>
</blockquote>
<p>对于不可序列化的数据，比如 bitmap，可通过 parcelable、或转为字节组、或写入文件转而传递文件路径等。</p>
<blockquote>
<ul>
<li><p>公有静态变量 或 全局变量</p>
</li>
<li><p>物理形式，即 File、Sqlite、SharedPreference 等</p>
</li>
</ul>
</blockquote>
<h2 id="Activity-与-Fragment，Service，BroadcastReceiver"><a href="#Activity-与-Fragment，Service，BroadcastReceiver" class="headerlink" title="Activity 与 Fragment，Service，BroadcastReceiver"></a>Activity 与 Fragment，Service，BroadcastReceiver</h2><h3 id="activity-与-fragment"><a href="#activity-与-fragment" class="headerlink" title="activity 与 fragment"></a>activity 与 fragment</h3><blockquote>
<ul>
<li>通过 Bundle</li>
<li>在宿主 activity 中定义方法，在 fragment onAttach 中取值</li>
<li>在 fragment 中定义静态获取实例方法，通过构造参数</li>
</ul>
</blockquote>
<h3 id="activity-与-service"><a href="#activity-与-service" class="headerlink" title="activity 与 service"></a>activity 与 service</h3><blockquote>
<ul>
<li>通过 Bundle</li>
</ul>
</blockquote>
<h3 id="activtity-与-broadcast"><a href="#activtity-与-broadcast" class="headerlink" title="activtity 与 broadcast"></a>activtity 与 broadcast</h3><blockquote>
<ul>
<li>通过 Bundle</li>
</ul>
</blockquote>
<h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><h3 id="fragment-与-activity"><a href="#fragment-与-activity" class="headerlink" title="fragment 与 activity"></a>fragment 与 activity</h3><p>fragment 可通过 getActivity() 获取到相关联的 Activity 实例</p>
<h3 id="fragment-与其他-fragment"><a href="#fragment-与其他-fragment" class="headerlink" title="fragment 与其他 fragment"></a>fragment 与其他 fragment</h3><ol>
<li>在 fragment A 中定义接口，并在触发事件中实现方法</li>
<li>预先在其他 fragment 中定义好接收的方法</li>
<li>在 activity 中引用该接口并实现，并在此处将 fragment A 传递过来的数据传递给其他 fragment</li>
</ol>
<h1 id="内存泄露与内存优化"><a href="#内存泄露与内存优化" class="headerlink" title="内存泄露与内存优化"></a>内存泄露与内存优化</h1><p><a href="https://www.51cto.com/article/676199.html">Android性能优化之从卡顿和ANR来彻底理解内存泄露原理和优化</a></p>
<p>使用 Android Studio 的 Memory Monitor 或 LeakCanary 可查看及检测内存泄露。</p>
<h2 id="本质原因"><a href="#本质原因" class="headerlink" title="本质原因"></a>本质原因</h2><p>持有对象引用。持有引用者的生命周期超过了被引用者的生命周期</p>
<h2 id="常见内存泄露场景"><a href="#常见内存泄露场景" class="headerlink" title="常见内存泄露场景"></a>常见内存泄露场景</h2><blockquote>
<ul>
<li>单例模式持有某个 Activity 或者是 service 上下文的引用，导致不能正常回收</li>
</ul>
</blockquote>
<p>可以将 context 改为全局的上下文</p>
<blockquote>
<ul>
<li>静态变量持有 Activity 引用导致内存泄露</li>
</ul>
</blockquote>
<p>尽量减少该情况；另外要适当的时候重置为 null。</p>
<blockquote>
<ul>
<li>非静态内部类（包括匿名内部类）导致泄露</li>
</ul>
</blockquote>
<p>比如 Handler 的使用，一般要<strong>改成静态内部类加弱引用</strong>的方式。</p>
<blockquote>
<ul>
<li><p>未及时取消注册一些组件，比如广播等</p>
</li>
<li><p>Timer 和 TimerTask 导致泄露</p>
</li>
</ul>
</blockquote>
<p>常用来做一些无限轮播的 ViewPager 等，销毁 Activity 时未能及时 cancel。</p>
<blockquote>
<ul>
<li><p>集合中的对象未能及时清理</p>
</li>
<li><p>进行读写操作时资源未关闭</p>
</li>
</ul>
</blockquote>
<p>在使用 IO、File、Sqlite 等读写操作时要及时关闭</p>
<blockquote>
<ul>
<li><p>属性动画未及时 cancel</p>
</li>
<li><p>WebView </p>
</li>
</ul>
</blockquote>
<p>WebView 的 Callback 常持有 Activity 引用，造成即使调用 WebView.destroy() 等方法也无法释放。正确的方案是需要先将 WebView 从父容器移除，再进行销毁。</p>
<h2 id="拓展小知识"><a href="#拓展小知识" class="headerlink" title="拓展小知识"></a>拓展小知识</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">内存分配策略</th>
<th style="text-align:center">使用的内存空间</th>
<th style="text-align:center">存储的数据</th>
<th style="text-align:center">分配策略 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">静态分配</td>
<td style="text-align:center">方法区<font color="red">（静态存储区）</font></td>
<td style="text-align:center">存储 已被虚拟机加载的 类信息、常量、静态变量</td>
<td style="text-align:center">在程序编译时就已分配好 &amp; 存在于程序整个运行期间</td>
</tr>
<tr>
<td style="text-align:center">栈式分配</td>
<td style="text-align:center">栈区<font color="red">（Stack）</font></td>
<td style="text-align:center">存储方法执行时的局部变量&lt;/p&gt;<font color="red">（含数据类型、对象的引用）（以帧栈的形式）</font></td>
<td style="text-align:center">方法执行时，定义局部变量 则由程序自动在栈中分配内存&lt;/p&gt;方法执行结束 / 超出变量域时，则由帧栈自动释放该部分内存&lt;/p&gt;效率高<font color="red">（因栈内存分配运算内置于处理器的指令集中）</font>&lt;/p&gt;但分配的内存容量有限</td>
</tr>
<tr>
<td style="text-align:center">堆式分配</td>
<td style="text-align:center">堆区<font color="red">（Heap）</font></td>
<td style="text-align:center">存储 Java 对象的实例<font color="red">（采用关键字new出来的对象）</font>&lt;/p&gt; &amp; 实例内的成员变量<font color="red">（基本数据类型、引用 &amp; 引用的对象实体）</font></td>
<td style="text-align:center">创建对象实例时，由程序分配<font color="red">（由Java垃圾回收管理器自动管理）</font></td>
</tr>
</tbody>
</table>
</div>
<h1 id="播放云端多媒体技术"><a href="#播放云端多媒体技术" class="headerlink" title="播放云端多媒体技术"></a>播放云端多媒体技术</h1><h1 id="调起支付宝支付的流程"><a href="#调起支付宝支付的流程" class="headerlink" title="调起支付宝支付的流程"></a>调起支付宝支付的流程</h1><p><img src="/2019/03/13/%E9%9D%A2%E8%AF%95%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/Alipay_Process.png" alt></p>
<h1 id="Android-多线程"><a href="#Android-多线程" class="headerlink" title="Android 多线程"></a>Android 多线程</h1>]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>牧场物语：重聚矿石镇个人记</title>
    <url>/2020/08/25/%E9%87%8D%E8%81%9A%E7%9F%BF%E7%9F%B3%E9%95%87/</url>
    <content><![CDATA[<p>游玩日期：2020-07-20 —— 2020-08-18</p>
<a id="more"></a>
<p>之前一段时间，突然对任天堂感兴趣了起来，就去买了几本关于任天堂的书，读完之后好感大增，于是来体验一下任天堂的游戏。</p>
<p>牧场物语确实挺好玩的，剧情上要比星露谷更生动一些。很感谢牧场物语，让我重拾了当年玩星露谷的快乐和悸动（牧场物语竟然还能磕CP，太甜了，多来几对不要停）。</p>
<p>放一些兰的图：</p>
<center style="font-size:15px;color:#C0C0C0">告白</center>

<p><img src="/2020/08/25/%E9%87%8D%E8%81%9A%E7%9F%BF%E7%9F%B3%E9%95%87/1.jpg" alt></p>
<center style="font-size:15px;color:#C0C0C0">情侣事件</center>

<p><img src="/2020/08/25/%E9%87%8D%E8%81%9A%E7%9F%BF%E7%9F%B3%E9%95%87/2.jpg" alt></p>
<center style="font-size:15px;color:#C0C0C0">求婚</center>

<p><img src="/2020/08/25/%E9%87%8D%E8%81%9A%E7%9F%BF%E7%9F%B3%E9%95%87/3.jpg" alt></p>
<center style="font-size:15px;color:#C0C0C0">求婚</center>

<p><img src="/2020/08/25/%E9%87%8D%E8%81%9A%E7%9F%BF%E7%9F%B3%E9%95%87/4.jpg" alt></p>
<center style="font-size:15px;color:#C0C0C0">求婚</center>

<p><img src="/2020/08/25/%E9%87%8D%E8%81%9A%E7%9F%BF%E7%9F%B3%E9%95%87/5.jpg" alt></p>
<center style="font-size:15px;color:#C0C0C0">婚礼前</center>

<p><img src="/2020/08/25/%E9%87%8D%E8%81%9A%E7%9F%BF%E7%9F%B3%E9%95%87/6.jpg" alt></p>
<center style="font-size:15px;color:#C0C0C0">婚礼</center>

<p><img src="/2020/08/25/%E9%87%8D%E8%81%9A%E7%9F%BF%E7%9F%B3%E9%95%87/7.jpg" alt></p>
<center style="font-size:15px;color:#C0C0C0">这一张兰的立绘实在是太可爱了</center>

<p><img src="/2020/08/25/%E9%87%8D%E8%81%9A%E7%9F%BF%E7%9F%B3%E9%95%87/8.jpg" alt></p>
<center style="font-size:15px;color:#C0C0C0">婚礼当天晚上</center>

<p><img src="/2020/08/25/%E9%87%8D%E8%81%9A%E7%9F%BF%E7%9F%B3%E9%95%87/9.jpg" alt></p>
<center style="font-size:15px;color:#C0C0C0">婚礼当天晚上</center>

<p><img src="/2020/08/25/%E9%87%8D%E8%81%9A%E7%9F%BF%E7%9F%B3%E9%95%87/10.jpg" alt></p>
<center style="font-size:15px;color:#C0C0C0">幸福生活第一天</center>

<p><img src="/2020/08/25/%E9%87%8D%E8%81%9A%E7%9F%BF%E7%9F%B3%E9%95%87/11.jpg" alt></p>
]]></content>
      <categories>
        <category>Game</category>
      </categories>
  </entry>
  <entry>
    <title>Android绘画学习-Paint相关</title>
    <url>/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>想做Android动画的时候，有的时候又需要自己画一些图形，比如自定义的进度条这样的。所以，学一些基础的绘画代码也是必要的。</p>
<a id="more"></a>
<p>我这里的Androi动画学习笔记是从CSDN的一位大佬的动画博客教程那里学来的，其实很多部分都与原博客相似，且内容不如原博客详细。这里直接贴上原博客，原博客有更丰富、更全面的教程，以方便大家学习，毕竟我自己的学习习惯有些问题，笔记并不一定全面。</p>
<p>原博客：<a href="https://blog.csdn.net/harvic880925/article/details/50995268">Android自定义控件学习三部曲</a></p>
<h1 id="Paint与Canvas"><a href="#Paint与Canvas" class="headerlink" title="Paint与Canvas"></a>Paint与Canvas</h1><p>Paint是画笔，Canvas是画布。画笔可以负责的，比如颜色，粗细，透明度等；而画布负责的，是画笔在画布上画的位置，大小，形状等。所以，搞清楚各部分负责的职能，逻辑会更清晰些。</p>
<p>参数稍后再写，先写怎么能让应用运行起来，这样，在改一些参数设置的时候，就用不着只是看，可以亲自感受变化了。</p>
<h2 id="基本实现方法"><a href="#基本实现方法" class="headerlink" title="基本实现方法"></a>基本实现方法</h2><p>1、先将布局更换为FrameLayout，并添加id，用于添加视图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;FrameLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class="line">    android:id&#x3D;&quot;@+id&#x2F;main_frame&quot;</span><br><span class="line">    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">    tools:context&#x3D;&quot;com.example.administrator.animationtest.activity.MainActivity&quot;&gt;</span><br><span class="line">&lt;&#x2F;FrameLayout&gt;</span><br></pre></td></tr></table></figure>
<p>2、创建一个自定义视图类，继承自View类。在这个类中，重点在于重写OnDraw()函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CustomView extends View &#123;</span><br><span class="line"></span><br><span class="line">    Context context;</span><br><span class="line"></span><br><span class="line">    public CustomView(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        this.context &#x3D; context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">        super.onDraw(canvas);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;示例代码</span><br><span class="line">		&#x2F;&#x2F;设置画笔基本属性</span><br><span class="line">        Paint paint &#x3D; new Paint();</span><br><span class="line">        paint.setAntiAlias(true);           &#x2F;&#x2F;抗锯齿</span><br><span class="line">        paint.setColor(Color.RED);          &#x2F;&#x2F;画笔颜色</span><br><span class="line">        paint.setStyle(Paint.Style.FILL);   &#x2F;&#x2F;填充样式</span><br><span class="line">        paint.setStrokeWidth(5);            &#x2F;&#x2F;画笔宽度</span><br><span class="line">        &#x2F;&#x2F;paint.setShadowLayer(1,15,15,Color.GREEN);      &#x2F;&#x2F;设置阴影</span><br><span class="line"></span><br><span class="line">        canvas.drawRGB(255,255,255);</span><br><span class="line">        &#x2F;&#x2F;画图</span><br><span class="line">        canvas.drawCircle(200,200,150,paint);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、在Activity类中添加绘画显示代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bind(R.id.main_frame) FrameLayout mainFrame;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mainFrame.addView(new CustomView(MainActivity.this));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行效果如下：</p>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/1.jpg" alt></p>
<p>我记得还有一个实现方法，是在布局文件中直接引用view类，不通过addView()方法也可以显示view。但由于忘了一些细节，没办法实现这个操作，所以在这里插个眼，等找到实现方法了TP回来。</p>
<h2 id="Paint的基本参数设置"><a href="#Paint的基本参数设置" class="headerlink" title="Paint的基本参数设置"></a>Paint的基本参数设置</h2><ul>
<li><p>setAntiAlias(Boolean boolean)    设置是否开启抗锯齿</p>
</li>
<li><p>setColor(int color)                设置画笔颜色</p>
</li>
<li><p>setStrokeWidth(int width)        设置画笔宽度</p>
</li>
<li><p>setStyle(Paint.Style style)        设置填充样式</p>
</li>
</ul>
<p>样式有三种：</p>
<p>Paint.Style.FILL                  填充内部</p>
<p>Paint.Style.FILL_AND_STROKE        填充内部以及描边</p>
<p>Paint.STyle.STROKE                仅描边</p>
<p>其中一和二其实没有什么区别。（起初我以为画笔如果够宽，一和二就会有明显的内部、边框之分，但实验过后发现并没有区别）</p>
<ul>
<li>setShadowLayer(float radius, float dx, float dy, int shadowColor)        设置阴影（对图形无效，对字体有效）</li>
</ul>
<p>其中radius指角度，即阴影倾斜度，dx水平位移，dy垂直位移</p>
<h2 id="基本几何图形绘制"><a href="#基本几何图形绘制" class="headerlink" title="基本几何图形绘制"></a>基本几何图形绘制</h2><p>canvas本身就提供了一些基础图形的绘制方法，接下来就是各个方法的使用设置。</p>
<h3 id="一条直线"><a href="#一条直线" class="headerlink" title="一条直线"></a>一条直线</h3><p>方法：drawLine (float startX, float startY, float stopX, float stopY, Paint paint)</p>
<p>参数不用多解释，起点的横纵坐标，终点的横纵坐标，最后就是已经设置好参数的画笔。最后一项参数，在后面的绘制方法里也会有，就不再赘述了。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas.drawLine(100,200,300,400,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/2.png" alt></p>
<h3 id="多条直线"><a href="#多条直线" class="headerlink" title="多条直线"></a>多条直线</h3><ul>
<li>方法：drawLines (float[] pts, Paint paint)</li>
</ul>
<p>由于每个pts的元素，都必须是以四个数，即一组点，即一条线为单位的，所以，在写多条直线的数组时，要<strong>注意数组的元素个数是否符合标准，即数的个数是否能被4整除</strong>。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float []opts&#x3D;&#123;10,10,100,100,200,200,300,300,400,400,500,500&#125;;</span><br><span class="line">canvas.drawLines(opts,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/3.png" alt></p>
<ul>
<li>方法：drawLines (float[] pts, int offset, int count, Paint paint)</li>
</ul>
<p>这个方法与上个方法相比，多出来两个不同的参数。offset表示跳过的数据个数，count表示实际参与绘制的数据个数。什么意思呢？就是在绘制的时候，会先跳过已设置的offset个数的点，只将接下来的count个数的点所构成的直线绘制出来。由此可以得知，两个参数均必须是4的倍数，且两者之和不超过数据的长度。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float []opts&#x3D;&#123;10,10,100,100,200,200,300,300,400,400,500,500&#125;;</span><br><span class="line">canvas.drawLines(opts,4,8,paint);</span><br><span class="line">&#x2F;&#x2F;canvas.drawLines(opts,4,4,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/4.png" alt></p>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/5.png" alt></p>
<p>可以看出来，第一行的运行效果，跳过了第一条直线，显示了第二、三条直线；第二行的运行效果，跳过了第一条直线，只显示了接下来四个点，也就是第二条直线；第三条直线则不再计入绘制。</p>
<h3 id="单个点"><a href="#单个点" class="headerlink" title="单个点"></a>单个点</h3><p>方法：drawPoint (float x, float y, Paint paint)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas.drawPoint(100,100,paint);</span><br></pre></td></tr></table></figure>
<h3 id="多个点"><a href="#多个点" class="headerlink" title="多个点"></a>多个点</h3><ul>
<li><p>方法：drawPoints (float[] pts, Paint paint)</p>
</li>
<li><p>方法：drawPoints (float[] pts, int offset, int count, Paint paint)</p>
</li>
</ul>
<p>这里的方法就跟直线的很类似了，就不再赘述了。</p>
<h3 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h3><p>绘制矩形有两个类：RectF类与Rect类。两个类的区别不大，目前看来的区别是构造参数类型不同。如下：</p>
<ul>
<li><p>RectF(float left, float top, float right, float bottom)</p>
</li>
<li><p>Rect(int left, int top, int right, int bottom)</p>
</li>
</ul>
<p>绘制方法：</p>
<ul>
<li><p>方法：drawRect (float left, float top, float right, float bottom, Paint paint)</p>
</li>
<li><p>方法：drawRect (RectF rect, Paint paint)</p>
</li>
<li><p>方法：drawRect (Rect r, Paint paint)</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas.drawRect(10,10,100,100,paint);</span><br><span class="line">canvas.drawRect(new Rect(120,10,210,100),paint);</span><br><span class="line">canvas.drawRect(new RectF(230,10,320,100),paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/6.png" alt></p>
<h3 id="圆角矩形"><a href="#圆角矩形" class="headerlink" title="圆角矩形"></a>圆角矩形</h3><p>方法：drawRoundRect (RectF rect, float rx, float ry, Paint paint)</p>
<p>这里的rx与ry是指矩形四角生成的椭圆的x轴半径与y轴半径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RectF rectF &#x3D; new RectF(100,100,300,300);</span><br><span class="line">canvas.drawRoundRect(rectF,20,20,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/7.png" alt></p>
<h3 id="圆形"><a href="#圆形" class="headerlink" title="圆形"></a>圆形</h3><p>方法：drawCircle (float cx, float cy, float radius, Paint paint)</p>
<p>这里的cx与cy是指圆心点的x轴与y轴坐标,radius则是圆的半径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas.drawCircle(200,200,100,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/8.png" alt></p>
<h3 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h3><p>椭圆是根据矩形生成的，根据矩形的左顶点与右底点坐标，决定了椭圆的x轴与y轴半径，以及中心点。</p>
<p>方法：drawOval (RectF oval, Paint paint)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RectF rectF &#x3D; new RectF(100,100,300,200);</span><br><span class="line">canvas.drawRect(rectF,paint);</span><br><span class="line"></span><br><span class="line">paint.setColor(Color.RED);</span><br><span class="line">canvas.drawOval(rectF,paint);</span><br></pre></td></tr></table></figure>
<p>为了直观些观察，这里临时将填充样式改为了描边，且将绘制第二个图形的画笔颜色改变一下。</p>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/9.png" alt></p>
<h3 id="弧"><a href="#弧" class="headerlink" title="弧"></a>弧</h3><p>弧是椭圆的一部分，椭圆与矩形相关，所以弧也与矩形相关。</p>
<p>方法：drawArc (RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint)</p>
<p>startAngle是弧开始的角度，sweepAngle是弧持续的角度，useCenter是是否需要弧的两边（详见例图）。<strong>注意，开始角度的起始位置是建立在Android的界面坐标系上的，而不是数学上的坐标系。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">paint.setStyle(Paint.Style.FILL);   &#x2F;&#x2F;填充样式</span><br><span class="line">RectF rectF &#x3D; new RectF(100,100,300,300);</span><br><span class="line">canvas.drawArc(rectF,0,70,true,paint);</span><br><span class="line"></span><br><span class="line">RectF rectF2 &#x3D; new RectF(400,100,600,300);</span><br><span class="line">canvas.drawArc(rectF2,0,70,false,paint);</span><br><span class="line"></span><br><span class="line">paint.setStyle(Paint.Style.STROKE);     &#x2F;&#x2F;描边样式</span><br><span class="line">RectF rectF3 &#x3D; new RectF(100,300,300,500);</span><br><span class="line">canvas.drawArc(rectF3,0,70,true,paint);</span><br><span class="line"></span><br><span class="line">RectF rectF4 &#x3D; new RectF(400,300,600,500);</span><br><span class="line">canvas.drawArc(rectF4,0,70,false,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/10.png" alt></p>
<h2 id="路径绘制图形"><a href="#路径绘制图形" class="headerlink" title="路径绘制图形"></a>路径绘制图形</h2><p>除了通过canvas直接调用绘制图形的专用方法外，还可以通过对path的参数编写并调用drawPath方法，画出想要绘制的图形。其实path有很多方法的参数跟上面的方法都很相似，这下面我就不赘述参数了。</p>
<p>方法：drawPath (Path path, Paint paint)</p>
<h3 id="直线"><a href="#直线" class="headerlink" title="直线"></a>直线</h3><ul>
<li>方法：moveTo (float x, float y)</li>
</ul>
<p>设定直线的起始点</p>
<ul>
<li>方法：lineTo (float x, float y)</li>
</ul>
<p>设定当前直线的终点，也是下一条直线的起始点</p>
<ul>
<li>方法：close ()</li>
</ul>
<p>闭环，即将最后一条直线的终点与第一条的起点连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">paint.setStyle(Paint.Style.FILL);   &#x2F;&#x2F;填充样式</span><br><span class="line"></span><br><span class="line">Path path &#x3D; new Path();</span><br><span class="line">path.moveTo(10,10);</span><br><span class="line">path.lineTo(10,100);</span><br><span class="line">path.lineTo(300,100);</span><br><span class="line">path.lineTo(500,50);</span><br><span class="line">path.close();</span><br><span class="line"></span><br><span class="line">canvas.drawPath(path,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/11.png" alt></p>
<h3 id="矩形-1"><a href="#矩形-1" class="headerlink" title="矩形"></a>矩形</h3><p>方法：addRect (RectF rect, Path.Direction dir)</p>
<p>矩形生成有两个方法，方法的区别主要在于矩形绘制的方向不同，一个是Path.Direction.CCW，为逆时针方向；另一个是Path.Direction.CW，为顺时针方向。为方便观察，可以通过绘制文字的生成路径来观察。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Path CCWpath &#x3D; new Path();</span><br><span class="line">RectF rectF1 &#x3D; new RectF(50,50,240,200);</span><br><span class="line">CCWpath.addRect(rectF1, Path.Direction.CCW);</span><br><span class="line"></span><br><span class="line">Path CWpath &#x3D; new Path();</span><br><span class="line">RectF rectF2 &#x3D; new RectF(290,50,480,200);</span><br><span class="line">CWpath.addRect(rectF2, Path.Direction.CW);</span><br><span class="line"></span><br><span class="line">canvas.drawPath(CCWpath,paint);</span><br><span class="line">canvas.drawPath(CWpath,paint);</span><br><span class="line"></span><br><span class="line">String text &#x3D; &quot;世间安得双全法，不负如来不负卿&quot;;</span><br><span class="line">paint.setColor(Color.RED);</span><br><span class="line">paint.setTextSize(35);</span><br><span class="line">canvas.drawTextOnPath(text,CCWpath,0,18,paint);</span><br><span class="line">canvas.drawTextOnPath(text,CWpath,0,18,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/12.png" alt></p>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/13.png" alt></p>
<h3 id="圆角矩形-1"><a href="#圆角矩形-1" class="headerlink" title="圆角矩形"></a>圆角矩形</h3><p>方法：addRoundRect (RectF rect, float[] radii, Path.Direction dir)</p>
<p>方法：addRoundRect (RectF rect, float rx, float ry, Path.Direction dir)</p>
<p>两个构造函数的区别主要在于第二个参数，即设定矩形的圆角大小。第一个方法可以对每个圆角进行定制，共8个数，方向则取决于绘制的方向，比如逆时针绘制圆角矩形，圆角则从左上角、左下角到右下角、右上角；而第二个方法则统一了每个圆角的大小。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Path path &#x3D; new Path();</span><br><span class="line">RectF rectF1 &#x3D; new RectF(50,50,240,200);</span><br><span class="line">path.addRoundRect(rectF1,10,15, Path.Direction.CCW);</span><br><span class="line"></span><br><span class="line">RectF rectF2 &#x3D; new RectF(290,50,480,200);</span><br><span class="line">float radius[] &#x3D; &#123;10,10,20,20,30,30,40,40&#125;;</span><br><span class="line">path.addRoundRect(rectF2,radius, Path.Direction.CCW);</span><br><span class="line"></span><br><span class="line">canvas.drawPath(path,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/14.png" alt></p>
<h3 id="圆形路径"><a href="#圆形路径" class="headerlink" title="圆形路径"></a>圆形路径</h3><p>方法：addCircle (float x, float y, float radius, Path.Direction dir)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Path path &#x3D; new Path();</span><br><span class="line">path.addCircle(200,200,100, Path.Direction.CCW);</span><br><span class="line">canvas.drawPath(path,paint);</span><br></pre></td></tr></table></figure>
<h3 id="椭圆路径"><a href="#椭圆路径" class="headerlink" title="椭圆路径"></a>椭圆路径</h3><p>方法：addOval (RectF oval, Path.Direction dir)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Path path &#x3D; new Path();</span><br><span class="line">RectF rectF &#x3D; new RectF(100,100,300,500);</span><br><span class="line">path.addOval(rectF, Path.Direction.CCW);</span><br><span class="line"></span><br><span class="line">canvas.drawPath(path,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/15.png" alt></p>
<h3 id="弧形路径"><a href="#弧形路径" class="headerlink" title="弧形路径"></a>弧形路径</h3><p>方法：addArc (RectF oval, float startAngle, float sweepAngle)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Path path &#x3D; new Path();</span><br><span class="line">RectF rectF &#x3D; new RectF(100,100,300,500);</span><br><span class="line">path.addArc(rectF,0,100);</span><br><span class="line"></span><br><span class="line">canvas.drawPath(path,paint);</span><br></pre></td></tr></table></figure>
<h3 id="线段"><a href="#线段" class="headerlink" title="线段"></a>线段</h3><p>方法：quadTo (float x1, float y1, float x2, float y2)</p>
<p>这个方法的特点是绘制的曲线遵循了“贝塞尔曲线”，所以在连续的绘制时看起来会很平滑，这里我也不多深究，也可能以后专门写个博客来描述一下区别吧。这里就贴一下别人的博客好了。</p>
<p>参考博客：<a href="https://blog.csdn.net/stevenhu_223/article/details/9229337">quadTo()方法与lineTo()方法的区别</a></p>
<h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><p>1、Paint相关设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">paint.setColor(Color.RED);                  &#x2F;&#x2F;画笔颜色</span><br><span class="line">paint.setStrokeWidth(5);                    &#x2F;&#x2F;画笔宽度</span><br><span class="line">paint.setAntiAlias(true);                   &#x2F;&#x2F;抗锯齿</span><br><span class="line">paint.setStyle(Paint.Style.FILL);           &#x2F;&#x2F;绘图样式</span><br><span class="line">paint.setTextSize(80);                      &#x2F;&#x2F;文字大小</span><br><span class="line"></span><br><span class="line">paint.setFakeBoldText(true);                &#x2F;&#x2F;是否为粗体</span><br><span class="line">paint.setTextSkewX((float) -0.25);          &#x2F;&#x2F;字体水平倾斜度</span><br><span class="line"></span><br><span class="line">paint.setUnderlineText(true);               &#x2F;&#x2F;下划线</span><br><span class="line">paint.setStrikeThruText(true);              &#x2F;&#x2F;删除线</span><br><span class="line"></span><br><span class="line">paint.setTextAlign(Paint.Align.CENTER);     &#x2F;&#x2F;对齐方式</span><br><span class="line">paint.setTextScaleX(1);                     &#x2F;&#x2F;只会将水平方向拉伸</span><br></pre></td></tr></table></figure>
<p>这就是paint绘制文字时的几个主要设置选项了。画笔颜色、宽度、抗锯齿、文字大小、下划线、删除线等这些很浅显的就不具体展示了，我只对绘图样式、是否为粗体、水平倾斜度、方向拉伸做一下展示，每行字之间至少有三个设置的不同（不包括最后两行的比较，最好两行是是否为粗体和设置阴影的区别）。示例代码及效果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">paint.setFakeBoldText(false);</span><br><span class="line">paint.setTextSkewX((float) -0.25);</span><br><span class="line">paint.setTextScaleX(1);</span><br><span class="line">canvas.drawText(&quot;おれはおまえが好きだ&quot;,10,100,paint);</span><br><span class="line"></span><br><span class="line">paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">paint.setFakeBoldText(false);</span><br><span class="line">paint.setTextSkewX((float) 0.25);</span><br><span class="line">paint.setTextScaleX((float) 0.75);</span><br><span class="line">canvas.drawText(&quot;わたしはあなたが好きだ&quot;,10,200,paint);</span><br><span class="line"></span><br><span class="line">paint.setStyle(Paint.Style.FILL_AND_STROKE);</span><br><span class="line">paint.setFakeBoldText(false);</span><br><span class="line">paint.setTextSkewX((float) -0.25);</span><br><span class="line">paint.setTextScaleX((float) 1.3);</span><br><span class="line">canvas.drawText(&quot;君の名は。&quot;,10,300,paint);</span><br><span class="line"></span><br><span class="line">paint.setShadowLayer(1,15,15,Color.GRAY);</span><br><span class="line">paint.setStyle(Paint.Style.FILL_AND_STROKE);</span><br><span class="line">paint.setFakeBoldText(true);</span><br><span class="line">paint.setTextSkewX((float) -0.25);</span><br><span class="line">paint.setTextScaleX((float) 1.3);</span><br><span class="line">canvas.drawText(&quot;君の名は。&quot;,10,400,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/16.png" alt></p>
<p>还有一个属性是文字对齐方式的区别。其实这里面细致的东西有很多，我在这里放上一篇讲的很细致的文章以供参考。<a href="https://www.jianshu.com/p/8b97627b21c4">博客链接</a>。我这里就只展示一下效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">paint.setTextAlign(Paint.Align.LEFT);</span><br><span class="line">canvas.drawText(&quot;君の名は。&quot;,360,100,paint);</span><br><span class="line"></span><br><span class="line">paint.setTextAlign(Paint.Align.CENTER);</span><br><span class="line">canvas.drawText(&quot;君の名は。&quot;,360,200,paint);</span><br><span class="line"></span><br><span class="line">paint.setTextAlign(Paint.Align.RIGHT);</span><br><span class="line">canvas.drawText(&quot;君の名は。&quot;,360,300,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/17.png" alt></p>
<p>根据设置的位置、属性以及效果可以看出，如果设置左对齐，则文字会以设置的原点为左基准线临界点，向右展开；如果为居中对齐，则文字以原点为基准线中心点；右对齐则为右基准线临界点。</p>
<p>2、canvas绘制文字的函数</p>
<ul>
<li><p>方法：void drawText (String text, float x, float y, Paint paint)</p>
</li>
<li><p>方法：void drawText (CharSequence text, int start, int end, float x, float y, Paint paint)</p>
</li>
</ul>
<p>第一个方法在上面的示例已经用过了，x和y表示位置，不用多说。而第二个方法，则可以额外对传入的字符串进行截取。不过我觉得也可以对字符串进行提前截取，再放入第一个方法，所以暂时想不到第二个方法的优势之处，可能少一行代码也算优势吧。</p>
<ul>
<li><p>方法：void drawPosText (char[] text, int index, int count, float[] pos, Paint paint)</p>
</li>
<li><p>方法：void drawPosText (String text, float[] pos, Paint paint)</p>
</li>
</ul>
<p>这两个方法可以指定要绘制的文字的位置，跟上面一样，位置也是两两数字一组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float pos[]&#x3D;new float[]&#123;10,200,60,300,110,400,160,500,210,600&#125;;</span><br><span class="line">canvas.drawPosText(&quot;君の名は。&quot;,pos,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/18.png" alt></p>
<ul>
<li><p>方法：void drawTextOnPath (String text, Path path, float hOffset, float vOffset, Paint paint)</p>
</li>
<li><p>方法：void drawTextOnPath (char[] text, int index, int count, Path path, float hOffset, float vOffset, Paint paint)</p>
</li>
</ul>
<p>这两个方法属于沿路径绘制，在上面的示例中也已经见过一次了。这里主要讲hOffset、vOffset，hOffset是与路径起始点的<strong>水平</strong>偏移增量，vOffset是与路径中心的垂直偏移增量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String text &#x3D; &quot;君の名は。&quot;;</span><br><span class="line"></span><br><span class="line">Path circlePath &#x3D; new Path();</span><br><span class="line">RectF rectF &#x3D; new RectF(100,100,300,300);</span><br><span class="line">circlePath.addRoundRect(rectF,10,15,Path.Direction.CCW);</span><br><span class="line">canvas.drawPath(circlePath,paint);</span><br><span class="line"></span><br><span class="line">Path circlePath2 &#x3D; new Path();</span><br><span class="line">RectF rectF2 &#x3D; new RectF(400,100,600,300);</span><br><span class="line">circlePath2.addRoundRect(rectF2,10,15, Path.Direction.CCW);</span><br><span class="line">canvas.drawPath(circlePath2,paint);</span><br><span class="line"></span><br><span class="line">canvas.drawTextOnPath(text,circlePath,0,0,paint);</span><br><span class="line">canvas.drawTextOnPath(text,circlePath2,80,30,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/19.png" alt></p>
<p>此外字体还有其他的样式设置等等。个人感觉暂时不会用到，就不做学习了。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>妈耶，我再也不一口气写这么长的博客了。写到后边，总觉得累了，都不想写的很详细了。真佩服那些能写出一本教程书的大佬。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin语法初入门</title>
    <url>/2020/12/14/Kotlin%E8%AF%AD%E6%B3%95%E5%88%9D%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>从 Java 来初入 Kotlin ，因目前在学习阶段，还没有投入到项目中去使用，很多语法规则在学过之后慢慢地忘记了，所以写一写学到的语法，以便回顾。</p>
<p>本文内容来源于《第一行代码》第三版第二章，代码上可能不尽相同，内容上仅仅做一些粗略概括罢了，想细致学习建议参考书籍。</p>
<a id="more"></a>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>声明变量的两个关键字： <strong>val</strong> 和 <strong>var</strong></p>
<blockquote>
<ul>
<li><strong>val</strong> ( value 的简写) 用来声明不可变变量。使用 val 声明的变量经赋值后无法再度赋值。</li>
<li><strong>var</strong> ( variable 的简写) 用来声明可变变量</li>
</ul>
</blockquote>
<p>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val a &#x3D; 10</span><br><span class="line">var b &#x3D; 100</span><br><span class="line">println(&quot;a &#x3D; $a b &#x3D; $b&quot;)</span><br></pre></td></tr></table></figure>
<p>Kotlin 拥有出色的<strong>类型推导机制</strong>，在之上的代码中可窥一斑。必要时，也需要声明变量的类型。其与 Java 中的声明对照如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Java 基本数据类型</th>
<th style="text-align:center">Kotlin 对象数据类型</th>
<th style="text-align:center">数据类型说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">Int</td>
<td style="text-align:center">整数</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">Long</td>
<td style="text-align:center">长整型</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">Short</td>
<td style="text-align:center">短整型</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">Float</td>
<td style="text-align:center">单精度浮点型</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">Double</td>
<td style="text-align:center">双精度浮点型</td>
</tr>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">Byte</td>
<td style="text-align:center">字节</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">Char</td>
<td style="text-align:center">字符</td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">布尔型</td>
</tr>
</tbody>
</table>
</div>
<p>显式声明如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a: Int &#x3D; 10</span><br></pre></td></tr></table></figure>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>常用关键字：<strong>fun</strong>。示例函数体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun method(param1: Int, parma2: Int): Int &#123;</span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小括号之外的 Int 声明了返回的变量类型。再比如如下的函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun largerNumber(param1: Int, param2: Int): Int &#123;</span><br><span class="line">    return max(param1, param2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种函数主体内容仅有一行代码的函数可以简写为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun largerNumber(param1: Int, param2: Int): Int &#x3D; max(param1, param2)</span><br></pre></td></tr></table></figure>
<p>又因为 Kotlin 的类型推导机制，还可以简化为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun largerNumber(param1: Int, param2: Int) &#x3D; max(param1, param2)</span><br></pre></td></tr></table></figure>
<h1 id="控制逻辑部分"><a href="#控制逻辑部分" class="headerlink" title="控制逻辑部分"></a>控制逻辑部分</h1><h2 id="if-与-when"><a href="#if-与-when" class="headerlink" title="if 与 when"></a>if 与 when</h2><p>if 的用法相差不多。比如上面的函数可改写为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun largerNumber(param1: Int, param2: Int): Int &#123;</span><br><span class="line">    return if(param1 &gt; param2)&#123;</span><br><span class="line">        param1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        param2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可简化为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun largerNumber(param1: Int, param2: Int) &#x3D; if(param1 &gt; param2)&#123;</span><br><span class="line">    param1</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    param2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再简化为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun largerNumber(param1: Int, param2: Int) &#x3D; if(param1 &gt; param2) param1 else param2</span><br></pre></td></tr></table></figure>
<h2 id="when"><a href="#when" class="headerlink" title="when"></a>when</h2><p>相当于 Java 中的 switch，又远强于 switch。Java 中的 switch 仅可传入整型，JDK1.7 之后添加了对字符串的支持（我好像从没传过字符串）。而 when 则相当强大。它允许传入任意类型的参数，判断的条件也可以多种多样，格式为：</p>
<blockquote>
<ul>
<li>匹配值 -&gt; {执行逻辑}</li>
</ul>
</blockquote>
<p>常见如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun getPrice(game: String) &#x3D; when(game)&#123;</span><br><span class="line">    &quot;Dark Souls 3&quot; -&gt; 268</span><br><span class="line">    &quot;Devil May Cry 5&quot; -&gt; 137</span><br><span class="line">    &quot;Left 4 Dead 2&quot; -&gt; 37</span><br><span class="line">    else -&gt; 68</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还支持复杂条件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun getPrice(game: String) &#x3D; when&#123;</span><br><span class="line">    game.startsWith(&quot;Dark&quot;) -&gt; 268</span><br><span class="line">    game.endsWith(&quot;Cry 5&quot;) -&gt; 137</span><br><span class="line">    game.contains(&quot;Dead&quot;) -&gt; 37</span><br><span class="line">    else -&gt; 68</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for-in 循环"></a>for-in 循环</h2><p>Kotlin 有以下几种表示区间的写法：</p>
<blockquote>
<ul>
<li>val rangeA = 0..10 表示 [0,10] 。这是一个双端闭区间</li>
<li>val rangeB = 0 util 10 表示 [0,10) 。这是一个单端闭区间</li>
<li>val rangeC = 10 downTo 0 表示[10, 0] 。这也是一个双端闭区间</li>
</ul>
</blockquote>
<p>对于循环，便有了如下写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(i in 0..10)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(i in 0 util 10)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但在以上的循环中，i 是以 1 为差递增的。有时需要改变一下递增规则，则需要用到 <strong>step</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(i in 0 util 10 step 2)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><p>新建一个类，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Game &#123;</span><br><span class="line">    var name &#x3D; &quot;&quot;</span><br><span class="line">    var price &#x3D; 0</span><br><span class="line"></span><br><span class="line">    fun info()&#123;</span><br><span class="line">        println(&quot;The Game : $name is sold in $price on steam&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kotlin 在实例化一个对象时不使用关键字，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun main() &#123;</span><br><span class="line">    val g &#x3D; Game()</span><br><span class="line">    g.name &#x3D; &quot;Dark Souls 3&quot;</span><br><span class="line">    g.price &#x3D; 268</span><br><span class="line">    g.info()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Kotlin 中，[类.属性] = [值] 这一写法相当于 Java 的 set() 方法</p>
<h2 id="继承与构造"><a href="#继承与构造" class="headerlink" title="继承与构造"></a>继承与构造</h2><p>不同于 Java 中一个类本身就可以被继承的默认规则，在 Kotlin 中，这个类需要添加 <strong>open</strong> 关键字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open class Game &#123;</span><br><span class="line">    var name &#x3D; &quot;&quot;</span><br><span class="line">    var price &#x3D; 0</span><br><span class="line"></span><br><span class="line">    fun info()&#123;</span><br><span class="line">        println(&quot;The Game : &quot; + name + &quot; is sold in &quot; + price + &quot; on steam&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，让一个类继承 Game 类。在 Java 中，关键字为 extends，而在 Kotlin 中，则变成了一个冒号，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class RPG : Game() &#123;</span><br><span class="line">    var fullName &#x3D; &quot;&quot;</span><br><span class="line">    var roleName &#x3D; &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒号后的 “Game()” 涉及到了构造函数的问题。每个类都存在一个不带参的主构造函数，比如 Game 类，在实例化时并未带进任何参数， RPG 也是如此。不过，也可以改写为主构造函数带参的形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class RPG (val fullName: String, val roleName: String) : Game() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主构造函数中，被声明了 val 和 var 的变量会成为该类的字段，而未声明的变量则是主构造函数内的局域变量。</p>
<p>这之后实例化 RPG 类的时候就需要携带参数了。那如果 Game 类也变成主构造函数带参后，则继承 Game 类时需要赋予参数，这样一来 RPG 也需要携带一些其他参数，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class RPG (val fullName: String, val roleName: String, name: String, price: String) : Game(name, price) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若是想在主构造函数中做一些初始化操作的话，需要在 init 结构体中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class RPG (val fullName: String, val roleName: String, name: String, price: String) : Game(name, price) &#123;</span><br><span class="line">    init&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，还可以通过 constructor 关键字来定义主构造函数和次构造函数。只不过，在定义主构造函数时，无法用 val 和 var 声明变量，即变量无法变成类的字段，只能作为局域变量使用；在定义次构造函数时与Java差别不大，不再赘述。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h2 id="函数可见性修饰符"><a href="#函数可见性修饰符" class="headerlink" title="函数可见性修饰符"></a>函数可见性修饰符</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">Java</th>
<th style="text-align:center">Kotlin</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">所有类可见</td>
<td style="text-align:center">所有类可见（默认）</td>
</tr>
<tr>
<td style="text-align:center">private</td>
<td style="text-align:center">当前类可见</td>
<td style="text-align:center">当前类可见</td>
</tr>
<tr>
<td style="text-align:center">protect</td>
<td style="text-align:center">当前类、子类、同一包路径下的类可见</td>
<td style="text-align:center">当前类、子类可见</td>
</tr>
<tr>
<td style="text-align:center">default</td>
<td style="text-align:center">当前类、同一包路径下的类可见</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:center">internal</td>
<td style="text-align:center">无</td>
<td style="text-align:center">统一模块中的类可见</td>
</tr>
</tbody>
</table>
</div>
<h2 id="数据类与单例类"><a href="#数据类与单例类" class="headerlink" title="数据类与单例类"></a>数据类与单例类</h2><p>数据类的关键字为 <strong>data</strong>，在 class 前添加，它会帮一个类自动生成 equals()、hashCode()、toString() 等方法</p>
<p>单例类的关键字为 <strong>object</strong>，替换掉 class 即可</p>
<h1 id="Lambda-编程"><a href="#Lambda-编程" class="headerlink" title="Lambda 编程"></a>Lambda 编程</h1><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Kotlin提供了内置的简化初始化集合的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val gameList &#x3D; listOf(&quot;Dark Souls&quot;, &quot;Devil May Cry&quot;, &quot;Sekiro: Shadows Die Twice&quot;, &quot;The Legend Of Zelda&quot;, &quot;Super Mario Odyssey&quot;, &quot;Ori And The Will Of Wisps&quot;)</span><br></pre></td></tr></table></figure>
<p>但是，listOf() 函数创建的是一个不可变的集合，要创建可变集合需要 mutableListOf() 函数</p>
<p>对于 set 集合，函数变成了 setOf() 和 mutableSetOf()</p>
<p>对于 map 集合，写法要特殊一些：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val gameMap &#x3D; mapOf(&quot;Dark Souls&quot; to 268, &quot;Devil May Cry 5&quot; to 137, &quot;Sekito: Shadows Die Twice&quot; to 274, &quot;Ori And The Will Of Wisps&quot; to 90)</span><br><span class="line">for ((game, price) in gameMap)&#123;</span><br><span class="line">    println(&quot;The game : $game is sold in $price on steam.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数式API"><a href="#函数式API" class="headerlink" title="函数式API"></a>函数式API</h2><p>Lambda 表达式在函数式 API 中用的比较多，先说一下语法结构：</p>
<blockquote>
<ul>
<li>{参数名1： 参数类型， 参数名2： 参数类型 -&gt; 函数体}</li>
</ul>
</blockquote>
<h3 id="maxBy-函数"><a href="#maxBy-函数" class="headerlink" title="maxBy 函数"></a>maxBy 函数</h3><p>这是一个提值函数，比如从 gameList 中提出长度最长的 game 单词，先从普通写法开始：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val gameList &#x3D; listOf(&quot;Dark Souls&quot;, &quot;Devil May Cry&quot;, &quot;Sekiro: Shadows Die Twice&quot;, &quot;The Legend Of Zelda&quot;, &quot;Super Mario Odyssey&quot;, &quot;Ori And The Will Of Wisps&quot;)</span><br><span class="line">var maxLengthGame &#x3D; &quot;&quot;</span><br><span class="line">for (game in gameList)&#123;</span><br><span class="line">    if (game.length &gt; maxLengthGame.length)&#123;</span><br><span class="line">        maxLengthGame &#x3D; game</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">println(&quot;max length game is $maxLengthGame&quot;)</span><br></pre></td></tr></table></figure>
<p>此时先了解一个函数：maxBy。它可以根据传入的条件来遍历集合，从而找到最大值，那么此时的条件就是单词的长度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val gameList &#x3D; listOf(&quot;Dark Souls&quot;, &quot;Devil May Cry&quot;, &quot;Sekiro: Shadows Die Twice&quot;, &quot;The Legend Of Zelda&quot;, &quot;Super Mario Odyssey&quot;, &quot;Ori And The Will Of Wisps&quot;)</span><br><span class="line">var lambda &#x3D; &#123; game: String -&gt; game.length&#125;</span><br><span class="line">var maxLengthGame &#x3D; gameList.maxBy(lambda)</span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var maxLengthGame &#x3D; gameList.maxBy(&#123; game: String -&gt; game.length&#125;)</span><br></pre></td></tr></table></figure>
<p>当 lambda 参数是函数最后一个参数时，可将表达式移出括号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var maxLengthGame &#x3D; gameList.maxBy() &#123; game: String -&gt; game.length&#125;</span><br></pre></td></tr></table></figure>
<p>当 lambda 参数是函数唯一一个参数时，可将函数括号省略：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var maxLengthGame &#x3D; gameList.maxBy &#123; game: String -&gt; game.length&#125;</span><br></pre></td></tr></table></figure>
<p>介于 Kotlin 的类型推导机制，对参数类型的声明可省略：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var maxLengthGame &#x3D; gameList.maxBy &#123; game -&gt; game.length&#125;</span><br></pre></td></tr></table></figure>
<p>当 lambda 表达式中只有一个参数时，不必声明参数名，条件里的参数名可用 it 来代替：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var maxLengthGame &#x3D; gameList.maxBy &#123; it.length&#125;</span><br></pre></td></tr></table></figure>
<h3 id="map-函数"><a href="#map-函数" class="headerlink" title="map 函数"></a>map 函数</h3><p>这是一个映射函数，同上映射规则在 lambda 表达式中指定，最终生成一个新的集合。比如将单词名全部变为大写模式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val gameList &#x3D; listOf(&quot;Dark Souls&quot;, &quot;Devil May Cry&quot;, &quot;Sekiro: Shadows Die Twice&quot;, &quot;The Legend Of Zelda&quot;, &quot;Super Mario Odyssey&quot;, &quot;Ori And The Will Of Wisps&quot;)</span><br><span class="line">val newList &#x3D; gameList.map &#123; it.toUpperCase() &#125;</span><br><span class="line">for (game in newList)&#123;</span><br><span class="line">    println(game)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter 函数"></a>filter 函数</h3><p>这是一个过滤函数，示例用法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val gameList &#x3D; listOf(&quot;Dark Souls&quot;, &quot;Devil May Cry&quot;, &quot;Sekiro: Shadows Die Twice&quot;, &quot;The Legend Of Zelda&quot;, &quot;Super Mario Odyssey&quot;, &quot;Ori And The Will Of Wisps&quot;)</span><br><span class="line">val newList &#x3D; gameList.filter &#123; it.length &lt;&#x3D; 20 &#125;</span><br><span class="line">        .map &#123; it.toUpperCase() &#125;</span><br><span class="line">for (game in newList)&#123;</span><br><span class="line">    println(game)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="any-amp-all-函数"><a href="#any-amp-all-函数" class="headerlink" title="any &amp; all 函数"></a>any &amp; all 函数</h3><p>这是两个判断函数，any 函数用于判断集合中是否至少存在一个元素满足条件，而 all 函数用于判断是否全部元素满足条件，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val gameList &#x3D; listOf(&quot;Dark Souls&quot;, &quot;Devil May Cry&quot;, &quot;Sekiro: Shadows Die Twice&quot;, &quot;The Legend Of Zelda&quot;, &quot;Super Mario Odyssey&quot;, &quot;Ori And The Will Of Wisps&quot;)</span><br><span class="line">val anyResult &#x3D; gameList.any &#123; it.startsWith(&quot;Dark&quot;) &#125;</span><br><span class="line">val allResult &#x3D; gameList.all &#123; it.length &gt; 10 &#125;</span><br><span class="line">println(&quot;anyResult is $anyResult, allResult is $allResult&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="Java-函数式-API"><a href="#Java-函数式-API" class="headerlink" title="Java 函数式 API"></a>Java 函数式 API</h2><p>使用函数式 API  有一定的限制条件，就是调用的方法是单个Java单抽象方法接口参数。示例，创建一个线程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread(object : Runnable&#123;</span><br><span class="line">    override fun run() &#123;</span><br><span class="line">        println(&quot;Thread is running&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start()</span><br></pre></td></tr></table></figure>
<p>创建匿名类实例的时候，Kotlin 需要用关键字 object 来声明。接下来进行简化。因 Runnable 类中只有一个待实现方法，指 run() 方法，Kotlin 能自动明白 Runnable 后面的 Lambda 表达式就是要在 run() 方法中实现的内容。可简化为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread(Runnable&#123;</span><br><span class="line">    println(&quot;Thread is running&quot;)</span><br><span class="line">&#125;).start()</span><br></pre></td></tr></table></figure>
<p>若方法的参数列表内仅有一个Java单抽象方法接口参数，可对接口名进行省略：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread(&#123;</span><br><span class="line">    println(&quot;Thread is running&quot;)</span><br><span class="line">&#125;).start()</span><br></pre></td></tr></table></figure>
<p>根据在 maxBy 函数环节的最后且唯一函数为 Lambda 表达式时，可将 () 省略：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread &#123;</span><br><span class="line">    println(&quot;Thread is running&quot;)</span><br><span class="line">&#125; .start()</span><br></pre></td></tr></table></figure>
<p>这种写法在后面会用的很多。</p>
<h1 id="空指针检查"><a href="#空指针检查" class="headerlink" title="空指针检查"></a>空指针检查</h1><p>在 Kotlin 中，编译时期就存在对空指针异常的检查。它提供了一个可为空的类型系统和一个 <strong>?</strong> 。比如，Int 表示不可为空的整型，而 Int? 就表示可为空的整型。</p>
<h2 id="判空辅助工具"><a href="#判空辅助工具" class="headerlink" title="判空辅助工具"></a>判空辅助工具</h2><h3 id><a href="#" class="headerlink" title="?."></a>?.</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a?.doSomething()</span><br></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (a !&#x3D; null)&#123;</span><br><span class="line">    a.doSomething()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="-1"><a href="#-1" class="headerlink" title="?:"></a>?:</h3><p>这个操作符的左右两边各接收一个表达式，结果不为空则返回左边表达式的结果，否则返回右边表达式的结果，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val c &#x3D; a ?: c</span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val c &#x3D; if (a !&#x3D; null)&#123;</span><br><span class="line">    a</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="-2"><a href="#-2" class="headerlink" title="!!"></a>!!</h3><p>如果确信某处的对象不会为空，不必做空指针检查，则在对象后加上 !! ，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a!!.doSomething()</span><br></pre></td></tr></table></figure>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>let 是一个函数，它可以处理变量的判空问题。用法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a?.doSomething()</span><br><span class="line">a?.doElse()</span><br></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a?.let &#123; a -&gt;</span><br><span class="line">    a.doSomething()</span><br><span class="line">    a.doElse()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又介于 Lambda 的表达式，可简化为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a?.let &#123;</span><br><span class="line">    it.doSomething()</span><br><span class="line">    it.doElse()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="一些-Kotlin-小常识"><a href="#一些-Kotlin-小常识" class="headerlink" title="一些 Kotlin 小常识"></a>一些 Kotlin 小常识</h1><h2 id="字符串内嵌表达式"><a href="#字符串内嵌表达式" class="headerlink" title="字符串内嵌表达式"></a>字符串内嵌表达式</h2><p>在表达式中，用 ${} 来替代之前的 + ，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val game &#x3D; Game(&quot;Dark Souls&quot;, &quot;268&quot;)</span><br><span class="line">println(&quot;The game name is $&#123;game.name&#125;. The Price is $&#123;game.price&#125;.&quot;)</span><br></pre></td></tr></table></figure>
<p>如果字段不是 类.属性 这样的情况，则可以省略 {}:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val ff7game &#x3D; &quot;Final Fantasy VII&quot;</span><br><span class="line">val ff7price &#x3D; 40</span><br><span class="line">println(&quot;Another game is $ff7game. Its price is $ff7price.&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h2><p>先看一下示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun printPrice(game: String, price: Int &#x3D; 428)&#123;</span><br><span class="line">    println(&quot;The game $game is sold price in $price on Steam.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用情况如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printPrice(&quot;Tomb Raider: Shadow&quot;)</span><br></pre></td></tr></table></figure>
<p>但这个函数的参数情况比较特殊，默认参数正好是第二位。如果默认参数改到第一位，代码就会报错。这时候 Kotlin 提供了键值对的方法来对参数赋值，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun printPrice(price: Int &#x3D; 428, game: String)&#123;</span><br><span class="line">    println(&quot;The game $game is sold price in $price on Steam.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用时变为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printPrice(game &#x3D; &quot;Tomb Raider: Shadow&quot;)</span><br></pre></td></tr></table></figure>
<p>这个方法还可以用到类的主构造函数中去：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Game (val name: String &#x3D; &quot;Dark Souls 3: Deluxe Edition&quot;, val price: String &#x3D; &quot;396&quot;) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="标准函数与静态方法"><a href="#标准函数与静态方法" class="headerlink" title="标准函数与静态方法"></a>标准函数与静态方法</h1><h2 id="with、run、apply-函数"><a href="#with、run、apply-函数" class="headerlink" title="with、run、apply 函数"></a>with、run、apply 函数</h2><h3 id="with-函数"><a href="#with-函数" class="headerlink" title="with 函数"></a>with 函数</h3><p>它接收两个参数：第一个是一个任意类型的对象；第二个是 Lambda 表达式。大致结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val result &#x3D; with(obj) &#123;</span><br><span class="line">    &quot;value&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val gameList &#x3D; listOf(&quot;Dark Souls&quot;, &quot;Devil May Cry&quot;, &quot;The Legend Of Zelda&quot;, &quot;Sekiro: Shadows Die Twice&quot;, &quot;Call Of Duty&quot;)</span><br><span class="line">val builder &#x3D; StringBuilder()</span><br><span class="line">builder.append(&quot;Start playing games: \n&quot;)</span><br><span class="line">for (index in gameList.indices)&#123;</span><br><span class="line">    builder.append(index).append(&quot;: &quot;).append(gameList[index]).append(&quot;\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line">builder.append(&quot;That&#39;s all.&quot;)</span><br><span class="line">val result &#x3D; builder.toString()</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure>
<p>可以改写为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val gameList &#x3D; listOf(&quot;Dark Souls&quot;, &quot;Devil May Cry&quot;, &quot;The Legend Of Zelda&quot;, &quot;Sekiro: Shadows Die Twice&quot;, &quot;Call Of Duty&quot;)</span><br><span class="line">val result &#x3D; with(StringBuilder()) &#123;</span><br><span class="line">    append(&quot;Start playing games: \n&quot;)</span><br><span class="line">    for (index in gameList.indices)&#123;</span><br><span class="line">        append(index).append(&quot;: &quot;).append(gameList[index]).append(&quot;\n&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    append(&quot;That&#39;s all&quot;)</span><br><span class="line">    toString()</span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure>
<h3 id="run-函数"><a href="#run-函数" class="headerlink" title="run 函数"></a>run 函数</h3><p>run 函数的大致结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val result &#x3D; obj.run &#123;</span><br><span class="line">    &quot;value&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val gameList &#x3D; listOf(&quot;Dark Souls&quot;, &quot;Devil May Cry&quot;, &quot;The Legend Of Zelda&quot;, &quot;Sekiro: Shadows Die Twice&quot;, &quot;Call Of Duty&quot;)</span><br><span class="line">val result &#x3D; StringBuilder().run &#123; </span><br><span class="line">    append(&quot;Start playing games: \n&quot;)</span><br><span class="line">    for (index in gameList.indices)&#123;</span><br><span class="line">        append(index).append(&quot;: &quot;).append(gameList[index]).append(&quot;\n&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    append(&quot;That&#39;s all.&quot;)</span><br><span class="line">    toString()</span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure>
<h3 id="apply-函数"><a href="#apply-函数" class="headerlink" title="apply 函数"></a>apply 函数</h3><p>apply 函数与 run 函数类似，但在返回结果上还是存在一定差异的。run 函数返回的对象是最后一行的运算结果，而 apply 函数返回的对象还是调用的对象本身。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val gameList &#x3D; listOf(&quot;Dark Souls&quot;, &quot;Devil May Cry&quot;, &quot;The Legend Of Zelda&quot;, &quot;Sekiro: Shadows Die Twice&quot;, &quot;Call Of Duty&quot;)</span><br><span class="line">val result &#x3D; StringBuilder().apply &#123;</span><br><span class="line">    append(&quot;Start playing games: \n&quot;)</span><br><span class="line">    for (index in gameList.indices)&#123;</span><br><span class="line">        append(index).append(&quot;: &quot;).append(gameList[index]).append(&quot;\n&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    append(&quot;That&#39;s all.&quot;)</span><br><span class="line">    toString()</span><br><span class="line">&#125;</span><br><span class="line">println(result.javaClass)</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure>
<p>其中，输出结果中表明 result 本身还是 StringBuilder, 并未变为 String：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class java.lang.StringBuilder</span><br></pre></td></tr></table></figure>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>在 Java 中，在方法前加上 static 即可。但由于 Kotlin 极度弱化了静态方法这个概念，所以在 Kotlin 中定义一个静态方法要麻烦一些。</p>
<p>首先，要知道在 Kotlin 中，使用单例类的写法会将整个类中的所有方法变成类似于静态方法的调用方式。故要先将单例类变为一个普通类，即将 object 变为 class。然后，将方法放在 companion object 结构体中，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Util &#123;</span><br><span class="line">    </span><br><span class="line">    fun doAction1()&#123;</span><br><span class="line">        println(&quot;do action 1&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line"></span><br><span class="line">        fun doAction2()&#123;</span><br><span class="line">            println(&quot;do action 2&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时就可以直接使用 Util.doAction2() 的方式调用。不过，这样也并不是静态方法，companion object 这个关键字会在 Util 类的内部创建一个伴生类，而 doAction2() 方法就是这个伴生类的实例方法。</p>
<p>若要真正地定义一个静态方法，则有两种方式：注解和顶层方法。</p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>在普通类的 companion object 的结构体内的方法前添加 @JvmStatic 注解，或在单例类的方法上添加 @JvmStatic 注解，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Util &#123;</span><br><span class="line">    </span><br><span class="line">    fun doAction()&#123;</span><br><span class="line">        println(&quot;do Action 1&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line"></span><br><span class="line">        @JvmStatic</span><br><span class="line">        fun doAction2()&#123;</span><br><span class="line">            println(&quot;do Action 2&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">object Singleton &#123;</span><br><span class="line"></span><br><span class="line">    @JvmStatic</span><br><span class="line">    fun singletonTest()&#123;</span><br><span class="line">        println(&quot;Now it&#39;s singleton test.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="顶层方法"><a href="#顶层方法" class="headerlink" title="顶层方法"></a>顶层方法</h3><p>新建一个 File 文件（后缀为 .kt），那么这个文件中定义的任何方法都将是顶层方法。</p>
<h1 id="扩展函数与运算符重载"><a href="#扩展函数与运算符重载" class="headerlink" title="扩展函数与运算符重载"></a>扩展函数与运算符重载</h1><h2 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h2><p>一般来说，当需要编写一个新的工具方法时，在 Java 里往往会新建一个 Util 类并编写方法。在 Kotlin 中，则可以通过使用扩展函数的方式来完成。语法结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun ClassName.methodName(param1: Int, param2: Int): Int &#123;</span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ClassName 可以与一些常见类同名，文件名也可同名，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun String.lettersCount(): Int &#123;</span><br><span class="line">    var count &#x3D; 0</span><br><span class="line">    for (char in this) &#123;</span><br><span class="line">        if (char.isLetter()) &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val info &#x3D; &quot;My favorite game is Dark Souls 3&quot;</span><br><span class="line">println(&quot;这句话含有 $&#123;info.lettersCount()&#125; 个字符&quot;)</span><br></pre></td></tr></table></figure>
<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>一些算法题</title>
    <url>/2021/04/13/%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    <content><![CDATA[<p>以训练一下自己的思维</p>
<p><a href="https://github.com/Blankj/awesome-java-leetcode">原文地址</a></p>
<a id="more"></a>
<h1 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h1><p><a href="https://github.com/Blankj/awesome-java-leetcode/blob/master/note/0001/README.md">查看原文</a></p>
<p>给定一个整数数组，返回两个数字的索引，以使它们加起来成为一个特定的目标。</p>
<p>您可以假设每个输入都只有一个解决方案，并且您可能不会两次使用相同的元素。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure>
<h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>与思路 0 一致，实现的时候<strong>多了一步转化为 list 的步骤</strong>。这一步不该做，因为<strong>占用了更多的时间和内存空间</strong>，以后少做。此外此方法的<strong>复杂度为$O(n^2)$</strong>，如果样本容量大一些，花费时间会更多。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int[] twoNums(int[] nums, int target)&#123;</span><br><span class="line">    List&lt;Integer&gt; tempNumList &#x3D; Arrays.stream(nums).boxed().collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    if (tempNumList.size() &gt; 0) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; tempNumList.size() - 1; i++) &#123;</span><br><span class="line">            for (int j &#x3D; i + 1; j &lt; tempNumList.size(); j++) &#123;</span><br><span class="line">                if (tempNumList.get(i) + tempNumList.get(j) &#x3D;&#x3D; target)&#123;</span><br><span class="line">                    return new int[]&#123;i ,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="推荐方法"><a href="#推荐方法" class="headerlink" title="推荐方法"></a>推荐方法</h2><p>利用 HashMap 作为存储媒介，<strong>键值为目标值减去当前元素值的差值，而值则是当前元素值的索引</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int[] twoNums(int[] nums, int target)&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; hashMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        Integer value &#x3D; hashMap.get(nums[i]);</span><br><span class="line">        if (value !&#x3D; null)&#123;</span><br><span class="line">            return new int[]&#123;value, i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        hashMap.put(target - nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例说明方法原理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums &#x3D; [3,8,4,6,9,2,15,11], target &#x3D; 13</span><br></pre></td></tr></table></figure>
<p>循环时：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">数组</th>
<th style="text-align:center">3</th>
<th style="text-align:center">8</th>
<th style="text-align:center">4</th>
<th style="text-align:center">6</th>
<th style="text-align:center">9</th>
<th style="text-align:center">2</th>
<th style="text-align:center">15</th>
<th style="text-align:center">11</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">key</td>
<td style="text-align:center">10</td>
<td style="text-align:center">5</td>
<td style="text-align:center">9</td>
<td style="text-align:center">7</td>
<td style="text-align:center">4</td>
<td style="text-align:center">11</td>
<td style="text-align:center">-2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">value（index）</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
</tr>
</tbody>
</table>
</div>
<h2 id="学习点"><a href="#学习点" class="headerlink" title="学习点"></a>学习点</h2><blockquote>
<ul>
<li>利用 HashMap 的存储机制，保存了差值（逆向思维）（也是寻找的元素值）的同时，还保存了原元素值的索引值。复杂度或许还是$O(n^2)$，不过，是 0…n 的变化，所以在可接受范围内。</li>
<li>整数数组转化为 List 的方法： Arrays.stream(nums).boxed().collect(Collectors.toList())</li>
<li>List 为顺序表结果，方便访问，不方便设计元素的插入、删除和移动等操作</li>
<li>int 不可与 null 值放在一起判断，但 Integer 可以</li>
</ul>
</blockquote>
<h1 id="逆序整数"><a href="#逆序整数" class="headerlink" title="逆序整数"></a>逆序整数</h1><p><a href="https://github.com/Blankj/awesome-java-leetcode/blob/master/note/0007/README.md">查看原文</a></p>
<p>给定一个32位带符号整数，求该整数的逆序整数。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 123</span><br><span class="line">Output:  321</span><br><span class="line"></span><br><span class="line">Input: -123</span><br><span class="line">Output: -321</span><br><span class="line"></span><br><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure>
<h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>第一反应用字符串转换，简单，但感觉思想有些僵化。想了下，还是用数学的方式解决。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int reverseNumber(long number)&#123;</span><br><span class="line">    long tempNumber &#x3D; 0;</span><br><span class="line">    for (; number !&#x3D; 0 ; number &#x3D; number &#x2F; 10) &#123;</span><br><span class="line">        tempNumber &#x3D; tempNumber * 10 + number % 10;</span><br><span class="line">    &#125;</span><br><span class="line">    if (tempNumber &gt; Integer.MAX_VALUE || tempNumber &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return (int) tempNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这次思路与原文思路对上了，只是代码上还有些优化空间。</p>
<h2 id="学习点-1"><a href="#学习点-1" class="headerlink" title="学习点"></a>学习点</h2><blockquote>
<ul>
<li>number = number / 10 可以简写为 number /= 10，我记错了简写方式</li>
<li>最后的返回可简写为条件赋值语句 return tempNumber &gt; Integer.MAX_VALUE || tempNumber &lt; Integer.MIN_VALUE ? 0 : (int) tempNumber;</li>
</ul>
</blockquote>
<h1 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h1><p><a href="https://github.com/Blankj/awesome-java-leetcode/blob/master/note/0009/README.md">查看原文</a></p>
<p>确定整数是否是回文。 整数与回读相同时就是回文。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 121</span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Input: -121</span><br><span class="line">Output: false</span><br><span class="line">Explanation：从左到右，它显示为-121。从右到左，它变为121-。因此，它不是回文。</span><br><span class="line"></span><br><span class="line">Input: 10</span><br><span class="line">Output: false</span><br><span class="line">Explanation: 从右到左读取01。因此，它不是回文。</span><br></pre></td></tr></table></figure>
<h2 id="我的思路："><a href="#我的思路：" class="headerlink" title="我的思路："></a>我的思路：</h2><p>负数一律不是回文数，正整数则转换后比较即可。关键代码上个问题已给出，此处略。</p>
<h2 id="推荐思路"><a href="#推荐思路" class="headerlink" title="推荐思路"></a>推荐思路</h2><p>负数、<strong>10的整倍数</strong>均不是回文数。且不必比较全部长度，在回文计算过程中，适时比较即可完成判断。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static boolean isPalindrome(int x) &#123;</span><br><span class="line">    if (x &lt; 0 || (x !&#x3D; 0 &amp;&amp; x % 10 &#x3D;&#x3D; 0)) return false;</span><br><span class="line">    int halfReverseX &#x3D; 0;</span><br><span class="line">    while (x &gt; halfReverseX) &#123;</span><br><span class="line">        halfReverseX &#x3D; halfReverseX * 10 + x % 10;</span><br><span class="line">        x &#x2F;&#x3D; 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return halfReverseX &#x3D;&#x3D; x || halfReverseX &#x2F; 10 &#x3D;&#x3D; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="学习点-2"><a href="#学习点-2" class="headerlink" title="学习点"></a>学习点</h2><blockquote>
<ul>
<li>试着优化及改变一个问题的判断条件和判断方式</li>
<li>可以提前筛选掉的特殊情况考虑不周全。不过这个问题不大，只要在关键判断部分解决掉也可。</li>
</ul>
</blockquote>
<h1 id="罗马数"><a href="#罗马数" class="headerlink" title="罗马数"></a>罗马数</h1><p><a href="https://github.com/Blankj/awesome-java-leetcode/blob/master/note/0013/README.md">原文地址</a></p>
<p>罗马数字由七个不同的符号表示：I，V，X，L，C，D和M。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>
<p>例如，两个用罗马数字记为II，仅将两个加在一起。 十二被写为XII，简称X + II。 数字二十七写为XXVII，即XX + V + II。</p>
<p>罗马数字通常从左到右以从大到小的顺序书写。 但是，四个数字不是IIII。 取而代之的是，数字四被写为IV。 因为一个在五之前，所以我们减去它等于四。 相同的原则适用于编号为IX的数字9。 在六个实例中使用减法：</p>
<p>我可以放在V（5）和X（10）的前面以得到4和9。<br>X可以放在L（50）和C（100）之前以得到40和90。<br>C可以放在D（500）和M（1000）之前以得到400和900。<br>给定罗马数字，将其转换为整数。 输入保证在1到3999的范围内。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;III&quot;</span><br><span class="line">Output: 3</span><br><span class="line"></span><br><span class="line">Input: &quot;IV&quot;</span><br><span class="line">Output: 4</span><br><span class="line"></span><br><span class="line">Input: &quot;IX&quot;</span><br><span class="line">Output: 9</span><br><span class="line"></span><br><span class="line">Input: &quot;LVIII&quot;</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: C &#x3D; 100, L &#x3D; 50, XXX &#x3D; 30 and III &#x3D; 3.</span><br><span class="line"></span><br><span class="line">Input: &quot;MCMXCIV&quot;</span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90 and IV &#x3D; 4.</span><br></pre></td></tr></table></figure>
<h2 id="我的思路-2"><a href="#我的思路-2" class="headerlink" title="我的思路"></a>我的思路</h2><p>很惭愧，无。看了推荐思路，拍手叫好，又是逆向思维。</p>
<h2 id="推荐思路-1"><a href="#推荐思路-1" class="headerlink" title="推荐思路"></a>推荐思路</h2><p>题意是罗马数字转整型数，范围从 1 到 3999，查看下百度百科的罗马数字介绍如下：</p>
<p>相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ=3；</p>
<p>小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数，如 Ⅷ=8、Ⅻ=12；</p>
<p>小的数字（限于 Ⅰ、X 和 C）在大的数字的左边，所表示的数等于大数减小数得到的数，如 Ⅳ=4、Ⅸ=9。</p>
<p>那么我们可以利用 map 来完成罗马数字的 7 个数字符号：I、V、X、L、C、D、M 和整数的映射关系，然后根据上面的解释来模拟完成即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int romanToInt(String roman) &#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    map.put(&#39;I&#39;, 1);</span><br><span class="line">    map.put(&#39;V&#39;, 5);</span><br><span class="line">    map.put(&#39;X&#39;, 10);</span><br><span class="line">    map.put(&#39;L&#39;, 50);</span><br><span class="line">    map.put(&#39;C&#39;, 100);</span><br><span class="line">    map.put(&#39;D&#39;, 500);</span><br><span class="line">    map.put(&#39;M&#39;, 1000);</span><br><span class="line">    int res &#x3D; map.get(roman.charAt(roman.length() - 1));</span><br><span class="line">    for (int i &#x3D; roman.length() - 1; i &gt; 0; i--)&#123;</span><br><span class="line">        int value1 &#x3D; map.get(roman.charAt(i));</span><br><span class="line">        int value2 &#x3D; map.get(roman.charAt(i - 1));</span><br><span class="line">        res &#x3D; value1 &gt; value2 ? res - value2 : res + value2;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="学习点-3"><a href="#学习点-3" class="headerlink" title="学习点"></a>学习点</h2><blockquote>
<ul>
<li>主要还是没有想到解决这个问题的思路，分析不够仔细，思维不够发散</li>
<li>字符型的声明关键字是 Character 不是 CharSequence</li>
</ul>
</blockquote>
<h1 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h1><p><a href="https://github.com/Blankj/awesome-java-leetcode/blob/master/note/0014/README.md">查看原文</a></p>
<p>编写一个函数以在字符串数组中找到最长的公共前缀字符串。</p>
<p>如果没有公共前缀，则返回一个空字符串“”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br><span class="line"></span><br><span class="line">Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br></pre></td></tr></table></figure>
<h2 id="我的思路-3"><a href="#我的思路-3" class="headerlink" title="我的思路"></a>我的思路</h2><p>一开始看错了题目，以为是找最长公共子字符串，后来才发现是前缀。先找出长度最短的字符串，再截取其前缀逐个比较，返回结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String longestCommonPrefix(String[] inputs)&#123;</span><br><span class="line">    String shortestStr &#x3D; inputs[0];</span><br><span class="line">    for (String str : inputs)&#123;</span><br><span class="line">        if (str.length() &lt; shortestStr.length()) &#123;</span><br><span class="line">            shortestStr &#x3D; str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String prefix &#x3D; &quot;&quot;;</span><br><span class="line">    boolean allEquals &#x3D; true;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; shortestStr.length(); i++) &#123;</span><br><span class="line">        prefix &#x3D; shortestStr.substring(0, i);</span><br><span class="line">        for (String str: inputs)&#123;</span><br><span class="line">            if (str.indexOf(prefix) !&#x3D; 0)&#123;</span><br><span class="line">                allEquals &#x3D; false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!allEquals) &#123;</span><br><span class="line">            prefix &#x3D; shortestStr.substring(0, i - 1);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return prefix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="推荐思路-2"><a href="#推荐思路-2" class="headerlink" title="推荐思路"></a>推荐思路</h2><p>找出最短的那个字符串的长度 minLen，然后在 0…minLen 的范围比较所有字符串，如果比较到有不同的字符，那么直接返回当前索引长度的字符串即可，否则最后返回最短的字符串即可。</p>
<p>而且再一次体现出了我代码功力与推荐答案的差距。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">    int len &#x3D; strs.length;</span><br><span class="line">    if (len &#x3D;&#x3D; 0) return &quot;&quot;;</span><br><span class="line">    int minLen &#x3D; 0x7fffffff;</span><br><span class="line">    for (String str : strs) minLen &#x3D; Math.min(minLen, str.length());</span><br><span class="line">    for (int j &#x3D; 0; j &lt; minLen; ++j)</span><br><span class="line">        for (int i &#x3D; 1; i &lt; len; ++i)</span><br><span class="line">            if (strs[0].charAt(j) !&#x3D; strs[i].charAt(j))</span><br><span class="line">                return strs[0].substring(0, j);</span><br><span class="line">    return strs[0].substring(0, minLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="学习点-4"><a href="#学习点-4" class="headerlink" title="学习点"></a>学习点</h2><blockquote>
<ul>
<li>Math.min()方法可以比较两个数之间的大小并返回值, 比 if 判断语句方便阅读</li>
<li>Integer.MAX_VALUE = 0x7fffffff, Integer.MIN_VALUE = 0x80000000</li>
</ul>
</blockquote>
<h1 id="跳水板"><a href="#跳水板" class="headerlink" title="跳水板"></a>跳水板</h1><p><a href="https://github.com/Blankj/awesome-java-leetcode/blob/master/note/16_11/README.md">查看原文</a></p>
<p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为 shorter，长度较长的木板长度为 longer。你必须正好使用 k 块木板。编写一个方法，生成跳水板所有可能的长度。</p>
<p>返回的长度需要从小到大排列。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inputs：</span><br><span class="line">shorter &#x3D; 1</span><br><span class="line">longer &#x3D; 2</span><br><span class="line">k &#x3D; 3</span><br><span class="line">outputs： </span><br><span class="line">&#123;3,4,5,6&#125;</span><br><span class="line"></span><br><span class="line">0 &lt; shorter &lt;&#x3D; longer</span><br><span class="line">0 &lt;&#x3D; k &lt;&#x3D; 100000</span><br></pre></td></tr></table></figure>
<h2 id="我的思路-4"><a href="#我的思路-4" class="headerlink" title="我的思路"></a>我的思路</h2><p>这个问题还算好的，只有两种木板。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static List dividingBoard(int shorter, int longer, int k)&#123;</span><br><span class="line">    if (k &#x3D;&#x3D; 0) return null;</span><br><span class="line">    List&lt;Integer&gt; dataList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    if (shorter &#x3D;&#x3D; longer) &#123;</span><br><span class="line">        dataList.add(shorter * k);</span><br><span class="line">        return dataList;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; k; i++)&#123;</span><br><span class="line">        dataList.add(i * shorter + (k - i) * longer);</span><br><span class="line">    &#125;</span><br><span class="line">    return dataList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="推荐思路-3"><a href="#推荐思路-3" class="headerlink" title="推荐思路"></a>推荐思路</h2><p>这题乍一看，好像得用递归或动态规划来解，仔细一想，其实就是高中数学学过的等差数列知识。</p>
<p>当 k == 0 时，返回 [] 即可；</p>
<p>当 shorter == longer 时，返回 [k * shorter] 即可；</p>
<p>当 shorter != longer 时，那么其实就是一个首项为 k <em> shorter，末项为 k </em> longer，公差为 longer - shorter 的等差数列么。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int[] divingBoard(int shorter, int longer, int k) &#123;</span><br><span class="line">    if (k &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return new int[0];</span><br><span class="line">    &#125;</span><br><span class="line">    if (shorter &#x3D;&#x3D; longer) &#123;</span><br><span class="line">        return new int[]&#123;shorter * k&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    int[] ans &#x3D; new int[k + 1];</span><br><span class="line">    int st &#x3D; k * shorter;&#x2F;&#x2F; 等差数列的首项</span><br><span class="line">    int delta &#x3D; longer - shorter;&#x2F;&#x2F; 公差</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; k; i++) &#123;</span><br><span class="line">        ans[i] &#x3D; st + i * delta;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="学习点-5"><a href="#学习点-5" class="headerlink" title="学习点"></a>学习点</h2><p>我就知道，算法的归路终是数学。而且如果按照 ACM 的标准来判断我的答案，返回类型是不符合标准的。</p>
<blockquote>
<ul>
<li>算法问题，终归是数学问题。有时候答案就藏在已经学过的数学公式中，以前做 ACM 的时候就有这种感觉了</li>
</ul>
</blockquote>
<h1 id="有效括号"><a href="#有效括号" class="headerlink" title="有效括号"></a>有效括号</h1><p><a href="https://github.com/Blankj/awesome-java-leetcode/blob/master/note/0020/README.md">查看原文</a></p>
<p>给定仅包含字符’（’，’）’，’{‘，’}’，’[‘和’]’的字符串，请确定输入字符串是否有效。</p>
<p>输入字符串在以下情况下有效：</p>
<blockquote>
<ul>
<li>开括号必须用相同类型的括号封闭。</li>
<li>开括号必须以正确的顺序关闭。</li>
<li>请注意，空字符串也被视为有效。</li>
</ul>
</blockquote>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;()&quot;</span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Input: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Input: &quot;(]&quot;</span><br><span class="line">Output: false</span><br><span class="line"></span><br><span class="line">Input: &quot;([)]&quot;</span><br><span class="line">Output: false</span><br><span class="line"></span><br><span class="line">Input: &quot;&#123;[]&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<h2 id="我的思路-5"><a href="#我的思路-5" class="headerlink" title="我的思路"></a>我的思路</h2><p>这个问题，让我想到了一个游戏，消消乐。把一对紧挨着的、配对的括号消掉，不能消掉的留下，且每发生一次消掉的事件则对内部重新进行一次配对判断。如果最后剩下的字符串是空字符串，则视为有效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static boolean isValidParentheses(String str)&#123;</span><br><span class="line">    if (str.equals(&quot;&quot;)) return true;</span><br><span class="line">    if (str.length() &#x3D;&#x3D; 1) return false;</span><br><span class="line">        </span><br><span class="line">    Map&lt;Character, Character&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    map.put(&#39;&#123;&#39;, &#39;&#125;&#39;);</span><br><span class="line">    map.put(&#39;(&#39;, &#39;)&#39;);</span><br><span class="line">    map.put(&#39;[&#39;, &#39;]&#39;);</span><br><span class="line">    </span><br><span class="line">    while (str.length() &gt; 1) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; str.length() - 1; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果紧挨着的字符串是配对的，则消掉这两个字符串，然后跳出此次判断，重新开始循环</span><br><span class="line">            if (map.get(str.charAt(i)) !&#x3D; null &amp;&amp; map.get(str.charAt(i)).equals(str.charAt(i + 1)))&#123;</span><br><span class="line">                str &#x3D; str.substring(0, i) + str.substring(i + 2);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return str.length() &#x3D;&#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="推荐思路-4"><a href="#推荐思路-4" class="headerlink" title="推荐思路"></a>推荐思路</h2><p>我们可以用栈来解决这个问题，当出现左括号的时候入栈，当遇到右括号时，判断栈顶的左括号是否何其匹配，不匹配的话直接返回 false 即可，最终判断是否空栈即可。有个细节注意下 top = 1;，从而省去了之后判空的操作和 top - 1 导致数组越界的错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static boolean isValid(String str) &#123;</span><br><span class="line">    char[] stack &#x3D; new char[str.length() - 1];</span><br><span class="line">    int top &#x3D; 1;</span><br><span class="line">    for (char c : str.toCharArray()) &#123;</span><br><span class="line">        if (c &#x3D;&#x3D; &#39;(&#39; || c &#x3D;&#x3D; &#39;&#123;&#39; || c &#x3D;&#x3D; &#39;[&#39;) &#123;</span><br><span class="line">            stack[top++] &#x3D; c;</span><br><span class="line">        &#125; else if (c &#x3D;&#x3D; &#39;)&#39; &amp;&amp; stack[--top] !&#x3D; &#39;(&#39;)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else if (c &#x3D;&#x3D; &#39;]&#39; &amp;&amp; stack[--top] !&#x3D; &#39;[&#39;)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else if (c &#x3D;&#x3D; &#39;&#125;&#39; &amp;&amp; stack[--top] !&#x3D; &#39;&#123;&#39;)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return top &#x3D;&#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="学习点-6"><a href="#学习点-6" class="headerlink" title="学习点"></a>学习点</h2><p>我的思路里，是用截取的方式替代了消掉的操作，而推荐思路里是用了逐个配对替换的方式替代了消掉的操作，让我眼前一亮。我也想过栈这种数据结构，但我数据结构学的不好，不知道用什么存储结构来代表栈。而且我的方法里有几个地方如果编写的时候不注意的话，容易引起数组越界。</p>
<h1 id="合并两个短列表"><a href="#合并两个短列表" class="headerlink" title="合并两个短列表"></a>合并两个短列表</h1><p>合并两个排序的链表，并将其作为新列表返回。 应该通过将前两个列表的节点拼接在一起来创建新列表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>
<h1 id="从排序数组中删除重复项"><a href="#从排序数组中删除重复项" class="headerlink" title="从排序数组中删除重复项"></a>从排序数组中删除重复项</h1><p>给定一个已排序的数组 nums，就地删除重复项，以使每个元素仅出现一次并返回新的长度。</p>
<p>不要为另一个数组分配额外的空间，必须通过使用$O(1)$额外的内存就地修改输入数组来做到这一点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [1,1,2],</span><br><span class="line"></span><br><span class="line">函数应返回length &#x3D; 2，且nums的前两个元素分别为1和2。</span><br><span class="line"></span><br><span class="line">Given nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应返回length &#x3D; 5，并将nums的前五个元素分别修改为0、1、2、3和4。</span><br><span class="line"></span><br><span class="line">超出返回的长度设置什么值都没有关系。</span><br></pre></td></tr></table></figure>
<h2 id="我的思路-6"><a href="#我的思路-6" class="headerlink" title="我的思路"></a>我的思路</h2><p>返回的长度，是数组里不重复数字的个数。余下的，从第二位开始，逐个往后比较，如果小于后面的，则将该位赋值为比较大的数，并跳出循环，进行下一位的往后比较。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int removeDuplicates(int[] nums)&#123;</span><br><span class="line">    int length &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; nums.length - 1; i++) &#123;</span><br><span class="line">        if (nums[i] &#x3D;&#x3D; nums[i + 1]) &#123;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">        for (int j &#x3D; i + 1; j &lt; nums.length; j++)&#123;</span><br><span class="line">            if (nums[i] &lt; nums[j]) &#123;</span><br><span class="line">                nums[i + 1] &#x3D; nums[j];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="推荐思路-5"><a href="#推荐思路-5" class="headerlink" title="推荐思路"></a>推荐思路</h2><p>以tail变量计数的同时，以tail作为赋值位，很骚的操作。</p>
<p>以及我真的搞不懂了，有时候会加这种长度&lt;=1直接返回值的代码，有时候（指上一题）又不加这种特殊情况处理的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">    int len &#x3D; nums.length;</span><br><span class="line">    if (len &lt;&#x3D; 1) return len;</span><br><span class="line">    int tail &#x3D; 1;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; len; ++i) &#123;</span><br><span class="line">        if (nums[i - 1] !&#x3D; nums[i]) &#123;</span><br><span class="line">            nums[tail++] &#x3D; nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="从排序数组中删除指定项"><a href="#从排序数组中删除指定项" class="headerlink" title="从排序数组中删除指定项"></a>从排序数组中删除指定项</h1><p>给定数组Nums和值val，删除该值的所有实例就位并返回新长度。</p>
<p>不要为另一个数组分配额外的空间，您必须通过**将输入阵列修改为o（1）额外的内存来修改输入阵列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2,</span><br><span class="line"></span><br><span class="line">函数应返回length &#x3D; 5，num的前五个元素包含0、1、3、0和4。</span><br></pre></td></tr></table></figure>
<h2 id="我的思路-7"><a href="#我的思路-7" class="headerlink" title="我的思路"></a>我的思路</h2><p>借鉴上一题的解法思路。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int removeSpecialDuplicated(int[] nums, int val)&#123;</span><br><span class="line">    int length &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (nums[i] !&#x3D; val) &#123;</span><br><span class="line">            nums[length++] &#x3D; nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h1><p>给定一个已排序的数组和一个目标值，如果找到目标，则返回索引。 如果不是，则返回按顺序插入索引的位置的索引。</p>
<p>您可以假设阵列中没有重复项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,3,5,6], 5</span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Input: [1,3,5,6], 2</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Input: [1,3,5,6], 7</span><br><span class="line">Output: 4</span><br><span class="line"></span><br><span class="line">Input: [1,3,5,6], 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<h2 id="我的思路-8"><a href="#我的思路-8" class="headerlink" title="我的思路"></a>我的思路</h2><p>哈，这么简单？这挨个比较不就完了？</p>
<h2 id="推荐思路-6"><a href="#推荐思路-6" class="headerlink" title="推荐思路"></a>推荐思路</h2><p>哦<del>（自作聪明之后发现被打脸后的失落）</del>，用二分法加快搜索速度啊~</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int searchInsert(int[] nums, int target) &#123;</span><br><span class="line">    int left &#x3D; 0, right &#x3D; nums.length - 1, mid &#x3D; (right + left) &gt;&gt; 1;</span><br><span class="line">    while (left &lt;&#x3D; right) &#123;</span><br><span class="line">        if (target &lt;&#x3D; nums[mid]) right &#x3D; mid - 1;</span><br><span class="line">        else left &#x3D; mid + 1;</span><br><span class="line">        mid &#x3D; (right + left) &gt;&gt; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数数说"><a href="#数数说" class="headerlink" title="数数说"></a>数数说</h1><p>count-and-say 序列是整数序列，前五项如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 1</span><br><span class="line">2. 11</span><br><span class="line">3. 21</span><br><span class="line">4. 1211</span><br><span class="line">5. 111221</span><br></pre></td></tr></table></figure>
<p>1 读作“一个 1 ”或 11。</p>
<p>11 读作“两个 1 ”或 21。</p>
<p>21 读作“一个 2，然后一个 1 ”或 1211。</p>
<p>给定一个整数 n，生成 count-and-say 序列的第 n 项。</p>
<p>注意：整数序列的每一项都将表示为一个字符串。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我先是手动写了前七项的值，发现无数学规律可言，那就只能按照递归或循环的办法来计算输出结果。关键在于在循环中计算某个数的出现次数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String countAndSay(int n) &#123;</span><br><span class="line">    String str &#x3D; &quot;1&quot;;</span><br><span class="line">    while (--n &gt; 0) &#123;</span><br><span class="line">        StringBuilder res &#x3D; new StringBuilder(&quot;&quot;);</span><br><span class="line">        int times &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">            if (i + 1 &lt; str.length()) &#123;</span><br><span class="line">                if (str.charAt(i) &#x3D;&#x3D; str.charAt(i + 1)) &#123;</span><br><span class="line">                    times++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    res.append(times).append(str.charAt(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                res.append(times).append(str.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        str &#x3D; res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小插曲：原本 res 我是写作 string 型的，循环中赋值的语句是 res += times + str.charAt(i) ，结果尝试调用的时候发现结果不对，才想到这里是整数型加字符型，计算时是整数加字符的 ASCII 值，结果变为了整数；如果是加字符串，则会直接变为字符串。算是一个意料之外的错误。</p>
<h2 id="推荐思路-7"><a href="#推荐思路-7" class="headerlink" title="推荐思路"></a>推荐思路</h2><p>思路大概一致，但代码仍需优化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String countAndSay(int n) &#123;</span><br><span class="line">    String str &#x3D; &quot;1&quot;;</span><br><span class="line">    while (--n &gt; 0) &#123;</span><br><span class="line">        int times &#x3D; 1;</span><br><span class="line">        StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">        char[] chars &#x3D; str.toCharArray();</span><br><span class="line">        int len &#x3D; chars.length;</span><br><span class="line">        for (int j &#x3D; 1; j &lt; len; j++) &#123;</span><br><span class="line">            if (chars[j - 1] &#x3D;&#x3D; chars[j]) &#123;</span><br><span class="line">                times++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                sb.append(times).append(chars[j - 1]);</span><br><span class="line">                times &#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        str &#x3D; sb.append(times).append(chars[len - 1]).toString();</span><br><span class="line">    &#125;</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="加一"><a href="#加一" class="headerlink" title="加一"></a>加一</h1><p>给定一个表示非负整数的非空数字数组，该整数加一。</p>
<p>存储数字时，最高有效数字位于列表的开头，并且数组中的每个元素都包含一个数字。</p>
<p>您可以假设整数不包含任何前导零，除了数字 0 本身。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1, 2, 3]</span><br><span class="line">输出：[1, 2, 4]</span><br><span class="line">解释：数组代表的是整数 123</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[4, 3, 2, 1]</span><br><span class="line">输出：[4, 3, 2, 2]</span><br><span class="line">解释：数组代表的是整数 4321</span><br></pre></td></tr></table></figure>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>分别考虑情况：</p>
<p>1、末位不满 10，无进位，加 1 返回数组</p>
<p>2、末位满 10，含进位，循环判断前置位的值，直至首位</p>
<p>3、首位满 10，分配一个长度比数组多 1 的新数组，首位赋 1，其余位赋 0，返回此新数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>为什么我做不好界面</title>
    <url>/2021/04/02/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%81%9A%E4%B8%8D%E5%A5%BD%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<p>从开始学 Android 到现在好几年了，每次写界面都会被人吐槽界面很丑。虽然我并不是 UI 设计师，但自己也不能总是写一些平均水平以下的界面，于是决定反思一下为什么我做不好界面。</p>
<a id="more"></a>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>先确定一下我反思的思路：</p>
<blockquote>
<ul>
<li><p>确定当今界面的大体设计思想：当今的设计思想是怎样的</p>
</li>
<li><p>回顾 Android 界面的发展历史：为什么以前的界面很丑，或者说为什么被抛弃了</p>
</li>
<li><p>未来的界面设计方向</p>
</li>
</ul>
</blockquote>
<p>就先定这几个章节吧，以后会慢慢补充的，<strong>毕竟审美是在持续变化的</strong>。</p>
<h1 id="确定当今界面的大体设计思想"><a href="#确定当今界面的大体设计思想" class="headerlink" title="确定当今界面的大体设计思想"></a>确定当今界面的大体设计思想</h1><p>我思考了一下，应当先确定一个标准，针对各个细节上的标准。在此基础上，才方便进行细节上的确定与优化。</p>
<p>界面设计大致包括为两类：直观上的静态界面设计(仅视觉)与隐性的动态交互设计(触碰与视觉)。</p>
<p>Google 曾在 2015 年提出了 Material Design。这种设计思想以及相关的设计指南资料已经对界面的规范作出了相当详细的建议，且很多细节上的设计让我啧啧称赞。作为一个界面审美白痴，我当然要试一下可行性如何。</p>
<p>但在我实践这一思想的过程中，遇到了一个很大的问题：很多控件细节和动画效果需要开发者自己从零实现，Google 并没有为开发者提供充足的现有资源。这就使得开发一个完整且优秀的 Material Design 风格 APP 需要花费很多精力。</p>
<p>而且，经受过 iOS 设计风格的影响，国内很多衍生系统和 APP 也在模仿 iOS 风格的路上一去不复返。</p>
<p>其实我认为，界面风格不分系统。只是，在一个 APP 内的所有界面上，往往很难做到统一界面设计风格与规则。</p>
<h2 id="Google-Material-Design"><a href="#Google-Material-Design" class="headerlink" title="Google - Material Design"></a>Google - Material Design</h2><p>参考文章：</p>
<blockquote>
<ul>
<li><a href="https://www.uisdc.com/material-design-knowledge">如果你不熟悉Material Design，请一口吃下这篇干货</a></li>
<li><a href="https://material.io/">Material Design 官网</a></li>
</ul>
</blockquote>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>Material Design 注重与卡片式设计，风格不完全是抽象扁平风格，也带有一些拟物的特性。它从物理现实里学习了诸如质感、投影、加速度等概念，将之在动画细节上给予表现。扁平设计的优点是<strong>信息噪音少</strong>(见下文设计概念中的“信噪比”)，缺点是<strong>情感传递不足</strong>（见下文设计概念中的“情感化”）。</p>
<h3 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h3><h4 id="Z轴"><a href="#Z轴" class="headerlink" title="Z轴"></a>Z轴</h4><p>在二维的手机平面上，利用投影、动效等构建出Z轴，创造出三维感。</p>
<h5 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h5><p>通过阴影的面积与边缘的模糊化程度来反馈出控件的海拔高低</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-58.jpg" alt="海拔阴影比较图"></p>
<h5 id="界面分层"><a href="#界面分层" class="headerlink" title="界面分层"></a>界面分层</h5><p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-4.jpg" alt="控件海拔高度图"></p>
<h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><p>正如 iOS 拥有自己的特色组件，Material Design 也有一些自己独具特色的组件。</p>
<h5 id="悬浮球-FAB"><a href="#悬浮球-FAB" class="headerlink" title="悬浮球 FAB"></a>悬浮球 FAB</h5><p>悬浮球是一个很显眼的组件。它应当<strong>负责当前页面的一些主线操作</strong>。</p>
<p>FAB 常有默认（56dp）与 Mini 尺寸（40dp）：</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-136.jpg" alt="FAB图标"></p>
<p>FAB 可设计为跳转，也可以展开子菜单：</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-141.jpg" alt></p>
<h5 id="底部应用栏-App-bars-bottom"><a href="#底部应用栏-App-bars-bottom" class="headerlink" title="底部应用栏 App bars: bottom"></a>底部应用栏 App bars: bottom</h5><p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-55.jpg" alt></p>
<p>底部栏应包含两个以上的图标(不含FAB)：</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-35.jpg" alt></p>
<h5 id="顶部应用栏-App-bars-top"><a href="#顶部应用栏-App-bars-top" class="headerlink" title="顶部应用栏 App bars: top"></a>顶部应用栏 App bars: top</h5><p>顶部应用栏与 iOS 的导航栏有些类似但不同。标题并非居中而是左对齐。左侧最多放置一个系统图标，右侧可放置多个系统图标。</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-18.jpg" alt></p>
<p>部分状态下可以改变原来的系统图标：</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-15.jpg" alt></p>
<p><strong>突出标题</strong>：可改变高度以凸显标题。可以让标题容纳更多的文字内容，比如新闻APP。有时为了减少视觉层级，可以在应用栏中加入图片来增强界面的整体感。</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-12.jpg" alt></p>
<h5 id="背板设计-Backdrop"><a href="#背板设计-Backdrop" class="headerlink" title="背板设计 Backdrop"></a>背板设计 Backdrop</h5><p>在应用引发的某个操作中，可设计背板来承载某些选项和辅助信息。较类似于 iOS 的 Action Sheet。</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-105.jpg" alt="概念图"></p>
<h5 id="背板设计的辅助控件"><a href="#背板设计的辅助控件" class="headerlink" title="背板设计的辅助控件"></a>背板设计的辅助控件</h5><blockquote>
<ul>
<li>背板设计隐藏时，后层控件可提供有关前层的辅助信息</li>
<li>背板设计激活时，后层可显示与前层相关的控件</li>
</ul>
</blockquote>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-56.jpg" alt></p>
<h5 id="横幅-Banner"><a href="#横幅-Banner" class="headerlink" title="横幅 Banner"></a>横幅 Banner</h5><p>是顶部栏下的第一个凸显区域，显示突出的消息和相关操作。</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-73.jpg" alt></p>
<h5 id="底部导航-Bottom-Navigation"><a href="#底部导航-Bottom-Navigation" class="headerlink" title="底部导航 Bottom Navigation"></a>底部导航 Bottom Navigation</h5><p>将底部等分为多个图标与辅助文字的点击区域，以将功能模块区分开来。</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-61.jpg" alt></p>
<h5 id="按钮-Button"><a href="#按钮-Button" class="headerlink" title="按钮 Button"></a>按钮 Button</h5><p>按钮是一个很常见的元素，在 Material Design 中则常见为以下几种风格：</p>
<blockquote>
<ul>
<li>纯文字按钮。只有加粗带色彩的文字，点击时会有波纹效果，显示按钮范围</li>
<li>线性按钮。用线框来表明点击区域，不显眼</li>
<li>填充按钮。常见形式，明显</li>
<li>切换按钮。</li>
</ul>
</blockquote>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-84.jpg" alt></p>
<p>贴合在文字里，不显得冲突显眼的 纯文字按钮：</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-116.jpg" alt></p>
<p>权重不抢戏的 线性按钮：</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-134.jpg" alt></p>
<p>有权重，突出操作的 按钮：</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-37.jpg" alt></p>
<h5 id="卡片式设计-CardView"><a href="#卡片式设计-CardView" class="headerlink" title="卡片式设计 CardView"></a>卡片式设计 CardView</h5><p>这也是 Material Design 的显著标志。卡片式设计像是一个小的单元，单元内的信息逻辑关系更加紧密。</p>
<p>卡片式设计应包含以下部分：</p>
<blockquote>
<ul>
<li>容器卡元素。容纳所有卡内元素，尺寸由元素决定</li>
<li>缩略图（可选）。放置头像、图标或logo等</li>
<li>标题文字（可选）。通常是重要的标题，文字较大</li>
<li>小标题（可选）。可放置文章署名或标记位置等</li>
<li>多媒体（可选）。可放置照片或视频等</li>
<li>辅助文字（可选）。通常是对于多媒体的描述信息</li>
<li>按钮（可选）</li>
<li>图标（可选）</li>
</ul>
</blockquote>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-112.jpg" alt></p>
<p><strong>卡片设计中的分割线</strong></p>
<p>如果卡片中的内容元素不属于一个逻辑，那么可以使用一条分割线来分割区域。注意，分割线需使用非常轻的颜色，且不要抵达边缘，以保证视觉上卡片的完整性。</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-79.jpg" alt></p>
<h5 id="纸片-Chip"><a href="#纸片-Chip" class="headerlink" title="纸片 Chip"></a>纸片 Chip</h5><p>纸片通常是输入框中多个元素的组合，拥有选中态以及交互态等丰富交互。</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-92.jpg" alt></p>
<h5 id="对话框-Dialog"><a href="#对话框-Dialog" class="headerlink" title="对话框 Dialog"></a>对话框 Dialog</h5><p>对话框分为模态对话框与非模态对话框。主要区别是，模态对话框需要与人交互，而非模态对话框则是显示提示信息。</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-87.jpg" alt></p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-53.jpg" alt></p>
<p>用户选择前，可以禁用掉确认功能防止用户点击：</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-128.jpg" alt></p>
<h5 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h5><p>信息分割按照轻重，次序依次是面的分割、线的分割和留白的分割。</p>
<p><strong>全出血分割线</strong>与<strong>插入式分割线</strong></p>
<p>全出血（“出血”是平面印刷中的概念，“全出血”指分割线横向贯穿整个页面）分割线给人的感受是信息完全独立，而插入式分割线更方便我们找到当前阅读的位置。</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-31.jpg" alt></p>
<h5 id="抽屉式导航栏-Navigation-Drawer"><a href="#抽屉式导航栏-Navigation-Drawer" class="headerlink" title="抽屉式导航栏 Navigation Drawer"></a>抽屉式导航栏 Navigation Drawer</h5><p>与苹果的不建议使用不同，Material Design 反而很青睐这种交互形式，并鼓励在应用栏增加一个导航图标，以供激活抽屉式导航。</p>
<blockquote>
<ul>
<li>容器（可选）</li>
<li>头部（可选）。通常为个人信息</li>
<li>分割线（可选）</li>
<li>选中态</li>
<li>选中态文本</li>
<li>未激活文本</li>
<li>小标题</li>
</ul>
</blockquote>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-30.jpg" alt></p>
<h5 id="页卡-Tabs"><a href="#页卡-Tabs" class="headerlink" title="页卡 Tabs"></a>页卡 Tabs</h5><p>常见于顶部应用栏，一般由2个到多个组成。点击时，应用栏下方跳转到对应内容。</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-96.jpg" alt></p>
<h5 id="文字输入框-Text-Fields"><a href="#文字输入框-Text-Fields" class="headerlink" title="文字输入框 Text Fields"></a>文字输入框 Text Fields</h5><p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-94.jpg" alt></p>
<h5 id="图片组-Image-Lists"><a href="#图片组-Image-Lists" class="headerlink" title="图片组 Image Lists"></a>图片组 Image Lists</h5><blockquote>
<ul>
<li>正常图片组：每张图片大小一致，间距统一且通常有些窄。图片源要求大小统一</li>
<li>排版图片组</li>
<li>照片墙图片组：结构组织教松散，适合图像尺寸不均等的内容展示</li>
<li>瀑布流图片组：图片宽度均相等</li>
</ul>
</blockquote>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-72.jpg" alt></p>
<h5 id="滑块-Sliders"><a href="#滑块-Sliders" class="headerlink" title="滑块 Sliders"></a>滑块 Sliders</h5><p>在音乐 APP 和视频 APP 中，需要设置一个或多个滑块方便用户进行调节。</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-70.jpg" alt></p>
<h5 id="选择器-Selection-Controls"><a href="#选择器-Selection-Controls" class="headerlink" title="选择器 Selection Controls"></a>选择器 Selection Controls</h5><p>苹果使用按钮和 Action Sheet 来代替不太好点击的选择器，但 Material Design 仍然认为这些选择器在移动端可行。</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-137.jpg" alt></p>
<h5 id="底部提示栏-Snackbars"><a href="#底部提示栏-Snackbars" class="headerlink" title="底部提示栏 Snackbars"></a>底部提示栏 Snackbars</h5><p>当需要给用户一些不需要确认操作的信息，且处于不影响用户操作的情景，底部提示栏是一个比较不错的选择。</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-126.jpg" alt></p>
<h5 id="状态指引-Progress-Indicators"><a href="#状态指引-Progress-Indicators" class="headerlink" title="状态指引 Progress Indicators"></a>状态指引 Progress Indicators</h5><p>在一些花费时间加载的页面，需要让用户感知到加载的状态和进度，且不必占用过多的空间。</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-145.jpg" alt></p>
<h4 id="色彩"><a href="#色彩" class="headerlink" title="色彩"></a>色彩</h4><p>Material Design 的色彩选择通常非常鲜亮，在明度和纯度上较为适中。MD 非常重视背景与文字的色彩对比，需要最大化保证文字的可读性。配色时注意三原则：</p>
<blockquote>
<ul>
<li>分级：通过使用不同的颜色来告诉用户，哪些是可交互的，哪些是装饰的；并且信息的逻辑关系也可以通过色彩表现出来</li>
<li>清晰：文本与背景要有一定的色彩反差，以防用户无法准确阅读信息</li>
<li>品牌：明确的主色调会给用户深刻的印象，如网易云音乐的红色与QQ音乐的黄绿色</li>
</ul>
</blockquote>
<h5 id="色系参考"><a href="#色系参考" class="headerlink" title="色系参考"></a>色系参考</h5><p>MD 已提供了色系列表以供参考。注意，颜色不可以选择比较“脏”（脏一般体现于颜色纯度、明度，以及跨颜色跨度）的颜色。</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-45.jpg" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- material design 调色板 --&gt;</span><br><span class="line">&lt;!--red--&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_red_50&quot;&gt;#FFEBEE&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_red_100&quot;&gt;#FFCDD2&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_red_200&quot;&gt;#EF9A9A&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_red_300&quot;&gt;#E57373&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_red_400&quot;&gt;#EF5350&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_red_500&quot;&gt;#F44336&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_red_600&quot;&gt;#E53935&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_red_700&quot;&gt;#D32F2F&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_red_800&quot;&gt;#C62828&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_red_900&quot;&gt;#B71C1C&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_red_A100&quot;&gt;#FF8A80&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_red_A200&quot;&gt;#FF5252&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_red_A400&quot;&gt;#FF1744&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_red_A700&quot;&gt;#D50000&lt;&#x2F;color&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--pink--&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_pink_50&quot;&gt;#FCE4EC&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_pink_100&quot;&gt;#F8BBD0&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_pink_200&quot;&gt;#F48FB1&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_pink_300&quot;&gt;#F06292&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_pink_400&quot;&gt;#EC407A&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_pink_500&quot;&gt;#E91E63&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_pink_600&quot;&gt;#D81B60&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_pink_700&quot;&gt;#C2185B&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_pink_800&quot;&gt;#AD1457&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_pink_900&quot;&gt;#880E4F&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_pink_A100&quot;&gt;#FF80AB&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_pink_A200&quot;&gt;#FF4081&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_pink_A400&quot;&gt;#F50057&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_pink_A700&quot;&gt;#C51162&lt;&#x2F;color&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--purple--&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_purple_50&quot;&gt;#F3E5F5&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_purple_100&quot;&gt;#E1BEE7&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_purple_200&quot;&gt;#CE93D8&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_purple_300&quot;&gt;#BA68C8&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_purple_400&quot;&gt;#AB47BC&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_purple_500&quot;&gt;#9C27B0&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_purple_600&quot;&gt;#8E24AA&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_purple_700&quot;&gt;#7B1FA2&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_purple_800&quot;&gt;#6A1B9A&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_purple_900&quot;&gt;#4A148C&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_purple_A100&quot;&gt;#EA80FC&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_purple_A200&quot;&gt;#E040FB&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_purple_A400&quot;&gt;#D500F9&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_purple_A700&quot;&gt;#AA00FF&lt;&#x2F;color&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--deep_purple--&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_deep_purple_50&quot;&gt;#EDE7F6&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_deep_purple_100&quot;&gt;#D1C4E9&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_deep_purple_200&quot;&gt;#B39DDB&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_deep_purple_300&quot;&gt;#9575CD&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_deep_purple_400&quot;&gt;#7E57C2&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_deep_purple_500&quot;&gt;#673AB7&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_deep_purple_600&quot;&gt;#5E35B1&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_deep_purple_700&quot;&gt;#512DA8&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_deep_purple_800&quot;&gt;#4527A0&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_deep_purple_900&quot;&gt;#311B92&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_deep_purple_A100&quot;&gt;#B388FF&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_deep_purple_A200&quot;&gt;#7C4DFF&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_deep_purple_A400&quot;&gt;#651FFF&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_deep_purple_A700&quot;&gt;#6200EA&lt;&#x2F;color&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--indigo--&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_indigo_50&quot;&gt;#E8EAF6&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_indigo_100&quot;&gt;#C5CAE9&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_indigo_200&quot;&gt;#9FA8DA&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_indigo_300&quot;&gt;#7986CB&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_indigo_400&quot;&gt;#5C6BC0&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_indigo_500&quot;&gt;#3F51B5&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_indigo_600&quot;&gt;#3949AB&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_indigo_700&quot;&gt;#303F9F&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_indigo_800&quot;&gt;#283593&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_indigo_900&quot;&gt;#1A237E&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_indigo_A100&quot;&gt;#8C9EFF&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_indigo_A200&quot;&gt;#536DFE&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_indigo_A400&quot;&gt;#3D5AFE&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_indigo_A700&quot;&gt;#304FFE&lt;&#x2F;color&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--blue--&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_blue_50&quot;&gt;#E3F2FD&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_blue_100&quot;&gt;#BBDEFB&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_blue_200&quot;&gt;#90CAF9&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_blue_300&quot;&gt;#64B5F6&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_blue_400&quot;&gt;#42A5F5&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_blue_500&quot;&gt;#2196F3&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_blue_600&quot;&gt;#1E88E5&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_blue_700&quot;&gt;#1976D2&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_blue_800&quot;&gt;#1565C0&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_blue_900&quot;&gt;#0D47A1&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_blue_A100&quot;&gt;#82B1FF&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_blue_A200&quot;&gt;#448AFF&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_blue_A400&quot;&gt;#2979FF&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_blue_A700&quot;&gt;#2962FF&lt;&#x2F;color&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--light_blue--&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_light_blue_50&quot;&gt;#E1F5FE&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_light_blue_100&quot;&gt;#B3E5FC&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_light_blue_200&quot;&gt;#81D4FA&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_light_blue_300&quot;&gt;#4FC3F7&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_light_blue_400&quot;&gt;#29B6F6&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_light_blue_500&quot;&gt;#03A9F4&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_light_blue_600&quot;&gt;#039BE5&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_light_blue_700&quot;&gt;#0288D1&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_light_blue_800&quot;&gt;#0277BD&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_light_blue_900&quot;&gt;#01579B&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_light_blue_A100&quot;&gt;#80D8FF&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_light_blue_A200&quot;&gt;#40C4FF&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_light_blue_A400&quot;&gt;#00B0FF&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_light_blue_A700&quot;&gt;#0091EA&lt;&#x2F;color&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--cyan--&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_cyan_50&quot;&gt;#E0F7FA&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_cyan_100&quot;&gt;#B2EBF2&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_cyan_200&quot;&gt;#80DEEA&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_cyan_300&quot;&gt;#4DD0E1&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_cyan_400&quot;&gt;#26C6DA&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_cyan_500&quot;&gt;#00BCD4&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_cyan_600&quot;&gt;#00ACC1&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_cyan_700&quot;&gt;#0097A7&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_cyan_800&quot;&gt;#00838F&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_cyan_900&quot;&gt;#006064&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_cyan_A100&quot;&gt;#84FFFF&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_cyan_A200&quot;&gt;#18FFFF&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_cyan_A400&quot;&gt;#00E5FF&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_cyan_A700&quot;&gt;#00B8D4&lt;&#x2F;color&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--teal--&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_teal_50&quot;&gt;#E0F2F1&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_teal_100&quot;&gt;#B2DFDB&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_teal_200&quot;&gt;#80CBC4&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_teal_300&quot;&gt;#4DB6AC&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_teal_400&quot;&gt;#26A69A&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_teal_500&quot;&gt;#009688&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_teal_600&quot;&gt;#00897B&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_teal_700&quot;&gt;#00796B&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_teal_800&quot;&gt;#00695C&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_teal_900&quot;&gt;#004D40&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_teal_A100&quot;&gt;#A7FFEB&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_teal_A200&quot;&gt;#64FFDA&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_teal_A400&quot;&gt;#1DE9B6&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_teal_A700&quot;&gt;#00BFA5&lt;&#x2F;color&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--green--&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_green_50&quot;&gt;#E8F5E9&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_green_100&quot;&gt;#C8E6C9&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_green_200&quot;&gt;#A5D6A7&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_green_300&quot;&gt;#81C784&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_green_400&quot;&gt;#66BB6A&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_green_500&quot;&gt;#4CAF50&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_green_600&quot;&gt;#43A047&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_green_700&quot;&gt;#388E3C&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_green_800&quot;&gt;#2E7D32&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_green_900&quot;&gt;#1B5E20&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_green_A100&quot;&gt;#B9F6CA&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_green_A200&quot;&gt;#69F0AE&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_green_A400&quot;&gt;#00E676&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_green_A700&quot;&gt;#00C853&lt;&#x2F;color&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--light_green--&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_light_green_50&quot;&gt;#F1F8E9&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_light_green_100&quot;&gt;#DCEDC8&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_light_green_200&quot;&gt;#C5E1A5&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_light_green_300&quot;&gt;#AED581&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_light_green_400&quot;&gt;#9CCC65&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_light_green_500&quot;&gt;#8BC34A&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_light_green_600&quot;&gt;#7CB342&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_light_green_700&quot;&gt;#689F38&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_light_green_800&quot;&gt;#558B2F&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_light_green_900&quot;&gt;#33691E&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_light_green_A100&quot;&gt;#CCFF90&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_light_green_A200&quot;&gt;#B2FF59&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_light_green_A400&quot;&gt;#76FF03&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_light_green_A700&quot;&gt;#64DD17&lt;&#x2F;color&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--lime--&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_lime_50&quot;&gt;#F9FBE7&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_lime_100&quot;&gt;#F0F4C3&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_lime_200&quot;&gt;#E6EE9C&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_lime_300&quot;&gt;#DCE775&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_lime_400&quot;&gt;#D4E157&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_lime_500&quot;&gt;#CDDC39&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_lime_600&quot;&gt;#C0CA33&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_lime_700&quot;&gt;#AFB42B&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_lime_800&quot;&gt;#9E9D24&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_lime_900&quot;&gt;#827717&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_lime_A100&quot;&gt;#F4FF81&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_lime_A200&quot;&gt;#EEFF41&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_lime_A400&quot;&gt;#C6FF00&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_lime_A700&quot;&gt;#AEEA00&lt;&#x2F;color&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--yellow--&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_yellow_50&quot;&gt;#FFFDE7&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_yellow_100&quot;&gt;#FFF9C4&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_yellow_200&quot;&gt;#FFF59D&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_yellow_300&quot;&gt;#FFF176&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_yellow_400&quot;&gt;#FFEE58&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_yellow_500&quot;&gt;#FFEB3B&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_yellow_600&quot;&gt;#FDD835&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_yellow_700&quot;&gt;#FBC02D&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_yellow_800&quot;&gt;#F9A825&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_yellow_900&quot;&gt;#F57F17&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_yellow_A100&quot;&gt;#FFFF8D&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_yellow_A200&quot;&gt;#FFFF00&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_yellow_A400&quot;&gt;#FFEA00&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_yellow_A700&quot;&gt;#FFD600&lt;&#x2F;color&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--amber--&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_amber_50&quot;&gt;#FFF8E1&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_amber_100&quot;&gt;#FFECB3&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_amber_200&quot;&gt;#FFE082&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_amber_300&quot;&gt;#FFD54F&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_amber_400&quot;&gt;#FFCA28&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_amber_500&quot;&gt;#FFC107&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_amber_600&quot;&gt;#FFB300&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_amber_700&quot;&gt;#FFA000&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_amber_800&quot;&gt;#FF8F00&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_amber_900&quot;&gt;#FF6F00&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_amber_A100&quot;&gt;#FFE57F&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_amber_A200&quot;&gt;#FFD740&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_amber_A400&quot;&gt;#FFC400&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_amber_A700&quot;&gt;#FFAB00&lt;&#x2F;color&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--orange--&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_orange_50&quot;&gt;#FFF3E0&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_orange_100&quot;&gt;#FFE0B2&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_orange_200&quot;&gt;#FFCC80&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_orange_300&quot;&gt;#FFB74D&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_orange_400&quot;&gt;#FFA726&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_orange_500&quot;&gt;#FF9800&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_orange_600&quot;&gt;#FB8C00&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_orange_700&quot;&gt;#F57C00&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_orange_800&quot;&gt;#EF6C00&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_orange_900&quot;&gt;#E65100&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_orange_A100&quot;&gt;#FFD180&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_orange_A200&quot;&gt;#FFAB40&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_orange_A400&quot;&gt;#FF9100&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_orange_A700&quot;&gt;#FF6D00&lt;&#x2F;color&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--deep_orange--&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_deep_orange_50&quot;&gt;#FBE9E7&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_deep_orange_100&quot;&gt;#FFCCBC&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_deep_orange_200&quot;&gt;#FFAB91&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_deep_orange_300&quot;&gt;#FF8A65&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_deep_orange_400&quot;&gt;#FF7043&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_deep_orange_500&quot;&gt;#FF5722&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_deep_orange_600&quot;&gt;#F4511E&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_deep_orange_700&quot;&gt;#E64A19&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_deep_orange_800&quot;&gt;#D84315&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_deep_orange_900&quot;&gt;#BF360C&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_deep_orange_A100&quot;&gt;#FF9E80&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_deep_orange_A200&quot;&gt;#FF6E40&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_deep_orange_A400&quot;&gt;#FF3D00&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_deep_orange_A700&quot;&gt;#DD2C00&lt;&#x2F;color&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--brown--&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_brown_50&quot;&gt;#EFEBE9&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_brown_100&quot;&gt;#D7CCC8&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_brown_200&quot;&gt;#BCAAA4&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_brown_300&quot;&gt;#A1887F&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_brown_400&quot;&gt;#8D6E63&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_brown_500&quot;&gt;#795548&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_brown_600&quot;&gt;#6D4C41&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_brown_700&quot;&gt;#5D4037&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_brown_800&quot;&gt;#4E342E&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_brown_900&quot;&gt;#3E2723&lt;&#x2F;color&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--grey--&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_grey_50&quot;&gt;#FAFAFA&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_grey_100&quot;&gt;#F5F5F5&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_grey_200&quot;&gt;#EEEEEE&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_grey_300&quot;&gt;#E0E0E0&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_grey_400&quot;&gt;#BDBDBD&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_grey_500&quot;&gt;#9E9E9E&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_grey_600&quot;&gt;#757575&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_grey_700&quot;&gt;#616161&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_grey_800&quot;&gt;#424242&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_grey_900&quot;&gt;#212121&lt;&#x2F;color&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--blue_grey--&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_blue_grey_50&quot;&gt;#ECEFF1&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_blue_grey_100&quot;&gt;#CFD8DC&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_blue_grey_200&quot;&gt;#B0BEC5&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_blue_grey_300&quot;&gt;#90A4AE&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_blue_grey_400&quot;&gt;#78909C&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_blue_grey_500&quot;&gt;#607D8B&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_blue_grey_600&quot;&gt;#546E7A&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_blue_grey_700&quot;&gt;#455A64&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_blue_grey_800&quot;&gt;#37474F&lt;&#x2F;color&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_blue_grey_900&quot;&gt;#263238&lt;&#x2F;color&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--black--&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_black&quot;&gt;#000000&lt;&#x2F;color&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--white--&gt;</span><br><span class="line">&lt;color name&#x3D;&quot;md_white&quot;&gt;#FFFFFF&lt;&#x2F;color&gt;</span><br></pre></td></tr></table></figure>
<h5 id="界面中的色彩"><a href="#界面中的色彩" class="headerlink" title="界面中的色彩"></a>界面中的色彩</h5><p>在界面中，考虑状态栏、顶部导航栏、底部应用栏和FAB在色彩上的关系。状态栏和顶部导航栏一般采用邻近色，而底部应用栏和FAB一般使用对比色。</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-5.jpg" alt></p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-77.jpg" alt></p>
<h4 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h4><p>在 MD 中，中文使用思源字体，英文使用 Roboto 字体。</p>
<h5 id="字体单位"><a href="#字体单位" class="headerlink" title="字体单位"></a>字体单位</h5><p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-150.jpg" alt></p>
<h5 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h5><p>MD 对于不同控件或部分的字体大小给出了一个参考表。</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-47.jpg" alt></p>
<h4 id="产品图标"><a href="#产品图标" class="headerlink" title="产品图标"></a>产品图标</h4><p>优秀的产品图标，应以简单、友好、大胆的方式传达产品的核心理念和意图。</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-29.jpg" alt></p>
<h5 id="图标网格与参考线"><a href="#图标网格与参考线" class="headerlink" title="图标网格与参考线"></a>图标网格与参考线</h5><p>如果想设计一个48dp的图标，建议将画布放大到400%（192dp x 192dp）来设计。</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-48.jpg" alt></p>
<p>(我怀疑上图中的圆形的宽度标注错了，应该是176dp)</p>
<h4 id="系统图标"><a href="#系统图标" class="headerlink" title="系统图标"></a>系统图标</h4><p>系统图标需要设计简单，现代，友好，在尽可能简化的情况下表达最基本或最明显的特征。</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-138.jpg" alt></p>
<h5 id="字体图标"><a href="#字体图标" class="headerlink" title="字体图标"></a>字体图标</h5><p>如果需要，可以在不下载使用图标文件的情况下，使用字体格式来节省控件。MD 和阿里都有提供图标网站：</p>
<p><a href="https://link.uisdc.com/?redirect=https%3A%2F%2Fmaterial.io%2Ftools%2Ficons">Material Design</a></p>
<p><a href="https://www.iconfont.cn/">IconFont</a></p>
<h5 id="造型接近几何形"><a href="#造型接近几何形" class="headerlink" title="造型接近几何形"></a>造型接近几何形</h5><p>MD 无需特别细致的细节，尽量使用几何形造型的图标。</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-144.jpg" alt></p>
<h5 id="图标点击状态"><a href="#图标点击状态" class="headerlink" title="图标点击状态"></a>图标点击状态</h5><p>以下透明度供参考：</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-109.jpg" alt></p>
<p>看了下后面的内容，属于设计的范畴，就不参考了。</p>
<h4 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h4><h5 id="空状态"><a href="#空状态" class="headerlink" title="空状态"></a>空状态</h5><p>空状态应使用幽默和可爱的情感化设计来和用户产生亲和感，但是不应该体现可操作性。不应使用口号和可点击的暗示。</p>
<p><img src="https://image.uisdc.com/wp-content/uploads/2018/11/uisdc-yk-20181104-95.jpg" alt></p>
<h5 id="警告对话框"><a href="#警告对话框" class="headerlink" title="警告对话框"></a>警告对话框</h5><p>警告对话框可以让用户明白下一步会发生什么，并提供取消的选项，比如删除操作通常都会弹出警告。</p>
<h5 id="闪屏页"><a href="#闪屏页" class="headerlink" title="闪屏页"></a>闪屏页</h5><p>大约即启动页。</p>
<h5 id="离线功能Offline-states"><a href="#离线功能Offline-states" class="headerlink" title="离线功能Offline states"></a>离线功能Offline states</h5><p>有些功能会因为无网络而无法完全使用，这时需要设计一些状态来表示当前的无网络状态。</p>
<h2 id="一些设计概念"><a href="#一些设计概念" class="headerlink" title="一些设计概念"></a>一些设计概念</h2><h3 id="信噪比"><a href="#信噪比" class="headerlink" title="信噪比"></a>信噪比</h3><p>参考文章：</p>
<blockquote>
<ul>
<li><a href="https://www.sohu.com/a/280346052_505826">界面设计中的“信噪比”</a></li>
</ul>
</blockquote>
<p>“信号”指有效或用户的目标信息，“噪声”指无用或干扰信息。信噪比越高，将信息传达给用户的效率也就越高。通常有两种方法来提高信噪比，一是<strong>加大信号</strong>，二是<strong>降低噪声</strong>。</p>
<p>比如下面这张图：</p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20181207/f71d3e67b75d453dbe1cbdc442b2e195.jpeg" alt></p>
<p>在右侧的界面中，分割线的颜色深浅与列表文字保持了一致。这就使得在视觉效果上呈现出，列表里的文字内容与分割线的信息处理等级是一致的。而实际上，应用想展示给用户的优先处理信息，是列表里的文字内容。所以，这里需要将分割线的颜色设置为浅色，以减少干扰信息。</p>
<p>再比如这张图：</p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20181207/717debfaa24344bcadf0bda9757249c9.jpeg" alt></p>
<p>iOS7 将拟物化图标改为扁平化图标。拟物化图标拥有充足的细节表现，比如高光、阴影、纹理、材质等；而扁平化图标经过了抽象、简化与符号化，与前者相比，去掉了很多不必要的细节，减少了用户的信息提取量。背景从拟真的深色图片更换为毛玻璃化的浅色背景，也降低了噪声<del>（与文章里的加大信号观点不同，我反而认为是这些处理是着重弱化了噪声）</del>。此外，iOS6 的主界面说不上脏，但 iOS7 的主界面看起来更“干净”一些，这是因为后者的界面里的颜色纯度与明度更高，颜色跨度比较小（也可以看得出相对地，iOS7 四个带有一些黑色元素的图标更容易吸引视线）。</p>
<p>关于“信噪比”，我之前在学习游戏开发的视频中也看到过，只不过一时找不到视频了。等我找到后来这里补个链接。</p>
<h3 id="情感化"><a href="#情感化" class="headerlink" title="情感化"></a>情感化</h3><p>参考文章</p>
<blockquote>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/109625598">APP引导页设计技巧，让你的设计更上一层楼</a></li>
<li><a href="http://www.woshipm.com/pd/12750.html">情感化移动应用设计</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/43085292">界面情感化设计</a></li>
</ul>
</blockquote>
<p>情绪是一个很主观、很微妙的东西。情感化设计，是指设计师利用界面元素，激发和带给用户一些设计目标内的情绪。当然，有时也可能处于设计目标之外。这样易引起用户的兴趣或共鸣，提升用户的粘度。</p>
<p>情感化设计常通过色彩、图案、布局、交互来达成感染情绪的结果。比如：</p>
<blockquote>
<ul>
<li>色彩：黄红色常作为积极的色彩和主色调使用，给人以热情、快乐等正面情绪；蓝绿黑色常作为消极的色彩和配色使用，给人以安静祥和、自由舒适等情绪。</li>
<li>图案：类似于下面的生动表情图案，能较准确地表达出一个人的情绪</li>
<li>布局：具有清晰、直观的结构化和层次化的界面，能让用户感觉到清爽与舒适；杂乱无章的布局容易让用户感到烦躁与不快。</li>
<li>交互：活泼有趣的交互设计，能激发用户对应用的使用兴趣；规矩死板的交互，会让用户觉得生硬无趣。</li>
</ul>
</blockquote>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200422/b8006cac55204b8dbc91dc85c59af452.gif" alt></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>加密算法初步学习</title>
    <url>/2018/10/16/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>最近发现学的东西杂七杂八的，总是看到什么，觉得有意思，就查一下看看。像这次加密算法也是，这是个我应该不会去涉及的领域，毕竟我也不做后台数据库，也不玩python去破解什么东西，可能学了也没什么用。但兴趣来了，就学一学好了，总比整日一味刷着b站无聊的视频好多了。</p>
<a id="more"></a>
<p>最初用到加密算法，是和锎锎他们做一个英语学习平台应用，在对用户密码进行申请提交的时候，考虑到信息流安全性的问题，对密码进行了一个简单的MD5加密算法加密。我们在加密之前先在密码末尾加一串内部约定的字符串，再对密码进行加密，最后截取其中一部分字符串进行密码提交与登录匹配。这是我第一次对加密算法有了接触。后来在使用支付宝支付SDK集成的过程中，我又知道了Base64、RSA、SHA1、SHA2加密算法，前者是在提交支付信息时有进行加密，后三个则是对商户私钥公钥等的计算加密。不过，我完全不了解这些算法的加密原理和使用领域，今天来了兴趣，就查一下吧。至于加密算法代码的实现，以后再说。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>加密算法主要分为以下三类：</p>
<ul>
<li>对称加密算法</li>
</ul>
<p>包括AES、DES、3DES等。加密和解密用到的密钥相同，加密速度快，适合经常发送数据的场所，但密钥传输需要格外注意。</p>
<ul>
<li>非对称加密\公钥加密算法</li>
</ul>
<p>包括RSA、DSA、ECC等。加密和解密的密钥不同，加密方式通常采用数学难题所构造，加密速度慢，适合偶尔发送数据的场所，密钥传输方便。</p>
<ul>
<li>安全散列算法</li>
</ul>
<p>包括MD5、SHA1、HMAC等。严格意义来说，加密算法需要满足加密与解密两个条件；而安全散列算法是不可逆的算法计算，所以其实不是加密算法之流。</p>
<h1 id="Base64加密算法"><a href="#Base64加密算法" class="headerlink" title="Base64加密算法"></a>Base64加密算法</h1><p>第二次碰到Base64加密算法，是在金云天的个人简历博客看到的。当时不太懂，只是觉得联系方式那串字符串末尾有一个熟悉的“=”号，在查找加密算法的时候歪打正着的查到了Base64加密算法，也就有了初步的认识。起因说完了，现在就来学习一下加密原理。</p>
<h2 id="加密原理"><a href="#加密原理" class="headerlink" title="加密原理"></a>加密原理</h2><p>我们先拿到一个要加密的字符串，将单个字符先按照ASCII码表转换为对应的数字，再将数字转换为8位的二进制数。得到全部的二进制数后，按6位划分开来，得到一个6位二进制数的全新数列，此时，再将数列转换为10进制。转换完毕后，按照Base64索引表，将数字转换为对应的字符，这样就完成了转换。</p>
<p>下面我附上Base64的索引表：</p>
<p><img src="/2018/10/16/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/1.jpg" alt></p>
<h2 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h2><p>举例，以我的博客名称“QingMi”为要加密的字符串。我们先将QingMi转换为ASCII码表对应的数字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">81 105 110 103 77 105</span><br></pre></td></tr></table></figure>
<p>再转换为二进制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01010001 01101001 01101110 01100111 01001101 01101001</span><br></pre></td></tr></table></figure>
<p>将这个数列按6位一组划分开来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">010100 010110 100101 101110 011001 110100 110101 101001</span><br></pre></td></tr></table></figure>
<p>转为十进制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20 22 37 46 25 52 53 41</span><br></pre></td></tr></table></figure>
<p>按照Base64索引表转换为字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UWluZ01p</span><br></pre></td></tr></table></figure>
<p>跟在线转换的网站的结果对比了一下，没有问题。</p>
<p>但是，这个转换过程存在一个问题：8位的二进制按6位划分的时候，最后的末尾不足6位怎么办。不急，这里还是有解决方案的。我们还是拿“QingM”来举例，接着走一遍刚才的步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">81 105 110 103 77</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01010001 01101001 01101110 01100111 01001101</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">010100 010110 100101 101110 011001 110100 1101</span><br></pre></td></tr></table></figure>
<p>走到这一步的时候，我们就需要在末尾补足0了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">010100 010110 100101 101110 011001 110100 110100</span><br></pre></td></tr></table></figure>
<p><strong>但是，还没有结束。</strong>我们还需要对加密的字符串的长度进行一下除3求余计算。这里长度是5，除3余2。如果余2，则在补足0后，<strong>在数列后加一个000000，但此数列不参与索引表转换，在最后只转换为“=”号</strong>；如果余1，<strong>则加两个000000</strong>。</p>
<p>那么此时，应当添加一个000000：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">010100 010110 100101 101110 011001 110100 110100 000000</span><br></pre></td></tr></table></figure>
<p>转换为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20 22 37 46 25 52 52</span><br></pre></td></tr></table></figure>
<p>末尾不参与索引表字符转换，直接在末尾添加一个“=”：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UWluZ00&#x3D;</span><br></pre></td></tr></table></figure>
<p>ok，转换完成。</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p><del>（我本不想讲用途的，但一想到以后若是与人谈论加密算法，却不知道用途，未免也太尴尬了些）</del></p>
<p>Base64编码在Java的Hibernate中有应用，也可用于HTTP环境下传递标识信息，但碍于“/”与“+”号在URL中会发生形式变化，不利于数据库数据的存储，所以有一些改进的Base64编码将最后的“/”与“+”号替换为“-”与“_”等。</p>
<h1 id="RSA加密算法"><a href="#RSA加密算法" class="headerlink" title="RSA加密算法"></a>RSA加密算法</h1><p>在查RSA加密算法之前，我绝没有想到它竟然是如此重量级的安全加密算法。它的加密原理，跟我上一个查过的Base64加密算法原理相差如此之大，涉及了很多高数的算法，让我这个高数一般的人学起来简直头大的不行。但既然已经查了，那我就把看来的东西整理一下。</p>
<p>首先要学习RSA用到的四个数学概念。</p>
<h2 id="理论知识准备"><a href="#理论知识准备" class="headerlink" title="理论知识准备"></a>理论知识准备</h2><p>1、<strong>互质</strong></p>
<p>如果两个正整数，没有除1以外的公约数，则这两个数是互质关系。并不一定只有质数之间才是互质关系，比如8和9，也是互质关系。</p>
<p>2、<strong>欧拉函数</strong></p>
<p>给定一个正整数$n$，求在小于等于$n$的正整数之中，与$n$构成互质关系的数的个数。计算这个数的函数称作欧拉函数，公式用$Φ(n)$表示。</p>
<ul>
<li><p>$n$=1时，$Φ(n)=1$</p>
</li>
<li><p>$n$是质数，则$Φ(n)=n-1$</p>
</li>
<li><p>$n$是质数的某一个次方，则$Φ(p^k)=p^k-p^{k-1}=p^k(1-\cfrac{1}{p})$</p>
</li>
<li><p>$n$可以分解为两互质整数之积，如$n=p_1p_2$，则$Φ(n)=Φ(p_1p_2)=Φ(p_1)Φ(p_2)$</p>
</li>
<li><p>因为任意一个大于1的正整数，都可以写成一系列质数的积，即$n=p_1p_2……p_r$;</p>
</li>
</ul>
<p>转换为$Φ(n)=Φ(p_1)Φ(p_2)……Φ(p_r)$；</p>
<p>最后得出$Φ(n)=n(1-\cfrac{1}{p_1})(1-\cfrac{1}{p_2})……(1-\cfrac{1}{p_r})$。</p>
<p>such as:$Φ(1323)=Φ(3^3*7^2)=1323(1-\cfrac{1}{3})(1-\cfrac{1}{7})=756$</p>
<p>3、<strong>欧拉定理</strong></p>
<p>如果两个正整数$a$与$n$互质，则满足以下等式：</p>
<p>$a^{Φ(n)}≡1\pmod n$</p>
<p>这个等式的意思是，$a$的$Φ(n)$次方被$n$除的余数为1，或者说，$a$的$Φ(n)$次方减去1可以被$n$整除。</p>
<p>当两者互质，且$n$为质数的时候，欧拉定理又可以写成：</p>
<p>$a^{p-1}≡1\pmod p$</p>
<p>这个等式又可以成为费马小定理。</p>
<p>4、<strong>模反元素</strong></p>
<p>如果两个正整数$a$和$n$互质，那么一定可以找到整数$b$，使得$ab-1$被$n$整除，即：</p>
<p>$ab≡1\pmod n$</p>
<p>此时$b$就成为$a$的模反元素。比如4与7互质，那么4的模反元素就是$2+7k$（$k$为整数）。欧拉定理有计算函数如下：</p>
<p>$a^{Φ(n)}=a*a^{Φ(n)-1}≡1\pmod n$</p>
<p>所以，$a^{Φ(n)-1}$就是$a$的模反元素。</p>
<h2 id="秘钥生成步骤"><a href="#秘钥生成步骤" class="headerlink" title="秘钥生成步骤"></a>秘钥生成步骤</h2><p>1、随机选择两个不相等的质数，$p$与$q$</p>
<p>此处取59和83</p>
<p>2、计算这两个数的乘积$n$</p>
<p>$59 * 83 = 4897$</p>
<p>3、计算乘积的欧拉函数$Φ(n)$</p>
<p>$Φ(4897)=58 * 82 = 4756$</p>
<p>4、随机选择一个整数$e$，条件是<strong>1&lt;e&lt;Φ(n)，且e与Φ(n)互质</strong></p>
<p>此处取23</p>
<p>5、计算$e$与$Φ(n)$的模反元素$d$</p>
<p>$ed≡1\pmod Φ(n)$</p>
<p>等价于 $ed - 1 = kΦ(n)$</p>
<p>得到 $ed + kΦ(n) = 1$ （不用在意$k$转换前后的符号，计算的时候代入符号转换即可）</p>
<p>代入数，得到 $23d + 4756k = 1$</p>
<p>采用<a href="https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95">扩展欧几里得算法</a>求解，过程如下：</p>
<p>先用类似辗转相除法，做以下计算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4756&#x3D;23*206+18</span><br><span class="line">23&#x3D;18*1+5</span><br><span class="line">18&#x3D;5*3+3</span><br><span class="line">5&#x3D;3*1+2</span><br><span class="line">3&#x3D;2*1+1</span><br></pre></td></tr></table></figure>
<p>然后改写成“余数等于”的形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18&#x3D;4756+23*(-206)	&#x2F;&#x2F;式1</span><br><span class="line">5&#x3D;23+18*(-1)		&#x2F;&#x2F;式2</span><br><span class="line">3&#x3D;18+5*(-3)			&#x2F;&#x2F;式3</span><br><span class="line">2&#x3D;5+3*(-1)			&#x2F;&#x2F;式4</span><br><span class="line">1&#x3D;3+2*(-1)</span><br></pre></td></tr></table></figure>
<p>然后开始“倒回来：计算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#x3D;3+2*(-1)</span><br><span class="line"> &#x3D;3+[5+3*(-1)]*(-1)				&#x2F;&#x2F;代入式4</span><br><span class="line"> &#x3D;3*2+5*(-1)</span><br><span class="line"> &#x3D;[18+5*(-3)]*2+5*(-1)			&#x2F;&#x2F;代入式3</span><br><span class="line"> &#x3D;18*2+5*(-7)</span><br><span class="line"> &#x3D;18*2+[23+18*(-1)]*(-7)		&#x2F;&#x2F;代入式2</span><br><span class="line"> &#x3D;18*9+23*(-1)</span><br><span class="line"> &#x3D;[4756+23*(-206)]*9+23*(-7)	&#x2F;&#x2F;代入式1</span><br><span class="line"> &#x3D;4756*9+23*(-1861)</span><br></pre></td></tr></table></figure>
<p>到此可以得出，$d=-1861$,$k=9$。</p>
<p><del>（这方法对整数形式的二元一次方程真是一个万能解，流弊）</del></p>
<p>6、将$n$和$e$封装成公钥，$n$和$d$封装成私钥</p>
<p>先回顾一下我们算过的所有有用的数：$p=59$,$q=83$,$n=4897$,$Φ(4897)=4756$,$e=23$,$d=-1861$</p>
<p>公钥用$(n,e)$表达，私钥用$(n,d)$表达，那么计算出来的公钥就是$(4897,23)$，私钥为$(4897,-1861)$</p>
<p>7、加密与解密</p>
<p>费心费力的算了半天，还不知道这公钥私钥怎么用，我都感觉自己差不多白学了，所以这里就讲一下怎么用。</p>
<ul>
<li>加密</li>
</ul>
<p>假设A向B发送信息$m$，A用公钥$(n,e)$进行加密。注意，$m$必须是证书且$m&lt;n$。而加密，就是要算出下式的$c$：</p>
<p>$m^e=c\pmod n$</p>
<p>公钥是$(4897,23)$,取$m$为7,则式为： $7^{23}≡c\pmod {4897}$</p>
<p>计算得出：$c=3855$。那么3855就是加密后的数字，A把它给了B。</p>
<p><del>(这里我只能取个比较小的数。最开始取了个101，然后，101的23次方，计算器炸了，，，，，)</del></p>
<ul>
<li>解密</li>
</ul>
<p>B拿到了3855，又有私钥$(4897,-1861)$，那要怎么解密呢？代入以下等式计算：</p>
<p>$c^d=m\pmod n$</p>
<p>代入得 $3855^{-1861}≡m\pmod {4897}$</p>
<p>emmmmmmm，等等，3855的-1861次方，这尼玛怎么算，等等，参考的博客是2790的2753次方，他怎么算的？芽儿哟，这怎么解啊。。。。。。这特么尴尬了，举了个例子结果有私钥都没法算，嗯……这大概就是RSA的安全性所在吧。。。。。</p>
<p>8、RSA的算法可靠性</p>
<p>维基百科这样说：“对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。”但维基百科又报道，到目前为止，并没有一种固定可靠的算法可以破解RSA算法。尽管如此，曾有暴力破解的方式破解过768位的秘钥，但花费时间漫长，从破解512位到768位花了漫长的10年。不过，普遍建议应将秘钥从1024位升级到2048位。</p>
<p>至于算法的安全性证明，我就不看了，光是上面这个次方计算都有点头疼。我知道有些算法可以优化次方运算，不过那是以后学习其他算法的事情了。原理明白就行了。想看安全性证明的，我在这里挂上参考博客链接：</p>
<p><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">RSA算法原理</a></p>
<h1 id="MD5摘要算法"><a href="#MD5摘要算法" class="headerlink" title="MD5摘要算法"></a>MD5摘要算法</h1><p>好吧，看来是Base64算法过于简单，让我产生了一部分算法都是简单的符号映射的错觉。在查阅MD5加密算法的资料过程中，MD5算法的过程运算让我更加头大。嘛，行吧，加密算法不难的话怎么能称为加密算法呢。</p>
<p>MD5算法是经由MD2、MD3、MD4发展而来。它的最大特点是，可以将任意长度的字节串变换成定长的字符串，现目前流行的有16位与32位。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>MD5算法是将输入的不定长度信息，输出固定长度为128-bits的算法。</p>
<h3 id="数据填充"><a href="#数据填充" class="headerlink" title="数据填充"></a>数据填充</h3><p>MD5算法对数据填充分两个步骤：</p>
<ul>
<li>1、<strong>填充信息至信息长度对512取模得448</strong></li>
</ul>
<p>填充方法：在信息后面填充一个1与无数个0，直至满足第一个条件</p>
<ul>
<li>2、<strong>在信息末尾添加信息长度的信息</strong></li>
</ul>
<p>看起来很绕，其实就是在上一步填充完的信息后，添加一个64位长度的二进制位数信息。这样一来，448+64=512，整个信息的长度还是可以被512整除的。这样做的话，在后面处理信息的时候也比较方便。</p>
<p>MD5会把信息以512位分组，再将每一分组划分为16个32位子分组。</p>
<h3 id="数据计算"><a href="#数据计算" class="headerlink" title="数据计算"></a>数据计算</h3><ul>
<li>四个被称作链接变量的常数：$A=0x67452301$,$B=0xEFCDAB89$,$C=0x98BADCFE$,$D=0x10325476$</li>
</ul>
<p>分别赋予小写$a$、$b$、$c$、$d$</p>
<p><del>(常数值与部分博客有出入，但观察一下，发现四个常数值的数字顺序是有规律的颠倒放置，至于原因还不知道)</del></p>
<ul>
<li>四个非线性函数</li>
</ul>
<p>$F(X,Y,Z)$ = ($X$ &amp; $Y$) | ($~X$ &amp; $Z$)</p>
<p>$G(X,Y,Z)$ = ($X$ &amp; $Z$) | ($Y$ &amp; $~Z$)</p>
<p>$H(X,Y,Z)$ = $X$ ^ $Y$ ^ $Z$</p>
<p>$I(X,Y,Z)$ = $Y$ ^ ($X$ | $~Z$)</p>
<p>准备完毕，下面就开始讲计算过程。</p>
<p>计算过程主要是四轮循环运算；每轮循环运算的次数，是512位信息分组的数目，即多少个32位信息组；每次运算，对$a$、$b$、$c$和$d$的其中三个做一次非线性函数运算，然后将所得结果加上第四个变量，文本信息的一个子分组，一个常数，将结果向右移一个不定的数，加上$a$、$b$、$c$、$d$其中之一，并用结果取代$a$、$b$、$c$、$d$之一。听起来很糊涂，那就看一下算式：</p>
<p>$F(a,b,c,d,M_j,s,t_i)表示a=b+(a+F(b,c,d)+M_j+t_i)&lt;&lt;$</p>
<p>其中$M_j$指文本信息子分组，$t_i$是常数，至于$s$，我猜是位移的数吧</p>
<p>这样经过几轮计算之后，将最后计算出来的$a$、$b$、$c$、$d$输出，就是最后的MD5值了。32位的MD5值是完整的计算结果，而16位的MD5值是截取的32位值的9~24位。</p>
<h2 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h2><p>1、常用作文件下载的核对，用于校验文件在下载过程中是否遭到不法程序篡改。</p>
<p>2、很多网站用来存储用户的密码，鉴于MD5算法的不可逆性，很难算出密码原文内容，所以经常用来做用户注册时密码的存储与登录时密码的核对。</p>
<p>3、数字签名。MD5也经常用作第三方认证机构的文件摘要信息比对，称“数字签名”。</p>
<p>PS：MD5算法现在已经不再完全可靠，已经有国内的科学院研究者破解了MD5的碰撞抵抗。</p>
<h1 id="AES加密算法"><a href="#AES加密算法" class="headerlink" title="AES加密算法"></a>AES加密算法</h1><p>查阅资料的时候，发现DES算法因已遭到破解，不再是安全的加密算法，所以又改换成学习AES加密算法。因为我实在看的有些困难，所以先贴上我参考的两篇比较好的详解博客：</p>
<p><a href="https://blog.csdn.net/qq_28205153/article/details/55798628">AES加密算法的详细介绍与实现</a></p>
<p><a href="https://www.cnblogs.com/luop/p/4334160.html">密码算法详解——AES</a></p>
<h2 id="加密原理-1"><a href="#加密原理-1" class="headerlink" title="加密原理"></a>加密原理</h2><p>AES是一种区块加密算法，即分组加密，将明文分成多个等长的模块，直至加密完所有明文。AES标准规范中，分组只能是128位，即每个分组为16个字节。但密钥的长度可以选择128位、192位或256位，每个选择对应的推荐加密轮数也不同，如下所示：</p>
<p><img src="/2018/10/16/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/3.jpg" alt></p>
<h2 id="加密步骤"><a href="#加密步骤" class="headerlink" title="加密步骤"></a>加密步骤</h2><p>因为过程很长，所以我先对整个过程做一个概要阐述：以AES-128举例，AES算法先将明文分组，每组被分为16个字节，用4x4的明文矩阵表示；然后将每组的明文矩阵转换为状态矩阵；然后进入AES的10轮加密，每轮加密均需要依次进行4个步骤，字节代换、行移位、列混合、轮密钥加（第一轮加密之前需先进行一次轮密钥加，最后一轮加密不需进行列混合）；最后，将输出的加密过后的状态矩阵替换为字符串，得到的即是密文。解密的过程，则是将上述的加密过程逆向进行即可。流程如下图所示：</p>
<p><img src="/2018/10/16/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/2.jpg" alt></p>
<h3 id="矩阵预处理"><a href="#矩阵预处理" class="headerlink" title="矩阵预处理"></a>矩阵预处理</h3><p>假设明文已被分好，第一组如下所示：</p>
<script type="math/tex; mode=display">
  \left[
  \begin{matrix}
   a & e & i & m \\\
   b & f & j & n \\\
   c & g & k & o \\\
   d & h & l & p
  \end{matrix}
  \right] \tag{1}</script><p>先将矩阵转换为状态矩阵，方法是只需将字符串转换为对应的十六进制即可：</p>
<script type="math/tex; mode=display">
  \left[
  \begin{matrix}
   0x61 & 0x65 & 0x69 & 0x6D \\\
   0x62 & 0x66 & 0x6A & 0x6E \\\
   0x63 & 0x67 & 0x6B & 0x6F \\\
   0x64 & 0x68 & 0x6C & 0x70
  \end{matrix}
  \right] \tag{2}</script><p>接下来该进行轮密钥加了。但考虑到我没办法进行10次加密运算，只能将每个步骤的计算方法讲清楚就行了，所以我把轮密钥加放在每轮的加密步骤中讲解。</p>
<h3 id="字节代换"><a href="#字节代换" class="headerlink" title="字节代换"></a>字节代换</h3><p>字节代换其实是一个查表替换字符的操作，AES算法为此定义了一个S盒和逆S盒（S盒与逆S盒的字符位置是固定的，是按照公式<script type="math/tex">GF(2^8) = GF(2)[x]/(x^8 + x^4 + x^3 + x + 1)</script>计算来的，有兴趣的可以去查一下）。表如下所示：</p>
<p><img src="/2018/10/16/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/4.jpg" alt></p>
<p><img src="/2018/10/16/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/5.jpg" alt></p>
<p>替换规则其实很简单：将原文的高4位作为行值，低4位作为列值，找到对应的元素，输出即可：</p>
<script type="math/tex; mode=display">
  \left[
  \begin{matrix}
   0xEF & 0x4D & 0xF9 & 0x3C \\\
   0xAA & 0x33 & 0x02 & 0x9F \\\
   0xFB & 0x85 & 0x7F & 0xA8 \\\
   0x43 & 0x45 & 0x50 & 0x51
  \end{matrix}
  \right] \tag{3}</script><p>逆向解密则从逆S盒取值即可。</p>
<h3 id="行移位"><a href="#行移位" class="headerlink" title="行移位"></a>行移位</h3><p>行移位是一个左循环移位操作。密钥长度为128位时，加密时，矩阵第0行左移0位，第1行左移1位，第2行左移2位，第3行左移3位。同理，解密时逆向即可。</p>
<script type="math/tex; mode=display">
  \left[
  \begin{matrix}
   0xEF & 0x4D & 0xF9 & 0x3C \\\
   0x33 & 0x02 & 0x9F & 0xAA \\\
   0x7F & 0xA8 & 0xFB & 0x85 \\\
   0x51 & 0x43 & 0x45 & 0x50
  \end{matrix}
  \right] \tag{4}</script><h3 id="列混合"><a href="#列混合" class="headerlink" title="列混合"></a>列混合</h3><p>列混合运算是将移位后的状态矩阵与固定的壶镇相乘，得到计算后的状态矩阵。固定矩阵如下：</p>
<script type="math/tex; mode=display">
  \left[
  \begin{matrix}
   02 & 03 & 01 & 01 \\\
   01 & 02 & 03 & 01 \\\
   01 & 01 & 02 & 03 \\\
   03 & 01 & 01 & 02
  \end{matrix}
  \right] \tag{5}</script><p>比如第一行第一列的元素的计算：</p>
<p>$S=(2\times0xEF)\bigotimes 0x4D \bigotimes 0xF9 \bigotimes (3\times0x3C)$</p>
<p>运算规则：1、对于2进制来说，乘以2即是将数左移一位。如果原数最高位为1，则需要在移位后再同（0001 1011）进行异或运算，比如$2\times0xEF$:</p>
<p>EF转换为二进制即为：1110 1111</p>
<p>乘2左移一位：1101 1110</p>
<p>因原最高位为1，故与0001 1011进行异或运算，得到：</p>
<p>1100 0101</p>
<p>这就是$2\times0xEF$的运算结果。</p>
<p>2、对于乘3运算，需要用分配率来进行运算，如$3\times0x3C$：</p>
<p>$3\times0x3C=(2+1)\times0011 1100=0111 1000\bigotimes0011 1100=0100 0100$</p>
<p>3、这样一来，就只剩下异或运算了，这就不用多说了吧：</p>
<p>1100 0101<br>0100 1101<br>1111 1001<br>0100 0100</p>
<p>得到结果：0011 0101</p>
<p>转换为十六进制即为：$0x35$</p>
<p>计算的过程如果手算那就太麻烦了，所以尽管可能多花了点时间，我还是写了点Java代码来实现计算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;存放状态矩阵</span><br><span class="line">        int a[][] &#x3D; new int[][]&#123;&#123;0xEF,0x4D,0xF9,0x3C&#125;,&#123;0x33,0x02,0x9F,0xAA&#125;,&#123;0x7F,0xA8,0xFB,0x85&#125;,&#123;0x51,0x43,0x45,0x50&#125;&#125;;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;存放要相乘的固定矩阵</span><br><span class="line">        int b[][] &#x3D; new int[][]&#123;&#123;2,3,1,1&#125;,&#123;1,2,3,1&#125;,&#123;1,1,2,3&#125;,&#123;3,1,1,2&#125;&#125;;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;存放计算后的状态矩阵</span><br><span class="line">        int c[][] &#x3D; new int[4][4];</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;先将后状态矩阵赋值为0</span><br><span class="line">        for(int i&#x3D;0;i&lt;4;i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;4;j++)&#123;</span><br><span class="line">                c[i][j]&#x3D;0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Main main &#x3D; new Main();</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;0;i&lt;4;i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;4;j++)&#123;</span><br><span class="line">                &#x2F;&#x2F;为方便理解下面的循环，在这里列出16次计算时每次计算的公式</span><br><span class="line">				&#x2F;&#x2F;c[i][j]&#x3D;a[i][0]*b[0][j]+a[i][1]*b[1][j]+a[i][2]*c[2][j]+a[i][3]*b[3][j];</span><br><span class="line">                int res &#x3D; 0;</span><br><span class="line">                for(int k&#x3D;0;k&lt;4;k++)&#123;</span><br><span class="line">                    if(b[k][j]&#x3D;&#x3D;2)&#123;</span><br><span class="line">                        res &#x3D; res ^ main.doubleCal(a[i][k]);</span><br><span class="line">                    &#125;else if(b[k][j]&#x3D;&#x3D;3)&#123;</span><br><span class="line">                        res &#x3D; res ^ main.tripleCal(a[i][k]);</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        res &#x3D; res ^ a[i][k];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                c[i][j]&#x3D;res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;输出计算后的状态矩阵</span><br><span class="line">        for(int i&#x3D;0;i&lt;4;i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;4;j++)&#123;</span><br><span class="line">				&#x2F;&#x2F;Integer.toHexString方法，可将十进制转化为十六进制输出；十六进制转化为十进制则为Integer.parseInt方法</span><br><span class="line">                System.out.print(Integer.toHexString(c[i][j])+&quot;  &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;乘2运算的情况处理</span><br><span class="line">    public int doubleCal(int a)&#123;</span><br><span class="line">		&#x2F;&#x2F;若a的最高位为1，即a大于127，则先移位，但移位不减值，故再减去超出8位的值，再与0001 1011，即27，进行异或运算</span><br><span class="line">        if(a&gt;127)&#123;</span><br><span class="line">            a &#x3D; a &lt;&lt; 1;</span><br><span class="line">            a -&#x3D; 256;</span><br><span class="line">            a &#x3D; a ^ 27;</span><br><span class="line">            return a;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            a &#x3D; a &lt;&lt; 1;</span><br><span class="line">            return a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;乘3运算的情况处理</span><br><span class="line">    public int tripleCal(int a)&#123;</span><br><span class="line">        a &#x3D; doubleCal(a) ^ a;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后计算出的结果是：</p>
<script type="math/tex; mode=display">
  \left[
  \begin{matrix}
   0x35 & 0x75 & 0xED & 0xCA \\\
   0x1E & 0x64 & 0xBA & 0xC4 \\\
   0x39 & 0xB4 & 0xF4 & 0xD0 \\\
   0x54 & 0x60 & 0x4E & 0x7D
  \end{matrix}
  \right] \tag{6}</script><p>逆运算的话，则是乘以上述固定矩阵的逆矩阵即可，该逆矩阵如下：</p>
<script type="math/tex; mode=display">
  \left[
  \begin{matrix}
   0x0E & 0x0B & 0x0D & 0x09 \\\
   0x09 & 0x0E & 0x0B & 0x0D \\\
   0x0D & 0x09 & 0x0E & 0x0B \\\
   0x0B & 0x0D & 0x09 & 0x0E
  \end{matrix}
  \right] \tag{7}</script><h3 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h3><p>轮密钥加则是将128位轮密钥同状态矩阵中的数据进行异或运算。密钥分成4组，每组32位字，状态矩阵取每列四个元素组成的32位字，依次对应进行异或运算，得到加密后的新状态矩阵。</p>
<p>在逆运算时，密钥不需改变，因为异或运算的特性，再次运算即可得到加密前的矩阵。</p>
<h3 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a>密钥扩展</h3><p>有一项事情需要注意：每一轮异或运算的密钥是在不断变化的。接下来就是了解一下，密钥变化的规律。</p>
<p>假设密钥Key为“abcdefghijklmnop”，则有$W[0]=“abcd”$,$W[1]=“efgh”$,$W[2]=“ijkl”$,$w[3]=“mnop”$。这是在进行10轮加密之前，最初的加密密钥。而接下来10轮所用到的40个新列$W[i]$，则以以下的规律计算：</p>
<p>1、如果i不是4的倍数</p>
<p>$W[i]=W[i-4] \bigotimes W[i-1]$</p>
<p>2、如果i是4的倍数</p>
<p>$W[i]=w[i-4] \bigotimes T(W[i-1])$</p>
<p>这里，T是一个由3部分组成的函数，包括字循环、字节代换和轮常量异或，分别如下：</p>
<p>$a$.字循环：将字节循环左移1个字节，如“abcd”变为“bcda”。</p>
<p>$b$.字节代换：这个不用多说，使用表为S盒。</p>
<p>$c$.轮常量异或：将值与轮常量进行异或，每一轮异或的值均不同，其表如下：</p>
<p><img src="/2018/10/16/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/6.jpg" alt></p>
<p>比如上述密钥可转化为“61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F 70”。那么4个初始值为：</p>
<p>$W[0]$=61 62 63 64</p>
<p>$W[1]$=65 66 67 68</p>
<p>$W[2]$=69 6A 6B 6C</p>
<p>$W[3]$=6D 6E 6F 70</p>
<p>求$W[4]$、$W[5]$、$W[6]$、$W[7]$</p>
<p>$W[4]=w[0] \bigotimes T(W[3])$</p>
<p>$T(W[3])$计算步骤：</p>
<p>1、6D 6E 6F 70输出变为6E 6F 70 6D</p>
<p>2、在S盒中找到对应字节，输出9F A8 51 3C</p>
<p>3、第一轮加密异或的数组为01 00 00 00,运算后输出9E A8 51 3C。</p>
<p>所以$T(W[3])$=9E A8 51 3C。</p>
<p>所以$W[4]$=61 62 63 64 $\bigotimes$ 9E A8 51 3C=FF CA 32 58</p>
<p>$W[5]=W[1] \bigotimes W[4]$=65 66 67 68 $\bigotimes$ FF CA 32 58=99 AC 55 30</p>
<p>$W[6]=W[2] \bigotimes W[5]$=69 6A 6B 6C $\bigotimes$ 99 AC 55 30=F0 C6 3E 5C</p>
<p>$W[7]=W[3] \bigotimes W[6]$=6D 6E 6F 70 $\bigotimes$ F0 C6 3E 5C=9D A8 51 2C</p>
<p>将所有结果组合起来，即为第一轮的密钥:FF CA 32 58 99 AC 55 30 F0 C6 3E 5C 9D A8 51 2C</p>
<h2 id="用途-2"><a href="#用途-2" class="headerlink" title="用途"></a>用途</h2><p>介于DES算法已被破解的事实，很多文件开始向3DES和AES加密靠拢。AES加密算法也并非牢不可破，目前已有成功的对AES算法的尝试攻击，不过距离算法的正式破解，还有一些难度。此外也有一些不针对算法，而针对算法系统或是安全系统的旁道攻击，不过这些攻击，就都是算法研究的题外话了。</p>
<p><del>（哇，终于把这个AES写完了，累死了。）</del></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这几章算法我均只讲解了初步原理。在查询及亲自使用在线加密算法的时候，深感每个算法均有很多不同的模式，而这些模式在原理讲解的博客中均未提及，可能是在代码实现的过程中有所差异？不过鉴于目前我还不会过度深入代码的实现，所以就点到为止。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>排序算法一直以来是我学的比较乱的一个部分，分不太清很多常用算法的特点。这次趁着写博客，我仔细捋一捋我听说过的算法。wiki百科上给出了很全的算法目录，我点了点，有一半的算法连名字都没听过，尤其是不实用算法的那五个，就不多做阐述了。</p>
<p>本篇博客排序的适用规模从小到大。</p>
<a id="more"></a>
<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>在讲解算法之前，要先考虑清楚，一个算法孰优孰劣，应该有怎样的评判标准。我觉得wiki百科上给出的几点很明确了，我就在这里直接引用了。</p>
<p>评判标准：</p>
<blockquote>
<ul>
<li><strong>计算的时间复杂度</strong>：（最差、最优及平均），依据列表的大小($n$)。一般而言，好的性能是$O(nlogn)$，坏的性能是$O(n^2)$。</li>
<li><strong>内存使用量</strong>：以及其他电脑资源的使用</li>
<li><strong>稳定性</strong>：稳定排序算法会让原本有相同键值的记录维持相对次序。比如说5，2，5，6，排完序后第一个5依然在第二个5之前，称稳定。但很多情况下，排列的元素并不会只是一个数字，多数为有很多属性的元素，所以稳定性就显得格外重要。</li>
</ul>
</blockquote>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>工作原理：重复走访过要排序的数列，一次比较两个元素，如果顺序错误就把他们交换过来，重复至到没有再需要交换，则排序完成。</p>
<p>算法描述：<br>1、比较相邻元素。如果第一个比第二个大（或小），则交换。<br>2、对当前范围每一对相邻元素做比较。结束时，最后的元素是最大值（或最开始的元素是最小值）。<br>3、缩小比较范围。<br>4、重复操作2、3，直至范围变为1，即不再需要比较。</p>
<p><strong>计算的时间复杂度</strong>：</p>
<blockquote>
<ul>
<li>最坏：$O(n^2)$</li>
<li>最优：$O(n)$</li>
<li>平均：$O(n^2)$</li>
</ul>
</blockquote>
<p><strong>内存使用量</strong>：</p>
<blockquote>
<ul>
<li>空间复杂度：需要辅助空间$O(1)$</li>
</ul>
</blockquote>
<p><strong>稳定性</strong>：<strong>稳定</strong></p>
<p><strong>特点</strong>：简单，稳定，但效率低下。</p>
<p>Java代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void bubbleSort(int arr[]) &#123;</span><br><span class="line">        int len &#x3D; arr.length;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">            for(int j &#x3D; 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class="line">                if(arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                    int temp &#x3D; arr[j];</span><br><span class="line">                    arr[j] &#x3D; arr[j + 1];</span><br><span class="line">                    arr[j + 1] &#x3D; temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>示意图</strong>：</p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/BubbleSort.gif" alt></p>
<p><strong>鸡尾酒排序</strong></p>
<p>鸡尾酒排序属于冒泡排序的一种变形，不同的是冒泡每次循环是单向，但鸡尾酒是双向。</p>
<p>大部分特点与冒泡排序一样。若排序是大部分已经排序过的话，会接近$O(n)$。</p>
<p><strong>示意图</strong>：</p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/CocktailSort.gif" alt></p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<p>算法描述：<br>1、将未排序序列的第一个元素标记为最小值<br>2、遍历当前未排序序列，找出最小值并标记<br>3、将最小值放至已排序序列末尾<br>4、重复1、2、3，直至未排序序列为空</p>
<p><strong>计算的时间复杂度</strong>：</p>
<blockquote>
<ul>
<li>最优、最差及平均：$O(n^2)$</li>
</ul>
</blockquote>
<p><strong>内存使用量</strong>：</p>
<blockquote>
<ul>
<li>空间复杂度：需要辅助空间$O(1)$</li>
</ul>
</blockquote>
<p><strong>稳定性</strong>：<strong>不稳定</strong></p>
<p><strong>特点</strong>：数据量较小时，选择排序比冒泡排序要快。原地操作几乎是选择排序的唯一优点，空间复杂度要求较高时，可选择此排序；然而实际应用比较罕见。</p>
<p>Java代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void selectionSort(int[] arr) &#123;</span><br><span class="line">        int i, j, min, temp, len &#x3D; arr.length;</span><br><span class="line">        for (i &#x3D; 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">            min &#x3D; i;&#x2F;&#x2F;未排序序列中最小数据数组下标</span><br><span class="line">            for (j &#x3D; i + 1; j &lt; len; j++)&#x2F;&#x2F;在未排序元素中继续寻找最小元素，并保存其下标</span><br><span class="line">                if (arr[min] &gt; arr[j]) &#123;</span><br><span class="line">                    min &#x3D; j;</span><br><span class="line">                &#125;</span><br><span class="line">            temp &#x3D; arr[min]; &#x2F;&#x2F;将最小元素放到已排序序列的末尾</span><br><span class="line">            arr[min] &#x3D; arr[i];</span><br><span class="line">            arr[i] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>示意图</strong>：</p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/SelectionSort.gif" alt></p>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>工作原理：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。其实插入排序的过程与玩手牌一样，从后往前查看比较，找到相应的位置插入即可。</p>
<p>算法描述：<br>1、从第一个元素开始，可以认为它已被排序<br>2、取出下一个元素，在已排序序列中从后往前扫描<br>3、若某元素大于新元素，将该元素移至下一位置，如此重复，直至找到小于新元素的位置，将新元素插入该位置后<br>4、重复操作3</p>
<p><strong>计算的时间复杂度</strong>：</p>
<blockquote>
<ul>
<li>最坏：$O(n^2)$</li>
<li>最优：$O(n)$</li>
<li>平均：$O(n^2)$</li>
</ul>
</blockquote>
<p><strong>内存使用量</strong>：</p>
<blockquote>
<ul>
<li>空间复杂度：需要辅助空间$O(1)$</li>
</ul>
</blockquote>
<p><strong>稳定性</strong>：<strong>稳定</strong></p>
<p><strong>特点</strong>：不适合数据量比较大的排序应用。如果数据量小于千，或输入元素大致上按顺序排列，那么插入排序是一个不错的选择。</p>
<p>Java代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void insertionSort(int[] arr) &#123;</span><br><span class="line">        for(int i &#x3D; 0; i&lt;arr.length-1; i++) &#123;</span><br><span class="line">            for(int j &#x3D; i + 1; j &gt; 0; j--) &#123;</span><br><span class="line">                if(arr[j - 1] &lt;&#x3D; arr[j])</span><br><span class="line">                    break;</span><br><span class="line">                int temp &#x3D; arr[j];</span><br><span class="line">                arr[j] &#x3D; arr[j - 1];</span><br><span class="line">                arr[j - 1] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>示意图</strong>：</p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/InsertionSort-example.gif" alt></p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/InsertionSort.gif" alt></p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>也称递减增量排序算法，是插入排序的一种更高效的改进版本。</p>
<p>工作原理：将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素一次性地朝最终位置前进一大步，然后算法再取越来越小的步长进行排序，到最后一步，即变成了普通的插入排序。不过在最后，所有数据基本已经排序好了。</p>
<p>算法描述：<br>例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13 14 94 33 82</span><br><span class="line">25 59 94 65 23</span><br><span class="line">45 27 73 25 39</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>然后我们对<strong>每列</strong>进行排序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 14 73 25 23</span><br><span class="line">13 27 94 33 39</span><br><span class="line">25 59 94 65 82</span><br><span class="line">45</span><br></pre></td></tr></table></figure>
<p>然后再以3为步长进行划分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 14 73</span><br><span class="line">25 23 13</span><br><span class="line">27 94 33</span><br><span class="line">39 25 59</span><br><span class="line">94 65 82</span><br><span class="line">45</span><br></pre></td></tr></table></figure>
<p>排序后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 14 13</span><br><span class="line">25 23 33</span><br><span class="line">27 25 59</span><br><span class="line">39 65 73</span><br><span class="line">45 94 82</span><br><span class="line">94</span><br></pre></td></tr></table></figure>
<p>最后再以1为步长进行排序，此时就是简单的插入排序了</p>
<p><strong>重点</strong>：步长的选择是希尔排序的重要部分</p>
<p>Donald Shell(设计者)最初建议选择步长为$\frac {n}{2}$</p>
<p>已知的最好步长序列是（1，5，19，41，109，……）（详情见<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a>）</p>
<p><strong>计算的时间复杂度</strong>：</p>
<blockquote>
<ul>
<li>最优：$O(n)$</li>
<li>最差：$O((nlogn)^2)$</li>
<li>平均：$O((nlogn)^2)$</li>
</ul>
</blockquote>
<p><strong>内存使用量</strong>：</p>
<blockquote>
<ul>
<li>空间复杂度：需要辅助空间$O(1)$</li>
</ul>
</blockquote>
<p><strong>稳定性</strong>：<strong>不稳定</strong></p>
<p><strong>特点</strong>：在使用最优步长序列时，比插入排序快。在较小数组中，比快速排序和堆排序还要快。但若涉及大量数据，速度依旧不及快速排序。</p>
<p>Java代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void shellSort(int[] arr) &#123;</span><br><span class="line">	int gap &#x3D; 1, i, j, len &#x3D; arr.length;</span><br><span class="line">	int temp;</span><br><span class="line">	while (gap &lt; len &#x2F; 3)</span><br><span class="line">		gap &#x3D; gap * 3 + 1; </span><br><span class="line">	for (; gap &gt; 0; gap &#x2F;&#x3D; 3)</span><br><span class="line">		for (i &#x3D; gap; i &lt; len; i++) &#123;</span><br><span class="line">			temp &#x3D; arr[i];</span><br><span class="line">			for (j &#x3D; i - gap; j &gt;&#x3D; 0 &amp;&amp; arr[j] &gt; temp; j -&#x3D; gap)</span><br><span class="line">				arr[j + gap] &#x3D; arr[j];</span><br><span class="line">			arr[j + gap] &#x3D; temp;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的代码中的步长取$\frac {n}{3}$</p>
<p><strong>示意图</strong>：</p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/ShellSort.gif" alt></p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>工作原理：归并排序是采用<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95">分治法</a>的一个非常典型的应用。归并排序的思想是先递归分解数组，再合并数组。</p>
<p>算法描述（迭代法）：<br>1、申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>2、设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>3、比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>4、重复步骤3直到某一指针到达序列尾<br>5、将另一序列剩下的所有元素直接复制到合并序列尾</p>
<p>合并：基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。</p>
<p>分解：基本思路是将数组分解成left和right，如果这两个数组内部数据是有序的，那么就可以用上面合并数组的方法将这两个数组合并排序。如何让这两个数组内部是有序的？可以再二分，直至分解出的小组只含有一个元素时为止，此时认为该小组内部已有序。然后合并排序相邻二个小组即可。</p>
<p><strong>计算的时间复杂度</strong>：</p>
<blockquote>
<ul>
<li>最优、最差及平均：$O(nlogn)$</li>
</ul>
</blockquote>
<p><strong>内存使用量</strong>：</p>
<blockquote>
<ul>
<li>空间复杂度：所需辅助空间$O(n)$</li>
</ul>
</blockquote>
<p><strong>稳定性</strong>：<strong>稳定</strong></p>
<p>Java代码（迭代版）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void mergeSort(int[] arr) &#123;</span><br><span class="line">    int len &#x3D; arr.length;</span><br><span class="line">    int[] result &#x3D; new int[len];</span><br><span class="line">    int block, start;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 原版代码的迭代次数少了一次，没有考虑到奇数列数组的情况</span><br><span class="line">    for(block &#x3D; 1; block &lt; len; block *&#x3D; 2) &#123;</span><br><span class="line">        for(start &#x3D; 0; start &lt;len; start +&#x3D; 2 * block) &#123;</span><br><span class="line">            int low &#x3D; start;</span><br><span class="line">            int mid &#x3D; (start + block) &lt; len ? (start + block) : len;</span><br><span class="line">            int high &#x3D; (start + 2 * block) &lt; len ? (start + 2 * block) : len;</span><br><span class="line">            &#x2F;&#x2F;两个块的起始下标及结束下标</span><br><span class="line">            int start1 &#x3D; low, end1 &#x3D; mid;</span><br><span class="line">            int start2 &#x3D; mid, end2 &#x3D; high;</span><br><span class="line">            &#x2F;&#x2F;开始对两个block进行归并排序</span><br><span class="line">            while (start1 &lt; end1 &amp;&amp; start2 &lt; end2) &#123;</span><br><span class="line">	        result[low++] &#x3D; arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</span><br><span class="line">            &#125;</span><br><span class="line">            while(start1 &lt; end1) &#123;</span><br><span class="line">	        result[low++] &#x3D; arr[start1++];</span><br><span class="line">            &#125;</span><br><span class="line">            while(start2 &lt; end2) &#123;</span><br><span class="line">	        result[low++] &#x3D; arr[start2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	int[] temp &#x3D; arr;</span><br><span class="line">	arr &#x3D; result;</span><br><span class="line">	result &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    result &#x3D; arr;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示意图</strong>：</p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/MergeSort-example.gif" alt></p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/MergeSort.gif" alt></p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>工作原理：快速排序主要采取分治法，将大问题逐步划分为小问题，逐个解决。</p>
<p>算法描述：<br>1、从数列中挑出一个元素，称为“基准”。<br>2、分区：所有比基准值小的元素摆在基准前面，所有比基准值大的元素摆在基准后面。分区结束时，基准应位于数列中间。<br>3、对左右区间递归执行操作2，直至各区间只有一个数。</p>
<p><strong>计算的时间复杂度</strong>：</p>
<blockquote>
<ul>
<li>最坏：$O(n^2)$</li>
<li>最优：$O(nlogn)$</li>
<li>平均：$O(nlogn)$</li>
</ul>
</blockquote>
<p><strong>内存使用量</strong>：</p>
<blockquote>
<ul>
<li>空间复杂度：需要辅助空间$O(logn)$</li>
</ul>
</blockquote>
<p><strong>稳定性</strong>：<strong>不稳定</strong></p>
<p><strong>特点</strong>：通常情况下，快速排序比其他$O(nlogn)$算法更快。</p>
<p>Java代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void quickSort(int arr[],int head,int tail) &#123;</span><br><span class="line">        if (head &gt;&#x3D; tail || arr &#x3D;&#x3D; null || arr.length &lt;&#x3D; 1) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int i &#x3D; head, j &#x3D; tail, pivot &#x3D; arr[(head + tail) &#x2F; 2];</span><br><span class="line">        while (i &lt;&#x3D; j) &#123;</span><br><span class="line">            while (arr[i] &lt; pivot) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            while (arr[j] &gt; pivot) &#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &lt; j) &#123;</span><br><span class="line">                int t &#x3D; arr[i];</span><br><span class="line">                arr[i] &#x3D; arr[j];</span><br><span class="line">                arr[j] &#x3D; t;</span><br><span class="line">                ++i;</span><br><span class="line">                --j;</span><br><span class="line">            &#125; else if (i &#x3D;&#x3D; j) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        quickSort(arr, head, j);</span><br><span class="line">        quickSort(arr, i, tail);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>示意图</strong>：</p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/QuickSort-example.gif" alt></p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/QuickSort.gif" alt></p>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>顾名思义，堆排序是利用堆这种数据结构所设计的一种排序算法，采用的是<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E5%A0%86">二叉堆</a>。</p>
<p><strong>二叉堆性质</strong>：<br>1、父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。<br>2、每个节点的左右子树都是一个二叉堆（都是最大堆或最小堆）。</p>
<p>算法描述：<br>1、构造最大堆（Build_Max_Heap）：若数组下标范围为0~$n$，考虑到单独一个元素是大根堆，则从下标$\frac {n}{2}$开始的元素均为大根堆。于是只要从$\frac {n}{2}-1$开始，向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。</p>
<p>2、堆排序（HeapSort）：由于堆是用数组模拟的。得到一个大根堆后，数组内部并不是有序的。因此需要将堆化数组有序化。思想是移除根节点，并做最大堆调整的递归运算。第一次将heap[0]与heap[$n$-1]交换，再对heap[0…$n$-2]做最大堆调整。第二次将heap[0]与heap[$n$-2]交换，再对heap[0…$n$-3]做最大堆调整。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。</p>
<p>3、最大堆调整（Max_Heapify）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点 。</p>
<p>上面这个是从大佬的博客拷来的步骤，说实话，太官方太仔细了些，我看不太懂。不过我看了几遍大佬博客下面的示意图后，明白了大概步骤，下面就整理一下。</p>
<p>步骤：<br>1、将数组构造为最大堆，在构造的过程中每一步都要检测当前堆是否为最大堆，如果不是，则进行调整<br>2、将第一个根节点与末节点互换后，移除末节点。移除出的末节点，就是堆中的最大数。<br>3、重新构建最大堆<br>4、重复步骤2、3，直至堆只有一个节点后再移除，则得到排列好的序列</p>
<p><strong>计算的时间复杂度</strong>：</p>
<blockquote>
<ul>
<li>最优、最差及平均：$O(nlogn)$</li>
</ul>
</blockquote>
<p><strong>内存使用量</strong>：</p>
<blockquote>
<ul>
<li>空间复杂度：所需辅助空间$O(n)$</li>
</ul>
</blockquote>
<p><strong>稳定性</strong>：<strong>不稳定</strong></p>
<p>Java代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HeapSort &#123;</span><br><span class="line">    </span><br><span class="line">    private int[] arr;</span><br><span class="line">    </span><br><span class="line">    public HeapSort(int[] arr)&#123;</span><br><span class="line">        this.arr &#x3D; arr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 堆排序的主要入口方法，共两步。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void sort()&#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         *  第一步：将数组堆化</span><br><span class="line">         *  beginIndex &#x3D; 第一个非叶子节点。</span><br><span class="line">         *  从第一个非叶子节点开始即可。无需从最后一个叶子节点开始。</span><br><span class="line">         *  叶子节点可以看作已符合堆要求的节点，根节点就是它自己且自己以下值为最大。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        int len &#x3D; arr.length - 1;</span><br><span class="line">        int beginIndex &#x3D; (len - 1) &gt;&gt; 1; </span><br><span class="line">        for(int i &#x3D; beginIndex; i &gt;&#x3D; 0; i--)&#123;</span><br><span class="line">            maxHeapify(i, len);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;*</span><br><span class="line">         * 第二步：对堆化数据排序</span><br><span class="line">         * 每次都是移出最顶层的根节点A[0]，与最尾部节点位置调换，同时遍历长度 - 1。</span><br><span class="line">         * 然后从新整理被换到根节点的末尾元素，使其符合堆的特性。</span><br><span class="line">         * 直至未排序的堆长度为 0。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        for(int i &#x3D; len; i &gt; 0; i--)&#123;</span><br><span class="line">            swap(0, i);</span><br><span class="line">            maxHeapify(0, i - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void swap(int i,int j)&#123;</span><br><span class="line">        int temp &#x3D; arr[i];</span><br><span class="line">        arr[i] &#x3D; arr[j];</span><br><span class="line">        arr[j] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 调整索引为 index 处的数据，使其符合堆的特性。</span><br><span class="line">     * </span><br><span class="line">     * @param index 需要堆化处理的数据的索引</span><br><span class="line">     * @param len 未排序的堆（数组）的长度</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void maxHeapify(int index,int len)&#123;</span><br><span class="line">        int li &#x3D; (index &lt;&lt; 1) + 1; &#x2F;&#x2F; 左子节点索引</span><br><span class="line">        int ri &#x3D; li + 1;           &#x2F;&#x2F; 右子节点索引</span><br><span class="line">        int cMax &#x3D; li;             &#x2F;&#x2F; 子节点值最大索引，默认左子节点。</span><br><span class="line">        </span><br><span class="line">        if(li &gt; len) return;       &#x2F;&#x2F; 左子节点索引超出计算范围，直接返回。</span><br><span class="line">        if(ri &lt;&#x3D; len &amp;&amp; arr[ri] &gt; arr[li]) &#x2F;&#x2F; 先判断左右子节点，哪个较大。</span><br><span class="line">            cMax &#x3D; ri;</span><br><span class="line">        if(arr[cMax] &gt; arr[index])&#123;</span><br><span class="line">            swap(cMax, index);      &#x2F;&#x2F; 如果父节点被子节点调换，</span><br><span class="line">            maxHeapify(cMax, len);  &#x2F;&#x2F; 则需要继续判断换下后的父节点是否符合堆的特性。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 测试用例</span><br><span class="line">     * </span><br><span class="line">     * 输出：</span><br><span class="line">     * [0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9]</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; new int[]&#123;3,5,3,0,8,6,1,5,8,6,2,4,9,4,7,0,1,8,9,7,3,1,2,5,9,7,4,0,2,6&#125;;        </span><br><span class="line">        new HeapSort(arr).sort();        </span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示意图</strong>：</p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Heapsort-example.gif" alt></p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/HeapSort.gif" alt></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/sort.png" alt></p>
<p>PS：</p>
<blockquote>
<ul>
<li>Timsort是结合了合并排序与插入排序的算法，效率很好Java SE7、Android与python均采用Timsort算法对数组排列。（后续会更新此算法介绍）</li>
</ul>
</blockquote>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><blockquote>
<ul>
<li><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/">经典排序算法总结与实现</a></li>
<li><a href="http://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">排序算法可视化</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>文件Uri解析</title>
    <url>/2019/09/05/%E6%96%87%E4%BB%B6Uri%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>很早就想对音视频的uri做一个很认真的归纳分析，但一直觉得没有必要，直到遇到越来越多的不同机型的返回路径，搞得我一塌糊涂却又似懂非懂的，所以这一次就对手上现有的机型的返回路径和解析做一个归纳总结。</p>
<a id="more"></a>
<p>机型统计</p>
<blockquote>
<ul>
<li>小米4</li>
</ul>
</blockquote>
<pre><code>已刷为Android9.0原生系统，但我有安装小米国际版文件管理。选择文件时不同的文件管理系统会返回不同的路径。
</code></pre><blockquote>
<ul>
<li>华为</li>
</ul>
</blockquote>
<pre><code>公司的平板，EMUI3.1系统，Android版本5.1.1。
</code></pre><blockquote>
<ul>
<li>一加7</li>
</ul>
</blockquote>
<pre><code>氢OS9.5.7.GM57系统，Android版本9.0。
</code></pre><p>但其实归根结底，uri返回类型的内容取决于Android的版本以及所用的文件管理系统。原生系统中，Android4.4之前返回的uri就是路径；4.4之后，uri统一开始变为文件资源标识符。而且，受于不同软件的文件标识方法，返回的uri也会有不同。</p>
<h1 id="Uri组成"><a href="#Uri组成" class="headerlink" title="Uri组成"></a>Uri组成</h1><p>uri一般由以下几个部分构成：</p>
<p>[scheme:][//authority][path][?query][#fragment]</p>
<p>或者说</p>
<p>[scheme:][//host:port][path][?query][#fragment]</p>
<p>针对返回的uri，我取其中的getPath()、getAuthority()和getScheme()方法做一些比较。</p>
<h1 id="文件选择测试"><a href="#文件选择测试" class="headerlink" title="文件选择测试"></a>文件选择测试</h1><h2 id="小米4（选择了同一张图片）"><a href="#小米4（选择了同一张图片）" class="headerlink" title="小米4（选择了同一张图片）"></a>小米4（选择了同一张图片）</h2><blockquote>
<ul>
<li>9.0 文件系统</li>
</ul>
</blockquote>
<pre><code>path：/document/image:3180
authority：com.android.providers.media.documents
</code></pre><blockquote>
<ul>
<li>小米国际版文件管理</li>
</ul>
</blockquote>
<pre><code>path：/external_files/AchievemeentApp/Avatar.jpg
authority：com.mi.android.globalFileexplorer.myprovider
</code></pre><h2 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h2><blockquote>
<ul>
<li>图库</li>
</ul>
</blockquote>
<pre><code>path：/external/images/media/44678
authority：media
</code></pre><blockquote>
<ul>
<li>文件管理</li>
</ul>
</blockquote>
<pre><code>path：/storage/emulated/0/AchievementApp/Achievement.xls
authority：
scheme：file
</code></pre><h2 id="一加7"><a href="#一加7" class="headerlink" title="一加7"></a>一加7</h2><blockquote>
<ul>
<li>氢OS 图库</li>
</ul>
</blockquote>
<pre><code>path：/external/file/68400
authority：media
</code></pre><blockquote>
<ul>
<li>氢OS 文件管理</li>
</ul>
</blockquote>
<pre><code>path：/document/primary:AchievementApp/avatar.jpg
authority：com.android.externalstorage.documents
</code></pre><h2 id="Google-相册"><a href="#Google-相册" class="headerlink" title="Google 相册"></a>Google 相册</h2><pre><code>path : /-1/1/content://media/external/images/media/69009/ORIGINAL/NONE/1306754059
authority：com.google.android.apps.photos.contentprovider
</code></pre><h2 id="Google-Drive"><a href="#Google-Drive" class="headerlink" title="Google Drive"></a>Google Drive</h2><pre><code>path：/document/acc=1;doc=encoded=ismNrKUOIBuKKajB8VwcvErY5tVOtHT3P1OhHzic9JbtEmErmSmRRw==
authority：com.google.android.apps.docs.storage
</code></pre><p>除此之外，这些文件uri的scheme大部分是content类型，这一类略去了；个别返回了file类型，这一项有标出。</p>
<p>在使用的过程中，我发现Android系统本身返回的uri，只会是第一个出现的那样，故华为和一加7的Android系统文件返回路径情况我就略去了；而其余的路径，可以说，基本上都是由附加的文件管理软件的差异引起的uri路径差异，尤以Google软件的uri最让人惊异。</p>
<h1 id="Uri解析"><a href="#Uri解析" class="headerlink" title="Uri解析"></a>Uri解析</h1><p>我先给出我之前一段时间所使用到的一段解析uri的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String getFilePathByUri(Context context, Uri uri) &#123;</span><br><span class="line">    String path &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; 以 file:&#x2F;&#x2F; 开头的</span><br><span class="line">    if (ContentResolver.SCHEME_FILE.equals(uri.getScheme())) &#123;</span><br><span class="line">        path &#x3D; uri.getPath();</span><br><span class="line">        return path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 以 content:&#x2F;&#x2F; 开头的，比如 content:&#x2F;&#x2F;media&#x2F;extenral&#x2F;images&#x2F;media&#x2F;17766</span><br><span class="line">    if (ContentResolver.SCHEME_CONTENT.equals(uri.getScheme()) &amp;&amp; Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">        Cursor cursor &#x3D; context.getContentResolver().query(uri, new String[]&#123;MediaStore.Images.Media.DATA&#125;, null, null, null);</span><br><span class="line">        if (cursor !&#x3D; null) &#123;</span><br><span class="line">            if (cursor.moveToFirst()) &#123;</span><br><span class="line">                int columnIndex &#x3D; cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);</span><br><span class="line">                if (columnIndex &gt; -1) &#123;</span><br><span class="line">                    path &#x3D; cursor.getString(columnIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cursor.close();</span><br><span class="line">        &#125;</span><br><span class="line">        return path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 4.4及之后的 是以 content:&#x2F;&#x2F; 开头的，比如 content:&#x2F;&#x2F;com.android.providers.media.documents&#x2F;document&#x2F;image%3A235700</span><br><span class="line">    if (ContentResolver.SCHEME_CONTENT.equals(uri.getScheme()) &amp;&amp; Build.VERSION.SDK_INT &gt;&#x3D; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">        if (DocumentsContract.isDocumentUri(context, uri)) &#123;</span><br><span class="line">            if (isExternalStorageDocument(uri)) &#123;</span><br><span class="line">                &#x2F;&#x2F; ExternalStorageProvider</span><br><span class="line">                final String docId &#x3D; DocumentsContract.getDocumentId(uri);</span><br><span class="line">                final String[] split &#x3D; docId.split(&quot;:&quot;);</span><br><span class="line">                final String type &#x3D; split[0];</span><br><span class="line">                if (&quot;primary&quot;.equalsIgnoreCase(type)) &#123;</span><br><span class="line">                    path &#x3D; Environment.getExternalStorageDirectory() + &quot;&#x2F;&quot; + split[1];</span><br><span class="line">                    return path;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (isDownloadsDocument(uri)) &#123;</span><br><span class="line">                &#x2F;&#x2F; DownloadsProvider</span><br><span class="line">                final String id &#x3D; DocumentsContract.getDocumentId(uri);</span><br><span class="line">                final Uri contentUri &#x3D; ContentUris.withAppendedId(Uri.parse(&quot;content:&#x2F;&#x2F;downloads&#x2F;public_downloads&quot;), Long.valueOf(id));</span><br><span class="line">                path &#x3D; getDataColumn(context, contentUri, null, null);</span><br><span class="line">                return path;</span><br><span class="line">            &#125; else if (isMediaDocument(uri)) &#123;</span><br><span class="line">                &#x2F;&#x2F; MediaProvider</span><br><span class="line">                final String docId &#x3D; DocumentsContract.getDocumentId(uri);</span><br><span class="line">                final String[] split &#x3D; docId.split(&quot;:&quot;);</span><br><span class="line">                final String type &#x3D; split[0];</span><br><span class="line">                Uri contentUri &#x3D; null;</span><br><span class="line">                if (&quot;image&quot;.equals(type)) &#123;</span><br><span class="line">                    contentUri &#x3D; MediaStore.Images.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">                &#125; else if (&quot;video&quot;.equals(type)) &#123;</span><br><span class="line">                    contentUri &#x3D; MediaStore.Video.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">                &#125; else if (&quot;audio&quot;.equals(type)) &#123;</span><br><span class="line">                    contentUri &#x3D; MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">                &#125;</span><br><span class="line">                final String selection &#x3D; &quot;_id&#x3D;?&quot;;</span><br><span class="line">                final String[] selectionArgs &#x3D; new String[]&#123;split[1]&#125;;</span><br><span class="line">                path &#x3D; getDataColumn(context, contentUri, selection, selectionArgs);</span><br><span class="line">                return path;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static String getDataColumn(Context context, Uri uri, String selection, String[] selectionArgs) &#123;</span><br><span class="line">    Cursor cursor &#x3D; null;</span><br><span class="line">    final String column &#x3D; &quot;_data&quot;;</span><br><span class="line">    final String[] projection &#x3D; &#123;column&#125;;</span><br><span class="line">    try &#123;</span><br><span class="line">        cursor &#x3D; context.getContentResolver().query(uri, projection, selection, selectionArgs, null);</span><br><span class="line">        if (cursor !&#x3D; null &amp;&amp; cursor.moveToFirst()) &#123;</span><br><span class="line">        final int column_index &#x3D; cursor.getColumnIndexOrThrow(column);</span><br><span class="line">            return cursor.getString(column_index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (cursor !&#x3D; null)</span><br><span class="line">        cursor.close();</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static boolean isExternalStorageDocument(Uri uri) &#123;</span><br><span class="line">    return &quot;com.android.externalstorage.documents&quot;.equals(uri.getAuthority());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static boolean isDownloadsDocument(Uri uri) &#123;</span><br><span class="line">    return &quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static boolean isMediaDocument(Uri uri) &#123;</span><br><span class="line">    return &quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来的任务，就是按获取到uri一步一步走下去，看看都走到的是哪一步。</p>
<h2 id="小米4-9-0文件系统"><a href="#小米4-9-0文件系统" class="headerlink" title="小米4 9.0文件系统"></a>小米4 9.0文件系统</h2><p>先前已经说过，获取到的scheme全部为”content”，而且源码中定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static final String SCHEME_CONTENT &#x3D; &quot;content&quot;;</span><br></pre></td></tr></table></figure>
<p>且机型的Android系统最低为5.1的LOLLIPOP，必大于4.4的KITKAT。故判断全部进入了第三个判断方法之中。</p>
<p>接下来再来看源码中的DocumentsContract.isDocumentUri(Context context, Uri uri)方法（记为源方法1）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static boolean isDocumentUri(Context context, @Nullable Uri uri) &#123;</span><br><span class="line">    if (isContentUri(uri) &amp;&amp; isDocumentsProvider(context, uri.getAuthority())) &#123;</span><br><span class="line">        final List&lt;String&gt; paths &#x3D; uri.getPathSegments();</span><br><span class="line">        if (paths.size() &#x3D;&#x3D; 2) &#123;</span><br><span class="line">            return PATH_DOCUMENT.equals(paths.get(0));</span><br><span class="line">        &#125; else if (paths.size() &#x3D;&#x3D; 4) &#123;</span><br><span class="line">            return PATH_TREE.equals(paths.get(0)) &amp;&amp; PATH_DOCUMENT.equals(paths.get(2));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看源码的方法（记为源方法2）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static boolean isContentUri(@Nullable Uri uri) &#123;</span><br><span class="line">    return uri !&#x3D; null &amp;&amp; ContentResolver.SCHEME_CONTENT.equals(uri.getScheme());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自不用说，返回结果为true。接着下一个方法（记为源方法3）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static boolean isDocumentsProvider(Context context, String authority) &#123;</span><br><span class="line">    final Intent intent &#x3D; new Intent(PROVIDER_INTERFACE);</span><br><span class="line">    final List&lt;ResolveInfo&gt; infos &#x3D; context.getPackageManager().queryIntentContentProviders(intent, 0);</span><br><span class="line">    for (ResolveInfo info : infos) &#123;</span><br><span class="line">        if (authority.equals(info.providerInfo.authority)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法我看不懂，但单独拿出来运行了一遍，获取如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.android.documentsui.archives</span><br><span class="line">com.android.externalstorage.documents</span><br><span class="line">com.android.mtp.documents</span><br><span class="line">com.android.providers.downloads.documents</span><br><span class="line">com.android.providers.media.documents</span><br></pre></td></tr></table></figure>
<p>那么看来这个方法获取到的，就是系统本身所提供的contentProvider类了，不包括后安装的文件管理类软件。因为小米4上我安装了小米国际版文件管理，上面却并未获取到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.mi.android.globalFileexplorer.myprovider</span><br></pre></td></tr></table></figure>
<p>那么现在跳回源方法1，可以看出判断通过，接下来测试uri.getPathSegments方法，循环打印内容得到如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document</span><br><span class="line">image:3180</span><br></pre></td></tr></table></figure>
<p>很明显，此处size为2，paths.get[0]即为document。又因源代码定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static final String PATH_DOCUMENT &#x3D; &quot;document&quot;;</span><br></pre></td></tr></table></figure>
<p>故判断通过，源方法1返回结果为true。那么接下来再看判断的三个方法，均为provider名称匹配，名称依次为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.android.externalstorage.documents</span><br><span class="line">com.android.providers.downloads.documents</span><br><span class="line">com.android.providers.media.documents</span><br></pre></td></tr></table></figure>
<p>很熟悉，是我们在源方法3中打印过的内容之三，按字面意思理解，分别对应外存储文件，下载文件与媒体库文件。在这里，uri跳转至第三个判断方法，媒体库文件。接着往下走，获取文件id（记为源方法4）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String getDocumentId(Uri documentUri) &#123;</span><br><span class="line">    final List&lt;String&gt; paths &#x3D; documentUri.getPathSegments();</span><br><span class="line">    if (paths.size() &gt;&#x3D; 2 &amp;&amp; PATH_DOCUMENT.equals(paths.get(0))) &#123;</span><br><span class="line">        return paths.get(1);</span><br><span class="line">    &#125;</span><br><span class="line">    if (paths.size() &gt;&#x3D; 4 &amp;&amp; PATH_TREE.equals(paths.get(0)) &amp;&amp; PATH_DOCUMENT.equals(paths.get(2))) &#123;</span><br><span class="line">        return paths.get(3);</span><br><span class="line">    &#125;</span><br><span class="line">    throw new IllegalArgumentException(&quot;Invalid URI: &quot; + documentUri);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，此处得到docId为”image：3180”。image表示资源类型，3180表示资源id。</p>
<p>接下来，对文件的类型进行判断，是图片、音频还是视频，分别进入不同的媒体库，按照给出的文件id查询，即可得到真正的文件路径了。这个步骤在选择获取音视频资源时经常用，就不赘述了。</p>
<p>搞懂了流程，接下来就都很简单了。</p>
<h2 id="小米4-小米国际版文件管理"><a href="#小米4-小米国际版文件管理" class="headerlink" title="小米4 小米国际版文件管理"></a>小米4 小米国际版文件管理</h2><p>这一次按上面的方法走一遍后，很明显发现均不符合判断条件，结果也确实拿到的是null，所以这里我就自己补充一下小米机型的uri解析了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int length &#x3D; &quot;&#x2F;external_files&quot; .length();</span><br><span class="line">path &#x3D; Environment.getExternalStorageDirectory() + uri.getPath().substring(length, uri.getPath().length());</span><br></pre></td></tr></table></figure>
<p>这个方法很明显不适用与小米的所有机型，因为我安装的是国际版的文件管理。但是国内版的安装包我竟然找不到，太神奇了，等以后碰到了再说。</p>
<h2 id="华为-文件管理"><a href="#华为-文件管理" class="headerlink" title="华为 文件管理"></a>华为 文件管理</h2><p>这一类不必多说。返回的文件类型为file，用uri.getPath()方法即可获取到真实路径。</p>
<h2 id="一加7-氢OS-图库-与-华为-图库"><a href="#一加7-氢OS-图库-与-华为-图库" class="headerlink" title="一加7 氢OS 图库 与 华为 图库"></a>一加7 氢OS 图库 与 华为 图库</h2><p>这一类的不同首先在于authority为media类。不过这一类也简单，路径是包含资源id的，只要获取到资源id，然后去查询即可拿到相应的文件路径。</p>
<h2 id="一加7-氢OS-文件管理"><a href="#一加7-氢OS-文件管理" class="headerlink" title="一加7 氢OS 文件管理"></a>一加7 氢OS 文件管理</h2><p>这一次的uri，判断成功的是isExternalStorageDocument(uri)方法。这次的判断，有一个让我疑惑的地方，就是getPathSegments的打印内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document</span><br><span class="line">primary:AchievementApp&#x2F;avatar.jpg</span><br></pre></td></tr></table></figure>
<p>此处，size也为2，但很明显，后面的路径不再细分。</p>
<p>接下来，获取到docId为”primary:AchievementApp/avatar.jpg”。以”:”划分字符串，并在后字符串前添加外存储的路径，组成为文件的真实存在路径。</p>
<h2 id="一加7-Google-相册"><a href="#一加7-Google-相册" class="headerlink" title="一加7 Google 相册"></a>一加7 Google 相册</h2><p>我去查了下网上的解析Google相册的方法，凡是中文博客里，清一色的通过uri读取文件内容然后复制到某个目录下的。嗯，真的，服了。</p>
<p>我觉得不必如此。通过path内容和打印segments可以发现，里面其实已经包含了资源id了，取过来path看一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;-1&#x2F;1&#x2F;content:&#x2F;&#x2F;media&#x2F;external&#x2F;images&#x2F;media&#x2F;69009&#x2F;ORIGINAL&#x2F;NONE&#x2F;1306754059</span><br></pre></td></tr></table></figure>
<p>喏，是不是，打印的segments内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1</span><br><span class="line">1</span><br><span class="line">content:&#x2F;&#x2F;media&#x2F;external&#x2F;images&#x2F;media&#x2F;69009</span><br><span class="line">ORIGINAL</span><br><span class="line">NONE</span><br><span class="line">1306754059</span><br></pre></td></tr></table></figure>
<p>只要通过循环判断，取出第三个字符串，就可以作为一个新的uri内容了。接下来的处理，自不必我多说了吧。</p>
<h2 id="一加7-Google-Drive"><a href="#一加7-Google-Drive" class="headerlink" title="一加7 Google Drive"></a>一加7 Google Drive</h2><p>很奇怪，开始的时候我还能拿到文件的uri，但后来测试的过程中，即使挂着VPN也拿不到uri了。即使是拿着之前的uri，看到这个非Base64加密的字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ismNrKUOIBuKKajB8VwcvErY5tVOtHT3P1OhHzic9JbtEmErmSmRRw&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>
<p>算了算了，都加密了，就不管了。而且我看很少人讨论这个问题，就不过多涉及了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次最重要的是，文件uri解析的过程我完全弄懂了，即使以后碰到其他的文件管理软件，我也可以很快的做出解析了。最后贴出来最终完成版的文件解析方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FileUtil &#123;</span><br><span class="line"></span><br><span class="line">    public static String getFilePathByUri(Context context, Uri uri) &#123;</span><br><span class="line">        String path &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 以 file:&#x2F;&#x2F; 开头的</span><br><span class="line">        if (ContentResolver.SCHEME_FILE.equals(uri.getScheme())) &#123;</span><br><span class="line">            path &#x3D; uri.getPath();</span><br><span class="line">            return path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 以 content:&#x2F;&#x2F; 开头的，比如 content:&#x2F;&#x2F;media&#x2F;extenral&#x2F;images&#x2F;media&#x2F;17766</span><br><span class="line">        if (ContentResolver.SCHEME_CONTENT.equals(uri.getScheme()) &amp;&amp; Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            Cursor cursor &#x3D; context.getContentResolver().query(uri, new String[]&#123;MediaStore.Images.Media.DATA&#125;, null, null, null);</span><br><span class="line">            if (cursor !&#x3D; null) &#123;</span><br><span class="line">                if (cursor.moveToFirst()) &#123;</span><br><span class="line">                    int columnIndex &#x3D; cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);</span><br><span class="line">                    if (columnIndex &gt; -1) &#123;</span><br><span class="line">                        path &#x3D; cursor.getString(columnIndex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cursor.close();</span><br><span class="line">            &#125;</span><br><span class="line">            return path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 4.4及之后的 是以 content:&#x2F;&#x2F; 开头的，比如 content:&#x2F;&#x2F;com.android.providers.media.documents&#x2F;document&#x2F;image%3A235700</span><br><span class="line">        if (ContentResolver.SCHEME_CONTENT.equals(uri.getScheme()) &amp;&amp; Build.VERSION.SDK_INT &gt;&#x3D; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果是系统自带五种provider之一</span><br><span class="line">            if (DocumentsContract.isDocumentUri(context, uri)) &#123;</span><br><span class="line">                if (isExternalStorageDocument(uri)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; ExternalStorageProvider</span><br><span class="line">                    final String docId &#x3D; DocumentsContract.getDocumentId(uri);</span><br><span class="line">                    final String[] split &#x3D; docId.split(&quot;:&quot;);</span><br><span class="line">                    final String type &#x3D; split[0];</span><br><span class="line">                    if (&quot;primary&quot;.equalsIgnoreCase(type)) &#123;</span><br><span class="line">                        path &#x3D; Environment.getExternalStorageDirectory() + &quot;&#x2F;&quot; + split[1];</span><br><span class="line">                        return path;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (isDownloadsDocument(uri)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; DownloadsProvider</span><br><span class="line">                    final String id &#x3D; DocumentsContract.getDocumentId(uri);</span><br><span class="line">                    final Uri contentUri &#x3D; ContentUris.withAppendedId(Uri.parse(&quot;content:&#x2F;&#x2F;downloads&#x2F;public_downloads&quot;), Long.valueOf(id));</span><br><span class="line">                    path &#x3D; getDataColumn(context, contentUri, null, null);</span><br><span class="line">                    return path;</span><br><span class="line">                &#125; else if (isMediaDocument(uri)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; MediaProvider</span><br><span class="line">                    final String docId &#x3D; DocumentsContract.getDocumentId(uri);</span><br><span class="line">                    final String[] split &#x3D; docId.split(&quot;:&quot;);</span><br><span class="line">                    final String type &#x3D; split[0];</span><br><span class="line">                    Uri contentUri &#x3D; null;</span><br><span class="line">                    if (&quot;image&quot;.equals(type)) &#123;</span><br><span class="line">                        contentUri &#x3D; MediaStore.Images.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">                    &#125; else if (&quot;video&quot;.equals(type)) &#123;</span><br><span class="line">                        contentUri &#x3D; MediaStore.Video.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">                    &#125; else if (&quot;audio&quot;.equals(type)) &#123;</span><br><span class="line">                        contentUri &#x3D; MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">                    &#125;</span><br><span class="line">                    final String selection &#x3D; &quot;_id&#x3D;?&quot;;</span><br><span class="line">                    final String[] selectionArgs &#x3D; new String[]&#123;split[1]&#125;;</span><br><span class="line">                    path &#x3D; getDataColumn(context, contentUri, selection, selectionArgs);</span><br><span class="line">                    return path;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (isMiGlobalFileDocument(uri))&#123;</span><br><span class="line">                &#x2F;&#x2F;小米国际文件管理器</span><br><span class="line">                int length &#x3D; &quot;&#x2F;external_files&quot; .length();</span><br><span class="line">                path &#x3D; Environment.getExternalStorageDirectory() + uri.getPath().substring(length, uri.getPath().length());</span><br><span class="line">                return path;</span><br><span class="line">            &#125; else if (uri.getAuthority().equals(&quot;media&quot;))&#123;</span><br><span class="line">                path &#x3D; sortUri(context, uri);</span><br><span class="line">                return path;</span><br><span class="line">            &#125; else if (isGooglePhotosUri(uri))&#123;</span><br><span class="line">                &#x2F;&#x2F;Google相册图片</span><br><span class="line">                Uri contentUri &#x3D; null;</span><br><span class="line">                List&lt;String&gt; segments &#x3D; uri.getPathSegments();</span><br><span class="line">                for (String segment : segments)&#123;</span><br><span class="line">                    if (segment.contains(&quot;content&quot;))&#123;</span><br><span class="line">                        contentUri &#x3D; Uri.parse(segment);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (contentUri !&#x3D; null)&#123;</span><br><span class="line">                    path &#x3D; sortUri(context, contentUri);</span><br><span class="line">                &#125;</span><br><span class="line">                return path;</span><br><span class="line">            &#125; else if (isGoogleDriveUri(uri))&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String sortUri(Context context, Uri uri)&#123;</span><br><span class="line">        String path &#x3D; null;</span><br><span class="line">        String id &#x3D; uri.getLastPathSegment();</span><br><span class="line">        Uri contentUri &#x3D; null;</span><br><span class="line">        if (uri.getPath().contains(&quot;images&quot;))&#123;</span><br><span class="line">            contentUri &#x3D; MediaStore.Images.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">        &#125; else if (uri.getPath().contains(&quot;video&quot;))&#123;</span><br><span class="line">            contentUri &#x3D; MediaStore.Video.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">        &#125; else if (uri.getPath().contains(&quot;audio&quot;))&#123;</span><br><span class="line">            contentUri &#x3D; MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">        &#125;</span><br><span class="line">        if (contentUri !&#x3D; null)&#123;</span><br><span class="line">            path &#x3D; getDataColumn(context, contentUri, &quot;_id &#x3D; ?&quot;, new String[]&#123;id&#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;根据id查询文件(不限类)</span><br><span class="line">            Cursor cursor &#x3D; context.getContentResolver().query(uri, new String[]&#123;&quot;_data&quot;&#125;, &quot;_id &#x3D; ?&quot;, new String[]&#123;id&#125;, null, null);</span><br><span class="line">            if (cursor !&#x3D; null &amp;&amp; cursor.moveToFirst())&#123;</span><br><span class="line">                int index &#x3D; cursor.getColumnIndexOrThrow(&quot;_data&quot;);</span><br><span class="line">                path &#x3D; cursor.getString(index);</span><br><span class="line">            &#125;</span><br><span class="line">            cursor.close();</span><br><span class="line">        &#125;</span><br><span class="line">        return path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String getDataColumn(Context context, Uri uri, String selection, String[] selectionArgs) &#123;</span><br><span class="line">        Cursor cursor &#x3D; null;</span><br><span class="line">        final String column &#x3D; &quot;_data&quot;;</span><br><span class="line">        final String[] projection &#x3D; &#123;column&#125;;</span><br><span class="line">        try &#123;</span><br><span class="line">            cursor &#x3D; context.getContentResolver().query(uri, projection, selection, selectionArgs, null);</span><br><span class="line">            if (cursor !&#x3D; null &amp;&amp; cursor.moveToFirst()) &#123;</span><br><span class="line">                final int column_index &#x3D; cursor.getColumnIndexOrThrow(column);</span><br><span class="line">                return cursor.getString(column_index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (cursor !&#x3D; null)</span><br><span class="line">                cursor.close();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean isExternalStorageDocument(Uri uri) &#123;</span><br><span class="line">        return &quot;com.android.externalstorage.documents&quot;.equals(uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean isDownloadsDocument(Uri uri) &#123;</span><br><span class="line">        return &quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean isMediaDocument(Uri uri) &#123;</span><br><span class="line">        return &quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean isMiGlobalFileDocument(Uri uri)&#123;</span><br><span class="line">        return &quot;com.mi.android.globalFileexplorer.myprovider&quot;.equals(uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean isGooglePhotosUri(Uri uri)&#123;</span><br><span class="line">        return &quot;com.google.android.apps.photos.contentprovider&quot;.equals(uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean isGoogleDriveUri(Uri uri)&#123;</span><br><span class="line">        return &quot;com.google.android.apps.docs.storage&quot;.equals(uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
</search>
