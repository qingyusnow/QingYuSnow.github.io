<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2019总结</title>
    <url>/2019/12/31/2019%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉，密码不正确" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">这里有东西被加密了，需要输入密码才能查看</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="6f02671df3659638fe79d9220f7fadfd7b815d754793fe87fc6af3b047e92566">c8bd79c51856d12e53d92667dc5fb819d07cbdb6f2c01890f4d556babfd8b01e8f0e51354381ab984720c290a0bdb81a4b11dd721485ffd33c15bc9285b2303965c68bbd31127889af61ed3c659b1ec79653439e80cc8a4c6e8aae767b1c713e0a10ba41394ff8818478211ea9b044b14f68b64a4b25bc214934d9df8c09a5e95b9228061fc6927dff478ebee983699435fb9e93623efb4e68a3c200a748559fb02e90223b5dfeeb5c8465c74f0682ff8514c34c9d712440c58feb62ca502a93390dd84b1b953f953723c175709a138d44c3b73cff561e3a9a0d7ac57868c507b7d9eea4584ca6b31efbd3ac90e784924e3ec0131bc51052fc4c130c1ea4e007391dade6560d930bae1659aa7d7d419bd7a324b8185cd4db382551b741eb416835db1b8d716ea1e3835b724bbdd690dafe4765f5b2d2809422902d7be043fdb06382d4a3e5a302c5a7deb55d5e6f41293e7731c07111d4ecce5050326bc5e68f571ca9a9f47d83be4794074e4720caf0e3496f2c8fdfac612d79a8c2e32d85ada9aa0ed8d19310d5644a51fb051d2a5bc855052c7ddb797dbb15ea96e1c951e495b883239baeb53649a367be3ebe18e239802d7bce6e4008bf991645566b13ee049b0c0a3794a2dc6aca1345b6fe368635ecbea0570ba142840954fc11f5e78a0e276f6bc5fa066ff3a836df459a0a434fc399e2a8d96ae9141edfd3436defae52b31af92d1e101291ef2e57e1b8c5db414e4afd843559d5d19a55d61b4c19338c531180680d0de67425858660209477ae12125131caefd1a4109be8b704bf73ea9a45e75054747e135e9f50682bb97acc2fde974377f85d62f1a9dcb95dc77f43a2e47bb4d6e244aafc55fa5f6ee2ff49873914d5fa097aca593b1adea03228d62925d412d7de74784ca5c2ba548494f57cf95f85b984d48618d549fd81b6d6d9b475dbf2c562bb80f563546af1c1fd9a7ea88a0ebf353e1fb9986f62c646674a3e01d9beef9ba146eea6abb337eadd43e4de563999b7c09c4b519c680312206cd55662f79931fa175702e8f16afd2a179b70eb6b8494dfebdb775149dab7a97fa68296a8a567eb8ec0e0138efbb181b25526cd026a24e9c43a0d5598e7a01f6154924c4f174fe76f5b004fb6b28782d7d9cca6a5adb652c8a6d9920610cbe60c8f32971a9d02c20209bc632981515fe0fcd80595edd06b56476cafc05eb3d4fb4d46dae5b1872ba652beed74539cd1e538298ec90a0a497cee350d6af663d3ce966e1e84eebdfe039b0c2e652f55a9a19408ad990e5d450e07381623bae672bb92dc28af1ddd645b2448d1d986febb3c7827a308d8defd02737ebcc4c6deb8bf7c87cd6600582fa21fd39283cab0ffd7a4d663912bea1155e45095cc840c909d436e5d144380171f3fcb7484c52d034f78ee267166a0c8a8b79ab7be03eb0b09765bf161c372a8b774860ca02d4b705e64b5cbf4dea9e892478c98ae689edde6b76b03aad689afeaaa4c7d5a85fd75926232b9eb6866ecff778a84e250e1ab1b583274ed340c68d6109f4ac8349f995ff38434c8892d95c852e63f43ab55ab41193d9bf90054fa1d5e185a0e0c9d71ddaea96c60a9ec07e6a9dd8d54cfb6c67dbde59400a50fb81009777b50ffbc6581a30d774d4b05cbb1e143263227355d9cdd05bc96a1bc25ded4eb7ad4e760e598debf1e491d6262b5630e72fd2a11f6e6e3b7633e13e389a0c1c4e3160e2edfcf65a6ddb6be795d8fad813601d18c7420357cf79d760bab4d249e6f667fba7f1fe9c911c80b6f544156911119e0b3705d1862a053fc17b058039da2596566eb2e08461f71ed3bc97e9209c4a7dae5a575d278db6ab75ead991707c1be3435625d84b01bb1da9663ebf4d87b0bd4a051cd817e19aee7d5382d36c85b4e6a5f33daa984ddef1ca8874732c31ee714f456206b55bbb18a6aa1fb24b1248dc9d85b2772b85ce788cff088b87f8ffe78ac1ebf355044041153d5ec57f896152cffd79900bca99ac3338fcce89e31529db25c4c98c340de148408abf5f1945c6319901c56782e9aacec69e8c359425b560bc97389a77a8373fe083b91d9d831651b2198a014b94946264b9e866ee73de9f36871895cdf340a6cb4fde5a3ac14cdd3fe7a48c758f9315db4e01a3122e6a9d6908c997024c0c9bb78d50bdc24e47e82fa2420b7d97c3778aa87dd6b1579f140608d9ab1a270ec85e89e716df4a05a3f30dc82892563cc71aa140e5980e628e2649170880c6556ac2234b7fddba70fa3d513385cb6cf037554078885631dd6d74d3aad5fbc5161a9ed19773e076298e81ee9d3e145add3435fcdbfe1d30daec85fb7c36d320818eb3800afbd91c67407c78503904e31c03c99736352c6ff5baa2cbb7448ed6883361c781acba6836c5402746ba821b0168c25957bd52e7ea75c030b99e8111edfa03434b56092462cabf62a7204bb85fa4eb968dd9a338106aace22af5459b81f4de9f57b219ab4d4df7a88229041a85b8a7ba3665bc431fe68f54d897241d44b0000260d0ee0a3f5ea7952796fbd7e915afead5eb5bef37c463608f2c60d6fbc602c1140b3d676506e6fe5786e26ee41f6d5ae3756604ea829249768ebe15a511d3276622d078022824f4e924c97384ed4cf9ce20c6717c4cf4c1c22a6b7db53de86d6c1ad421a4c84c5d3ae3a64fdf7af893a017faa00bcc60d0b87edda02e9fe38ce04c3343e4d403775c98278b584e09c11f41f76ee64c05ea2fdd1bb0c6e74b9b09a6a4442578e9f02b887f72eea934844181649782adf69c5043ca57a9d9197b1ec5a7b3336f7652eb67796152a642d8d11102c6be51d41a0370a1a09ef37efd96213b741d05ecee9c70d292e4ed8af8c98cbe752b9a080bc66b7ef9cfdcf98e8b6dcfad226030517fb9a18a71e3f6d0f370f91fd9fb41000b97bcf6d2a18f42ab646f5d2d7a4e522a57dea40ecd3b621e70c74d7d16cd1eeef891b9d5d4b84de125a6752298c80f3f611fec19f1df06c10f0af246b43883651e733e1a082bbb19bba08c4b8d9c546ca40fa097d9caf9f6244973f15429fccf4c68ae581396eb0c3c51ba60649f1e8bb7aca70a6e7d0b16e723247f40ef140658b0d6a50e350fe3dd7f3a74c129f2d92516f17e86cd9a6ac65462f96494fa0fed09d458a35de9989d05f7541b3866d381446046371fe674089b382098c1f439622506f7f012b007b021e5d945c027a5ad4bc648d8cd0355557579675a7bc17d80f0ee7154ab3dd525237c08cc7df97103df7b68316f031a16d52e24cdc2110441f5110a379f42d9c9c73f47d98c7c8849c06975dd2eb3bda491f89a5ec72ef564f8fe4e6be0b3c9597ec3aad8667965970754257a80377554b1dee15236fa6a45612e90b093f7aabf7d641629ec2c14c6d63c178d2efd2242c8ec11786c710cd2da32b78ea68cc7c08d1e8282479aaa5255bccddef7123fd96d71b2d41d991a372027c9db2dae59cc3c07deccce83f6186bfb2f4c0a7402d8acc16b3bfb0eb94e7324213fef87ebba0fd5992fa657837d396aa03eb40e51f8f4a2e4210d3f2e05c39906debc7cbb21e4d0d11de444ea1b35f4f1becbcce854a351294589fd456ac391d69583d71945662e4697e0e012687874247427eb683c30d33830706d49d9f5a3ef173b018bf5644a89dca2d18024dbbacfcda07464dd3aca0950e6799968c15fe7479995dceee571fda7e92259dc68dae6f90fd27ca331c40111ff5b7446ca757b1b40b7a29abd7148573bf409d683a44d3bd403cc7467f64d2674e940094f73c5851304415c82b42fb693c7864a679b4a27f3c20c0fac07fdb78300b1986f7d2d2a1d6cf975382ce84ca61f3ad7a98f7e8523b3cc347e4ffefd3b783925daf17963bb5ead1f78d230403922233644da14319761e68b00ec72c26e40bb2eb7a20712f431aa69b80f77d7ee0022f160f076e5b77aa18155f9daca1fc35d91ab098020f70b73a32104664d9aff32c4c65017842825792ae7349776361026925425285f06ede183388c0969d177adeafb0b09173b412a17ac9f2f19a769790101e237810fb277bbe309311f38e90fb19908dc0a897e07bd14aba56bee6ae803d8310d3598f9a0418a62badd32a8bbc29c8829ab623b536ed1e5df1e00c2c38f12aa4ed7e05d1b765ce059b9937bf49c558af20e7ef83c07410cfd83102716e3d7c93b78e132c0f669f9164bc88de73be836a731d770a2c4a5cb658b02550b38faebf6cdbe5332b87f8d349c8da7cc29aaa932f5cb4ad81bd2070b9d07d9bf10f210ef9a2195b648ff94875ab88046a88bfda7a1a31acaa2ca71b69a51a61c3862a8933393db783f1e7cef721bcc9601beaf561cf858d03ef6e765c2be953f3c38848c923851209f7da3395147ff1daee6048c82b29a3f8b632bb437f38287c15637fde1ae4f8be9bc81a1901ff3ebb898b0f8c566aeec64ba99103522a250c6a7a890effe50de597c2e02e9188b530d845d9db782d5e3058a8cade9fb6cc18b2afeeaa0c3e8232c441f42ec046271ab4d13aaab099306453ba99244e93ccdde8dd139313c711e3daa61c4ae0f44f711be8cb1f3aa28dc15a27715b5f54969a88f12ed6c3862f452d4dcd862db7ac7d5817fd4fb966f76c0ac7555e0a28039a5cccb470fb591230cdc9026ec73e38b12e5a60666c13545ae3d967cd480956f4704433fdac17fe75e9ea5ef83b44315d28e20fa47eacd7c4bd82d274739aed48b6fceaa27e8c6d6807dacaf30d34ff3572c76afb8080ffaa24837f0273abe5bf69e5c01ce06c86d795c97f40158fc1b2ba532bc865b65754371c2e4de0c7e33bdae90a0a91dae7ea979f497fcd4595d5a72cd2726fd3bbc6eec744b5ca6f0d4665fa1d9dae00792cc68bf254c353a9d1cf5d360030ec237113175f5012bf5260ff55d3731c76944e756b4b0d46653213435ee82a7704e79d49b8f6752df17559ebb8620008b52175c629a556f42a55e98404f80cf3b0157f14b1050810f574e1b59a4f15365cb77be75f779ec09a91d0d2d4f9815d1ddaeb50ef0793ff34536ad95fe95f769d7d8ed89daf274960f2ba5678b4c4cbe222a069bd3b282e3190730d007b55c5904f3aaa37e8d9dbb9612d15f2099fafa450e015b5af0080d5f58ed1924470498f70143e5e081344e94d9d7b4ed9414642af61c9cc621e5aa8d9a9b7e828b96e1fc7019c1eb663fc435af4884cae6e83e79877f04c2b237d95766ada4aebe435c0744c3ef2eadc18060d0c04dd605d0232747606655821cb1e28d893b78639909ee0c842a55a27e4f36d9a1d21da3aa371163f6a2196708d8148ccb843814c2604e47e98c4c29cee728eda300f18e2d1cf5775da1b5fddddde9d0dce2cf153d510ae89371b601e009fd8e0012003179a146f45da8f7096a7e24a8eb05495178186850cf0ec4e1c1727a7afba502c750342a0ce7a8a0f590e4f83e7244c1bfc82bb7845a012162f23314ce01e53270534eb3cd5387e964693ca2e7a897a71abf26a67369a7d701cf0545d7caa23bbbca1dfad4b787316141e48a94daf7b92d7910df2667e0b8ba7e01a06940fd4e00b658bbc712e41234b056ca242520f7866be52c087eacb20f2bd95f1d8b6208b74cef706dc36d31cf8876bec5ef3bf00a18324dd7e91aa48d2145a3e7108d00be2a3c6549d91655e00bd1cc9a08e1e51ec5dc0741fc730e2f354c37d0acb3667322c0298f039423c3b0201a76fc3625c4053e80a2abad621cc74982ba376017b685c9b10e25d404aad0e1b1107bd7a8a1c471f08dca32c24d45b47dedf7904ca5985320b41f13552eddfab130166632467aa17eec825410988d09fef0151b341232c0d1817c4c8ecf452dc246eab08f217c399ea1f7ebf4d1e6956bbd2cc3991f21f528b81aa14dd8c4cb58b93fa054245b2afc1e6e7cfe6fc0b732d81ae896a841fe88c80e77dc2abf86bd7c4660eddc5c0be4d2ee7bff81226b0845fd6d267ae102aa16f3d22ffc1f2705d70f127474f729008e62c230b682a59279990eec75f774eb4b821c321dc06b6b3e259088fa63c30a8be18ea3d97f3740e05350f4179b7b7cbf0f284551876eef011b01e8596a524af9e08432fdd2e677fbc75728e9ea7802e9b49a1289fc47fb49dbb59a32a9ca144b15738bd1e6c07103bd381685a9841355dd090a2f01caab537f4d251da049094729a3fdb8a0176ba8ac13b8ce78907017fee832bb70be2b71b9cd1d6b9e3c83027a782c111e78794aa629ec56747f9d980824f9bd4ae41304a24da14cc446979a609a02a0f79159103a3583a5faf69616308587d08384343beb8d99748f5f6f713b2c7ea39bbe97ee237ac7a374dbeec459346a9b89bc37cb49696fce0b7a89fc5dd05e4e1a2c3910c54f87b2e7c443ee86bbb01f614310ed58f3e83d5c3aeca5e37fba43d798ebbc478701904e50587b4b229c75276585797836275ba36e2d97bf048cafc19d892e89b0adac98ea1d4d9a09929e92bc51abf6775432190456e76ff9c4dda4f62e4ce634c90dc60b3544e9d49c84052e71b42dfcddbe613c3f4e97be54e92b8341fe61c4c52e8ee0450c900d28e9167ff8c6cd0920de9de8c4853393fc40bab23d020567d0f0c4188a02544d4ac34ec53281ccaaf3ef71945db41c14a2540d812d2432dbfdabf473d6d09373bc66603a45bed02aa420255196e2925f557a29d7b4502ccaab8f2785dee66c6271fbc188bc12f11133200420f7d43f0edb2243c2bc1679ad700d3f0ed065fce20e647fe92912d7e44338735d4ca9c73542a2e1fb82630c12128037af0eabf04363849b16a8aa8c0af4077d5a6b0a5978f73ba0ad63f5bc1c85f07d903af11f56a270b112eb57def6f17adc92c45787d2e61f847f038713522c4ca38004038faaf122ee590206bb0ba3524ef3dc0f79055d767d78c5db5667208961d5afc2d1a2fe7311ca130ab65dd4960d1fe8d6643c7f60463b466a36eddeb539d734cf1914c5bf37e4ae7ae84edb3ce9e25102e5d34016e3617817de07920bd14e701f21b2dc64feb11876ccfa2804077c98f45c3a3729a2665c4ac0e7ba1a79172d3a7c2250bb9508b763fb8700aff2363ab9c240b5f16fe4f5268dd896f071952256b502ace69cc0a535a77cc4b0db6c0d94babd5a9ef83f6ab512a99eb4215e4c0e5aeb4e02a1085f1138d40f9f67aa9ef36cf61cd1cc80a0787b710b86b1ece68f3ac6b1a747a502495fe5ea43c5fbe659aec59fbacee6167494176071fa308ff23ecab1fdf30ddc39f895ff75e51962d1e7ccff35a1ae651df4d396302d129358743d415f8ece12012aa64cfa29b51f216f8202cf9b2f4d710909920858604255af38b64bcd68ddd70663f6db581cb82f152f3c94ddcb538840a08c64a76fab43cdc793f3f714c4d051c3a1e70c96fd98e625c0f5d2a28f6fd753017d25b3cab179c5d651719bc3ab8a1cc1652c282dd8c7e91af4b13fb2b7cb1cbd6e99c96a4e7f48eaad9f6ab36e337d29739a0d6a8a0f63eb8e053b05040b007607af0ef789a22c7ff65003da4e607ac2552aadb07d6954eaa6aca84708644768bf010c698f87c5ecda5c35a095e20ad3a590b9fb166af7e9c03d0b94fa5e6c41d1e37b536ce24a2aae2dfdef65c8cfbb95187b6bcf10011f5e02a1bc660563980968188a09d564805c630b268abd99c263c6fe0279044a8a175283afb8d30039fad8af635a2f5eea635383ab27611928d7e8c2fa50f1ffc4d3a587c5b84f6df11df854986a3d4003c060e0cd8dff8b364844b581dd1bcfee956d151cee33a5b61a6c528dce028d2dd84629341f98a168d61544e1540eedf4a941c7e96d699b37b8ea0284bd4a09f45e2bf4179ee9f064ab9cda1c826a62291de91010707c70913f855925069e8f98aae28a742d2d975eddb8fe95067775dd35caf5cc38fe45cc3b035bcfc06e09e91ec4ecc3041d51d6b3290b92925578886a4457cb52598e7f3301656158ddbd629bc3feede86f679d6832694ec4f93fcbeacbee6fdac5308319eabe938fca2fc2cab57db2734910cc899b8634955c1d5d7dce169676773f612b2d12a142e53eff51ff108103bc00190f95e4f1b11da456803239724f6064a2a963f97cae0c9df356b05194901430dc7a5a5adc6edb145050fadb8b3badc65215b1452fe2813377c0a93b2212ff8d835f921b62d2e293beee3dc389949809cc24438eef9126844f2bd47c2394e0e1b4501373aa41051a9ed99e35f8aeb26d838bca2ffba09931bca63086190f29e4ddaa3b907c2c93391c530715327c7081bfec72f80903ef49166b421a6a1c9413e8b3e39a672ebf7abf7b23c9aa44b6a1b71be16e14986320fd849590533afab9136eeaee6aa1d0bc03062bbf1b297ae49e768da7b65b04dd9a81a962c4bcd49dba31aa9e866d088a963edd313a62e203664b5934f97f9b0f115b9e4f55c8519be4d5b9524b9a465644adc7cbc27d3699599eca274fc3eb45439170dc8c169553c387c7c54337c063c1cbd00b18471fe3ea145028c19d206efd797347e5deed0b6425f9c01a47c85ef57d489f45219e51383e1c28ca7400f56b8702a57c1c6eed8ee98d1bc02cad517dc9e50fa63e0bd3547783d3220b042349050a7cd6a832ae4b609846a396c6d0702961ee5a3dc4d6eb4c21a61f568b0a863d79234aa2e90609dd76d73453c7570d4773a03048a3b8f626a90913b20d020fea137359dd3e7b7cb539e626afe3ab002a168f702ea319c7f5a82e684ff086566eeb9f5f6d77161cdfce2f366b77d1d20678fa69af3ced734993710d7fddf9492ec80cb27ecccc085ce60ee5105fcde808a7296ec31336e8558d628af344cb04af48545712ad659bd56344443d828a53f14823ce348db2311c139a53f30d3e9c50101a59107c72cda5049c8a394be1ba530a85ca14b2d61a018e1e7123e6834ad6454f27101c22a97a1ab5a680607c12d00a1a93ee308e276506e87570e9675bff77b6097a8836a464c1296f378f82ad5e893bf2bb0cbd7d1412f90f97561e589a150dfbb81f57b442a564fe7265745416f505b38cd123415b825b34d1cd7e7ec60756dfc8d3fcdad483138047e9053256bd454e4b3b1793c2c6a5af8c71e01749d6fd8de7d02484838b12faebaeaf66e90bb5f79e1a5756661093fb2a41440d52846bc3db7765939636432831836db42b714bd543c6c659437cc336132d60be617fc775e0c770373760010e4e67d87c2da65eec6bc3c39b5db55e181d59779ee1a6572c914dd7f24ca9683e7654fbdc0219c22d5eda66c0cb15268341948a2f03aeefda79eeefe2fd3c41894667afb056a760ce9b7468c74d8b09fd96966847f6d3ece3edb6a0220033facd2b7a9e2eca23e3a3220b27b69c78bcfdebc96bf3aa3f56cf848ae70d1deab65bbc645aeacf2037bb2c69aaf4d5b73672edc1b65b46450a78fd800341c1be6675e73d55ca49915d5e65725ebbf3c6878196bea85340aeee30b167d2c43df7bf7d6e6c461a57b0c93f391b3fd126138642b8ad671dbfb3c22ab0f46b88ffbe9890210eff6d86f683dd9f448405da6e24c2065d91f350237ab51f475e954841ec51b95abc145e218c4712d4ff710a639e3bb77495598373a4ec788cf0f4c8d7af7792d74e1216fbed269d87ace9162b2fc37ba6ba37b04fdb10cc3bea0833fb41f4b3c17ae679b26f7ae71a8e9b213e33ab3f1eaf05207c96d4bffe714d4d126d1898cf292a28fe22b02014c8854e065082a633162049e3ac7873382588d1902a32d13209d5d2a832a2b5c56607a6d4bfb8e20183e647fc92ca169066870a9e546eee7137b5dd7879850543d2d68149d5a30c8f825ed1175de242884140e097849214357aa358314c1dc130516b90e42b6cf46f8f75e5280f038804cb648732b545025c6e6c720e5ee27ed2d4327ed45aa1db5672b85755ab6068ce5371ab085499ddd63b7ae91206d9d23ef559fc6b56d1afb75ec1167c4ff5a69c11607e78cfcf6b7d733988c2253579863c4f4ad8382a8799efe0ad0a38c35ce61703c83270626e98634357b7330</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Book</category>
      </categories>
  </entry>
  <entry>
    <title>二载成就杂谈</title>
    <url>/2020/12/20/2020%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>我活的太过随心所欲，生活便迷失了方向。</p>
<p>我活的又太过急于求成，乐趣便也被剥夺了。</p>
<a id="more"></a>
<h1 id="写在最前面的"><a href="#写在最前面的" class="headerlink" title="写在最前面的"></a>写在最前面的</h1><p>原本标题为“2020总结”，但这些话翻来覆去，感觉完全没有生活的气息，委实算不得年度总结，却像是一篇针对自己纠正方向的分析报告。没有对过去的怀念，没有对未来的展望；没有对好友说些什么祝福的话语，也没对自己提些什么批评的建议。很庆幸在年底发布前一天发现了这一点，希望不会披着“年度总结”这样的幌子使得读者读完全篇才发现被欺骗了。故综上，先给读者打一剂预防针。<strong>这不是一张祝福清单，也不是一篇年度总结</strong>，只是一份不太有趣的报告罢了。</p>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>在前一两个月，我偶然发现了Aeon Timeline这款软件。它完美实现了我的预期效果：能以时间线的方式标注出一件事件的完成跨度，以此方便记录与观察我的行事轨迹。</p>
<h2 id="为什么要记录"><a href="#为什么要记录" class="headerlink" title="为什么要记录"></a>为什么要记录</h2><p>我想通过完成这些事情来给自己一些成就感，以填补一些空虚感。</p>
<h2 id="记录什么样的事情"><a href="#记录什么样的事情" class="headerlink" title="记录什么样的事情"></a>记录什么样的事情</h2><p>2018 年末有这个想法的时候，第一个想到的就是游戏。其次便是受身边朋友的感染，觉得自己胸无点墨，款学寡闻，几乎从不去读书，也不去看番和电影，感觉自己活在一个别的世界。</p>
<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>借助 Aeon Timeline，我将这两年记录下来的事件做了两张表：</p>
<blockquote>
<p>建议在PC端右键点击图片，在新标签页中查看</p>
</blockquote>
<p><img src="/2020/12/20/2020%E6%80%BB%E7%BB%93/2019-横版.png" alt></p>
<p><img src="/2020/12/20/2020%E6%80%BB%E7%BB%93/2020-横版.png" alt></p>
<h2 id="2019年"><a href="#2019年" class="headerlink" title="2019年"></a>2019年</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类别</th>
<th style="text-align:center">实际完成数量</th>
<th style="text-align:center">计划目标数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">游戏</td>
<td style="text-align:center">14</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:center">阅读</td>
<td style="text-align:center">15</td>
<td style="text-align:center">20</td>
</tr>
<tr>
<td style="text-align:center">影视</td>
<td style="text-align:center">15</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:center">项目</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
</div>
<h2 id="2020年"><a href="#2020年" class="headerlink" title="2020年"></a>2020年</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类别</th>
<th style="text-align:center">实际完成数量</th>
<th style="text-align:center">计划目标数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">游戏</td>
<td style="text-align:center">11</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">阅读</td>
<td style="text-align:center">9</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">影视</td>
<td style="text-align:center">14</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">项目</td>
<td style="text-align:center">0</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
</div>
<h1 id="分析与感受"><a href="#分析与感受" class="headerlink" title="分析与感受"></a>分析与感受</h1><p>结合图表与实际体验，这两年间存在以下问题：</p>
<blockquote>
<ul>
<li><strong>目标数量不明确</strong>，未在年初立下过具体目标</li>
<li><strong>存在空档时期</strong>，可能是迷茫无目标或有任务中途弃坑</li>
<li><strong>事件在时间上的跨度重合变高</strong>，说明专注度和耐心存在问题</li>
</ul>
</blockquote>
<p>此外还有一个问题：那就是每一类记录的<strong>事件的标准线</strong>。其实两年以来一直模糊不定，借此对事件做一些明确的定义：</p>
<h2 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h2><blockquote>
<ul>
<li>初玩的<strong>单机游戏</strong>为主，网游和已玩过的游戏不记录在内</li>
<li>完成度：至少要求<strong>主线通关</strong>。</li>
</ul>
</blockquote>
<p>我也曾玩了DOTA2、黑魂2（完成度大概2/3）、刺客信条奥德赛、死亡细胞、上古卷轴5等等，但未达条件其一</p>
<h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><p>我阅读资历尚浅，还在摸索阶段，从这两年的书单可以看得出很杂，且要求并不高</p>
<blockquote>
<ul>
<li><strong>已出版</strong>的著作</li>
<li><strong>已完结</strong>的网文。借出版社之手，可以帮我筛选掉很多质量不过关的小说</li>
</ul>
</blockquote>
<h2 id="影视"><a href="#影视" class="headerlink" title="影视"></a>影视</h2><p>这是我之前定义最模糊的一个分类</p>
<blockquote>
<ul>
<li><strong>口碑</strong>要好</li>
<li>已完结或即将完结的<strong>二次元番剧</strong></li>
<li>非院线的<strong>电影</strong>。我看电影太太太太太少了，因此要求也很低；去影院看的电影不计在内</li>
<li>非国产连续电视剧。主要还是现在的国产剧大部分又臭又长，看的也不爽，时间也浪费了</li>
</ul>
</blockquote>
<p>总体感受上20年比19年要差一些</p>
<blockquote>
<ul>
<li>游戏：20年玩的游戏比19年玩的游戏要好一些，得益于新主机的添置与宫崎英高。<strong>最值得的事情是大致玩了魂系列三部曲以及只狼</strong></li>
<li>阅读：20年试图跳脱于东野圭吾单个作者，尝试向其他方向扩展，但似乎不太成功，而且很惭愧，9月份之后再也没读过书了。<strong>最值得的事情是第一次阅读完了一本名著——《围城》，挑战了自己的耐性</strong></li>
<li>影视：20年比起19年差了很多，二次元番剧看的极少，总感觉今年缺失了一些什么。<strong>最值得的事情是补了《青春猪头不会梦到兔女郎学姐》这部番</strong></li>
</ul>
</blockquote>
<h1 id="思考与改变"><a href="#思考与改变" class="headerlink" title="思考与改变"></a>思考与改变</h1><p>在第二年，我“如期”体验到了预想中的得与失。得，为了完成目标数量，我努力地去寻找、体验、完成很多事情；但同时，为了数量，我需要尽快完成，但有时这会意味着冲突，我的体验开始被一点点破坏掉了。这使得它在一定程度上从美好变成了阻碍。这是一件很悲哀的事情，但也需要我努力去感受、去跳脱的事情。我不知道该怎么去概括，大概就是<strong>已知结果美好时依旧努力，已知结果糟糕时依旧享受</strong>吧。</p>
<p>返回来说些在意的，那就是时长方面。</p>
<p>比如电影，一般是2小时；而一部番剧，通常为 12 集，即 6 小时；再长一点的民工番，如《犬夜叉》共 178 集，我在 8 月份的时候是很想补一下这部没看过的番，但看了 30 集后觉得花费时间真的太长了，就弃坑不计了，这是件很可惜的事。</p>
<p>再比如阅读，说起这个我就很羡慕别人读书的速度，半天或者几天就能很快看完一本书。而我的话短则两天，长则如围城花费时间将近一个月，一方面是围城长，一方面是开始阅读没几天后沉迷旷野之息便被搁置了。</p>
<p>而游戏，短如 Gorogoa，全成就也就 4 个小时；长如旷野之息，一周目时长为200多小时，双周目加起来为 330 多小时。</p>
<p>所以我在想，要不要在某些计量上做出一些改变。</p>
<h2 id="游戏-1"><a href="#游戏-1" class="headerlink" title="游戏"></a>游戏</h2><p>我想对游戏的标准作出一些改变，因为此时我的需求已不再是单单去扩展视野，多了解新游戏了。作为一名成就党，有一些游戏没有得到全成就让我有些遗憾；而有一些游戏我更想去突破自己的极限。这些意味着要付出更多的时间，而它们却无法记录在表内，比如：</p>
<p>黑魂3：我只记录了通关一周目的一个月；我没记录在 20 年初的一个月又用了 50 个小时打了黑魂 3 两个周目以及全成就</p>
<p><img src="/2020/12/20/2020%E6%80%BB%E7%BB%93/DarkSouls-1.jpg" alt></p>
<p><img src="/2020/12/20/2020%E6%80%BB%E7%BB%93/DarkSouls.jpg" alt></p>
<center style="font-size:15px;color:#C0C0C0">附一张最喜欢的防火女</center>

<p>鬼泣5：我只记录了 DH 难度通关的一周；我没记录我后面一个月在打 DH 的全 S 评价以及其他难度的评价（哎，果然是我太菜了）</p>
<p><img src="/2020/12/20/2020%E6%80%BB%E7%BB%93/DMC5-1.jpg" alt></p>
<p><img src="/2020/12/20/2020%E6%80%BB%E7%BB%93/DMC5-2.jpg" alt></p>
<p>DOTA2：从接触 DOTA2，被疯狂人机血虐，到现在基本可以正常对线疯狂人机</p>
<p><img src="/2020/12/20/2020%E6%80%BB%E7%BB%93/DOTA2.jpg" alt></p>
<p>现在我有一些想要额外去实现的目标<del><strong>（也可能会成为主目标）</strong></del>（部分可点击跳到学习链接）。我也不知道以自己的实力去做这些事情会花费多少时间。我把这些目标按我自认为的难度从难到易排列如下，除<strong>第一个极有可能是永久目标</strong>：</p>
<blockquote>
<ul>
<li><a href="https://www.bilibili.com/video/BV1b54y197tY">蔚蓝 全金草莓</a> （C 面短但容错率极低，B 面又长又难，还有最不想提及的第 9 关）</li>
<li><a href="https://www.bilibili.com/video/BV1Bb411E7zy">鬼泣5 DMD 全 S</a> （DMD 都还做不到通关）</li>
<li><a href="https://www.bilibili.com/video/BV1S4411Q7x4">武士刀零 速通成就</a></li>
<li>只狼 全成就</li>
<li>奥日与萤火意志 全成就</li>
<li>旷野之息 大师模式 （主线通关，已于本月完成）</li>
</ul>
</blockquote>
<p>前两件事情，是我不太认为自己能完成的事情。如果这些事情能做到的话，或许我就能在心理上突破自己的信心极限；但如果没能做到，我也难免会有觉得自己已经到此为止的心情。</p>
<p>我想在 B 站发布视频记录下完成第一件事情的过程<del>（因为它很难）</del>，其他的暂不考虑。<strong>如果</strong>完成度达到了我的满意度，我会在这里更个链接。但愿我能按时，甚至提前在明年年底前完成这个目标。</p>
<h2 id="阅读-1"><a href="#阅读-1" class="headerlink" title="阅读"></a>阅读</h2><p>这方面，我认为还是提前定下读哪些书比较好，这样就省去了寻找的时间。这其中有些书纯粹是当下时事使然，让我觉得应该去拜读一下，比如《史记》与《血疫：埃博拉的故事》。我按阅读的欲望和分类的不同将阅读顺序打乱，以免增加疲倦感。<strong>如果</strong>年末能读完这些书，就再去找两本凑个 12，但我感觉<strong>这些对我来说够多了</strong>。</p>
<blockquote>
<ul>
<li>《平均分》</li>
<li>《基督山伯爵》</li>
<li>《史记》</li>
<li>《血疫：埃博拉的故事》</li>
<li>《呼啸山庄》</li>
<li>《任天堂·征服全球史》</li>
<li>《活着》</li>
<li>《小王子》</li>
<li>《我与地坛》</li>
<li>《岩田先生》 （明年夏天待出版）</li>
</ul>
</blockquote>
<h2 id="影视-1"><a href="#影视-1" class="headerlink" title="影视"></a>影视</h2><p>这东西总是很难说，基本靠朋友的推荐，我自己发现的往往比较少。</p>
<p>我最喜欢的三部短番，是《紫罗兰永恒花园》《来自多彩世界的明天》《青春猪头不会梦到兔女郎学姐》。我想，这或许可以定义一下我喜欢的番。</p>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>20年基本没什么想做项目的想法以及欲望，想了一下，不如在新的一年花点时间和功夫在丰富博客上，一个月至少一篇，这样也算有所收获。</p>
<h1 id="一些题外话"><a href="#一些题外话" class="headerlink" title="一些题外话"></a>一些题外话</h1><p>其实，在定下这些目标后，还是有些惴惴不安的。因为我在一个不该任性的年纪，还在一如既往地任性。不过，生活的圈子总会告诉我风向的，只不过，我总是走在队伍的尾巴里罢了。</p>
<p>还有的话，就是这一年成就虽少，却身心俱疲。总是在一个目标还没完成的时候就跳到下一个目标去了。希望来年能合理安排。</p>
<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><p>先定下所有目标，而后去完成，这是刺客信条·奥德赛。这个游戏我只玩了不到 30 个小时。</p>
<p>沿途发现并完成目标，这是塞尔达传说·旷野之息。这个游戏我玩了 300 多个小时。</p>
<p>我突然想起《良医》里的一句话：Everything’s a game.Just sometimes the stakes are higher.</p>
<p>新的一年到了，这次早一点出发吧。</p>
]]></content>
      <categories>
        <category>Book</category>
      </categories>
  </entry>
  <entry>
    <title>Activity的生命周期</title>
    <url>/2020/06/15/Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p><a href="https://developer.android.google.cn/guide/components/activities/activity-lifecycle">Activity生命周期</a></p>
<p>了解Activity的生命周期，在一定程度上，对修正或完善代码内 <strong>各种情况下</strong> <em>业务的执行顺序与发生时机</em> ，会有很大的帮助。</p>
<a id="more"></a>
<h1 id="先行知识"><a href="#先行知识" class="headerlink" title="先行知识"></a>先行知识</h1><p><img src="/2020/06/15/Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/activity_lifecycle.png" alt="Android开发官网的生命周期图例"></p>
<h2 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate"></a>onCreate</h2><p>在创建activity时触发，生命周期中第一个调用的方法，在整个生命周期内也只应发生一次（存在打破此规则的可行性操作）。<strong>此时还在后台，对用户不可见</strong>。</p>
<p>在这一步，应该初始化布局资源，绑定数据，还有所有静态资源。要注意此时视图还在构建，是无法调用布局动画以及获取或设置布局的长宽及位置信息的。</p>
<h2 id="onStart"><a href="#onStart" class="headerlink" title="onStart"></a>onStart</h2><p>activity进入“已启动”状态。对于这个阶段的描述，各博客的说法不一。我的理解为，<strong>此时对用户可见，但不处于前台，无法与用户进行交互</strong>。这个阶段很短，大概像是activity的整个界面在初现到完整展现中的过渡阶段，这个阶段的确符合“可见，不处于前台，无法交互”三个要素。</p>
<p>在这一步，可以尝试检测一些必要条件，比如检查一些权限等。</p>
<h2 id="onResume"><a href="#onResume" class="headerlink" title="onResume"></a>onResume</h2><p>调用此方法后，activity可与用户进行交互。<strong>此时位于前台，对用户可见，且可进行交互</strong>。</p>
<p>在这一步，初始化一些“独占设备”（比如相机、录音机等）的相关设置。</p>
<h2 id="onPause"><a href="#onPause" class="headerlink" title="onPause"></a>onPause</h2><p>activity失去焦点，并进入“已暂停”状态。<strong>此时尚且位于前台，对用户可见，但已不可进行交互</strong>。一般来说，如果当前方法在500ms内未执行完毕，会强制关闭当前activity。</p>
<p>此时，考虑到<strong>各种情况</strong>，调用的下一个方法会是onResume或onStop；当然，杀进程这种特别少见的情况也是有可能存在的。这里的<strong>各种情况</strong>，会在下面尝试通过操作实现。</p>
<p>在这一步，只能释放一些必要资源，以防下一个activity会用到，比如上文刚提过的“独占设备”资源。考虑到onPause有默认限时，这一步最好不要做很多操作，以防业务提前中断，造成崩溃或数据丢失等。</p>
<h2 id="onStop"><a href="#onStop" class="headerlink" title="onStop"></a>onStop</h2><p>activity已停止。<strong>此时已位于后台，对用户不可见</strong>。但此时activity还存在于内存中，尚未被销毁。</p>
<p>在这一步，可以着重做很多资源的回收工作。阿里巴巴的Android规范手册要求，尽量不要在onDestroy中释放资源，因为onDestroy的执行时机可能较晚。所以，一些线程资源的释放，数据的保存，都可以在这一步做。</p>
<h2 id="onDestroy"><a href="#onDestroy" class="headerlink" title="onDestroy"></a>onDestroy</h2><p>activity被销毁。<strong>此时对用户不可见</strong>。</p>
<p>在这一步，释放其他未释放的资源，特别是onCreate中初始化的静态资源等。</p>
<h2 id="onRestart"><a href="#onRestart" class="headerlink" title="onRestart"></a>onRestart</h2><p>处于“已停止”状态即将重启时，会调用此方法。此回调后面总跟着onStart。</p>
<h1 id="状态变更"><a href="#状态变更" class="headerlink" title="状态变更"></a>状态变更</h1><p>在使用应用的过程中，用户总会做出些令人意想不到的预料外的操作，这样一来，就需要了解一下状态变更的详情，以便开发者整理出一套趋于完美的业务逻辑。</p>
<p>以下是我所能设想到的所有操作。这其中有两种操作，属于配置更改。这类操作会重新创建activity。</p>
<h2 id="activity的切换"><a href="#activity的切换" class="headerlink" title="activity的切换"></a>activity的切换</h2><h3 id="activity-A-启动-activity-B"><a href="#activity-A-启动-activity-B" class="headerlink" title="activity A 启动 activity B"></a>activity A 启动 activity B</h3><p>onPause()(A) -&gt; onCreate()(B) -&gt; onStart()(B) -&gt; onResume()(B) -&gt; onStop()(A) -&gt; onSaveInstanceState()(A)</p>
<h3 id="activity-B-返回-activity-A"><a href="#activity-B-返回-activity-A" class="headerlink" title="activity B 返回 activity A"></a>activity B 返回 activity A</h3><p>onPause()(B) -&gt; onRestart()(A) -&gt; onStart()(A) -&gt; onResume()(A) -&gt; onStop()(B) -&gt; onDestroy()(B)</p>
<h2 id="息亮屏"><a href="#息亮屏" class="headerlink" title="息亮屏"></a>息亮屏</h2><h3 id="息屏"><a href="#息屏" class="headerlink" title="息屏"></a>息屏</h3><p>onPause() -&gt; onStop() -&gt; onSaveInstanceState()</p>
<h3 id="亮屏"><a href="#亮屏" class="headerlink" title="亮屏"></a>亮屏</h3><p>onRestart() -&gt; onStart() -&gt; onResume()</p>
<h2 id="来电"><a href="#来电" class="headerlink" title="来电"></a>来电</h2><p>一般来说，现在的手机系统很少会有不经用户允许直接切换至电话接听界面的操作了。相对以往来说，这里的操作其实也无特别之处了。</p>
<h3 id="切换至接听界面"><a href="#切换至接听界面" class="headerlink" title="切换至接听界面"></a>切换至接听界面</h3><p>onPause() -&gt; onStop() -&gt; onSaveInstanceState()</p>
<h3 id="拒绝来电"><a href="#拒绝来电" class="headerlink" title="拒绝来电"></a>拒绝来电</h3><p>onRestart() -&gt; onStart() -&gt; onResume()</p>
<h2 id="横竖屏切换（第一类配置更改操作）"><a href="#横竖屏切换（第一类配置更改操作）" class="headerlink" title="横竖屏切换（第一类配置更改操作）"></a>横竖屏切换（第一类配置更改操作）</h2><p>onPause() -&gt; onStop() -&gt; onSaveInstanceState() -&gt; onDestroy() -&gt; onCreate() -&gt; onStart() -&gt; onRestoreInstanceState() -&gt; onResume()</p>
<h2 id="窗口模式"><a href="#窗口模式" class="headerlink" title="窗口模式"></a>窗口模式</h2><h3 id="按下任务键，应用变为窗口"><a href="#按下任务键，应用变为窗口" class="headerlink" title="按下任务键，应用变为窗口"></a>按下任务键，应用变为窗口</h3><p>onPause() -&gt; onStop() -&gt; onSaveInstanceState()</p>
<h3 id="选中窗口，应用变为全屏"><a href="#选中窗口，应用变为全屏" class="headerlink" title="选中窗口，应用变为全屏"></a>选中窗口，应用变为全屏</h3><p>onRestart() -&gt; onStart() -&gt; onResume()</p>
<h3 id="切换至多窗口（即分屏）模式（第二类配置更改操作）"><a href="#切换至多窗口（即分屏）模式（第二类配置更改操作）" class="headerlink" title="切换至多窗口（即分屏）模式（第二类配置更改操作）"></a>切换至多窗口（即分屏）模式（第二类配置更改操作）</h3><p>onDestroy() -&gt; onCreate() -&gt; onStart() -&gt; onRestoreInstanceState() -&gt; onResume() -&gt; onPause()</p>
<p>这让我发现了一个有趣的东西。在切换至分屏且未添加第二个分屏应用时，主activity的生命周期会运行至onPause()。此时若是点击应用，会发现应用不响应点击事件，似是获取不到用户输入，即失去焦点。</p>
<p><strong>添加第二个分屏应用之后，测试应用调用 onResume()</strong>，此时可以响应点击事件。</p>
<p>接下来可有两种操作。</p>
<h4 id="1、将测试应用拉至全屏"><a href="#1、将测试应用拉至全屏" class="headerlink" title="1、将测试应用拉至全屏"></a>1、将测试应用拉至全屏</h4><p>onPause() -&gt; onStop() -&gt; onSaveInstanceState() -&gt; onDestroy() -&gt; onCreate() -&gt; onStart() -&gt; onRestoreInstanceState() -&gt; onResume()</p>
<h4 id="2-1、将另一个分屏应用拉至全屏"><a href="#2-1、将另一个分屏应用拉至全屏" class="headerlink" title="2-1、将另一个分屏应用拉至全屏"></a>2-1、将另一个分屏应用拉至全屏</h4><p>onPause() -&gt; onStop() -&gt; onSaveInstanceState()</p>
<h4 id="2-2、再切换至测试应用"><a href="#2-2、再切换至测试应用" class="headerlink" title="2-2、再切换至测试应用"></a>2-2、再切换至测试应用</h4><p>onDestroy() -&gt; onCreate() -&gt; onStart() -&gt; onRestoreInstanceState() -&gt; onResume()</p>
<h1 id="本章相关知识点"><a href="#本章相关知识点" class="headerlink" title="本章相关知识点"></a>本章相关知识点</h1><blockquote>
<ul>
<li><a href="https://developer.android.google.cn/topic/libraries/architecture/saving-states">保存界面状态</a></li>
<li><a href="https://developer.android.google.cn/guide/topics/ui/multi-window">多窗口支持</a></li>
<li><a href="https://developer.android.google.cn/topic/libraries/architecture/lifecycle">生命周期感知能力的组件</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android时钟动画实现</title>
    <url>/2018/11/21/Android%E6%97%B6%E9%92%9F%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>依自己的使用来看，小米手机的自身很多应用在动画处理和界面处理上都很圆滑舒服，所以估计在未来一段时间内，我都会以小米应用作为模仿练手的目标，这次就先模仿实现一下小米时钟的动画。小米时钟有很多动画，我暂时只完成了一个界面，而且还不完善，所以还会持续改进。</p>
<a id="more"></a>
<p>先放上我已经实现的效果图<del>(录制采用的是免费版的icecream，功能很不错，就是水印有点大）</del>。</p>
<p><img src="/2018/11/21/Android%E6%97%B6%E9%92%9F%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/1.gif" alt></p>
<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>这个动画中需要绘制的一共有6个部分：中心环，时针，分针，秒针，内环，外环刻度盘，如下图：</p>
<p><img src="/2018/11/21/Android%E6%97%B6%E9%92%9F%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/2.jpg" alt></p>
<p>在这6个部分中，中心环、内环属于静态，一经绘制便不需要再作处理；时针、分针、秒针和外环刻度盘则是属于时时刻刻都在运动的部分，是需要重点处理的部分。</p>
<h1 id="代码实现部分"><a href="#代码实现部分" class="headerlink" title="代码实现部分"></a>代码实现部分</h1><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>既然是要绘制时钟，就一定需要获取到时间。时间的精度一定要高，要以毫秒为单位，这样才能使动画的变化更加圆滑一些，而不是一秒一跳那样的动画。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获取当前总时间（超出1970年1月1日的时间）</span><br><span class="line">long time &#x3D; System.currentTimeMilllis();</span><br><span class="line">&#x2F;&#x2F;获取当前时间（超出当天0点的时间）</span><br><span class="line">long overtime;</span><br><span class="line">&#x2F;&#x2F;获取当前系统时间</span><br><span class="line">SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">&#x2F;&#x2F;除以1000，得到的会是以秒为单位的时间；不除，则以毫秒为单位</span><br><span class="line">try &#123;</span><br><span class="line">	overtime &#x3D; (time - (simpleDateFormat.parse(simpleDateFormat.format(time)).getTime()));</span><br><span class="line">&#125;catch (Exception e)&#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;时钟最多展示12个小时的时间，所以只需要留下一个小于12个小时的数据；一天共有12x60x60&#x3D;86400秒，半天则为43200秒</span><br><span class="line">if(overtime &gt;&#x3D; 43200000) &#123;</span><br><span class="line">	overtime &#x3D; overtime - 43200000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中心环与内环"><a href="#中心环与内环" class="headerlink" title="中心环与内环"></a>中心环与内环</h2><p>中心环与内环的实现很简单，只需要绘制两个中心圆就可以了，一个半径小一些且画笔宽度粗一些，一个半径大一些且画笔宽度细一些：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;绘制中心环画笔</span><br><span class="line">paints[0].setStyle(Paint.Style.STROKE);</span><br><span class="line">paints[0].setStrokeWidth(centerCircleWidth);</span><br><span class="line">paints[0].setColor(Color.WHITE);</span><br><span class="line">paints[0].setAntiAlias(true);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;绘制内环画笔</span><br><span class="line">paints[1].setStyle(Paint.Style.STROKE);</span><br><span class="line">paints[1].setStrokeWidth(innerCircleWidth);</span><br><span class="line">paints[1].setColor(Color.WHITE);</span><br><span class="line">paints[1].setAntiAlias(true);</span><br><span class="line"></span><br><span class="line">······</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;绘制中心环</span><br><span class="line">canvas.drawCircle(centerX,centerY,centerCircleRadius,paints[0]);</span><br><span class="line">&#x2F;&#x2F;绘制内环</span><br><span class="line">canvas.drawCircle(centerX,centerY,innerCircleRadius,paints[1]);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/11/21/Android%E6%97%B6%E9%92%9F%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/3.jpg" alt></p>
<h2 id="时针"><a href="#时针" class="headerlink" title="时针"></a>时针</h2><p>时针的实现有两点：1、时针的形状绘制；2、时针的指向角度绘制</p>
<p>时针的形状，我采用了一个等腰三角形来绘制。绘制等腰三角形，需要计算出三个点的位置。考虑到点的位置是时刻都在变化的，所以要先计算出指针应当指向的角度。</p>
<p><img src="/2018/11/21/Android%E6%97%B6%E9%92%9F%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/4.jpg" alt></p>
<p>如图所示，A点是左底点，B点是右底点，C点是顶点。其中，∠β是偏差角度，我设定为60度，∠α是时针整体的指向角度，底距是两个底点距原点的距离，时针的臂长则是顶点C距原点的距离。有了这些参数，计算各个点的变化规律就简单多了。比如：</p>
<p>$A_x = O_x + 底距 * sin(∠α - ∠β)$</p>
<p>$A_y = O_y + 底距 * cos(∠α - ∠β)$</p>
<p><strong>但是，Android界面的坐标系y轴与数学系的y轴在正方向上是相反的。所以，第二个算式中，要把”+”变为”-“。</strong></p>
<p>底点的计算已经有了，顶点的计算更简单了，自不用说。不过，计算中的∠β是个未知数，是需要我们自己去计算的。</p>
<p>前面代码中已经给过了overtime这个变量的计算，它代表的是超出当天0点的时间。计算时针的角度，只需要计算overtime能占到一个表格所表示的最大时间的比例，即占12个小时的比例。要注意的是，这里的比例计算要以毫秒为考虑角度，才能使计算出的角度尽可能的细致入微，而不是每过一个小时，跳格30度。代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;绘制时针底部时用到的偏差角度，用于计算底部点</span><br><span class="line">hourHandDeviation &#x3D; 60;</span><br><span class="line">······</span><br><span class="line">&#x2F;&#x2F;绘制时针</span><br><span class="line">&#x2F;&#x2F;以下是简化的公式，原公式为overtime&#x2F;(12 * 3600 * 1000) * (360 &#x2F; 1000)</span><br><span class="line">&#x2F;&#x2F;即先计算当前时间（单位为秒）占12个小时的总时间的多少，再乘以整个圈的度数，即可得到当前时针应该指向的角度</span><br><span class="line">double degree &#x3D; Math.toRadians(((double)overtime) &#x2F; 120000.00);</span><br><span class="line">double leftPointX &#x3D; centerX + handRadius * Math.sin(degree - Math.toRadians(hourHandDeviation));</span><br><span class="line">double leftPointY &#x3D; centerY - handRadius * Math.cos(degree - Math.toRadians(hourHandDeviation));</span><br><span class="line">double rightPointX &#x3D; centerX + handRadius * Math.sin(degree + Math.toRadians(hourHandDeviation));</span><br><span class="line">double rightPointY &#x3D; centerY - handRadius * Math.cos(degree + Math.toRadians(hourHandDeviation));</span><br><span class="line">double topPointX &#x3D; centerX + hourHandLength * Math.sin(degree);</span><br><span class="line">double topPointY &#x3D; centerY - hourHandLength * Math.cos(degree);</span><br><span class="line">&#x2F;&#x2F;通过绘制一个等腰三角形的类似图形来绘制时针</span><br><span class="line">Path path &#x3D; new Path();</span><br><span class="line">path.moveTo((float)leftPointX,(float)leftPointY);</span><br><span class="line">path.lineTo((float)topPointX,(float)topPointY);</span><br><span class="line">path.lineTo((float)rightPointX,(float)rightPointY);</span><br><span class="line">path.close();</span><br><span class="line">canvas.drawPath(path,paints[3]);</span><br></pre></td></tr></table></figure>
<h2 id="分针"><a href="#分针" class="headerlink" title="分针"></a>分针</h2><p>分针的绘制如同时针，只不过偏差角度小一些，臂长长一些，原理上都是一样的。代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;绘制分针</span><br><span class="line">&#x2F;&#x2F;以下为简化的公式，原公式为overtime mod (3600 * 1000) &#x2F; 3600 * (360 &#x2F; 1000)，计算当前时间除去小时后，剩余时间占一个小时的多少，再乘以总度数</span><br><span class="line">degree &#x3D; Math.toRadians(overtime % 3600000 * 0.0001);</span><br><span class="line">leftPointX &#x3D; centerX + handRadius * Math.sin(degree - Math.toRadians(minuteHandDeviation));</span><br><span class="line">leftPointY &#x3D; centerY - handRadius * Math.cos(degree - Math.toRadians(minuteHandDeviation));</span><br><span class="line">rightPointX &#x3D; centerX + handRadius * Math.sin(degree + Math.toRadians(minuteHandDeviation));</span><br><span class="line">rightPointY &#x3D; centerY - handRadius * Math.cos(degree + Math.toRadians(minuteHandDeviation));</span><br><span class="line">topPointX &#x3D; centerX + minuteHandLength * Math.sin(degree);</span><br><span class="line">topPointY &#x3D; centerY - minuteHandLength * Math.cos(degree);</span><br><span class="line">path &#x3D; new Path();</span><br><span class="line">path.moveTo((float)leftPointX,(float)leftPointY);</span><br><span class="line">path.lineTo((float)topPointX,(float)topPointY);</span><br><span class="line">path.lineTo((float)rightPointX,(float)rightPointY);</span><br><span class="line">path.close();</span><br><span class="line">canvas.drawPath(path,paints[4]);</span><br></pre></td></tr></table></figure>
<h2 id="秒针"><a href="#秒针" class="headerlink" title="秒针"></a>秒针</h2><p>秒针的绘制实际上也可以跟以上两个是一样的，不过我为了绘制一个等边三角形，本可以直接给定值的底距，在这里我是通过给定的秒针三角形的高secondHandHeight和底边中心到原点的距离secondHandRadius，间接计算而得出。这样的计算比较麻烦，但能得到一个等边三角形，我觉得还是可以的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;绘制一个三角形指针</span><br><span class="line">&#x2F;&#x2F;以下为简化的公式，原公式为overtime mod (60 * 1000) &#x2F; 60 * (360 &#x2F; 1000)</span><br><span class="line">degree &#x3D; Math.toRadians(overtime % 60000 * 0.006);</span><br><span class="line">&#x2F;&#x2F;计算三角形另外两顶点的偏差角度</span><br><span class="line">double deviation &#x3D; Math.atan(Math.tan(Math.toRadians(30))*secondHandHeight&#x2F;secondHandRadius);</span><br><span class="line">&#x2F;&#x2F;计算三个顶点的坐标变化</span><br><span class="line">topPointX &#x3D; centerX + (secondHandRadius + secondHandHeight) * Math.sin(degree);</span><br><span class="line">topPointY &#x3D; centerY - (secondHandRadius + secondHandHeight) * Math.cos(degree);</span><br><span class="line">double secondRadius &#x3D; Math.tan(Math.toRadians(30))*secondHandHeight&#x2F;Math.sin(deviation);</span><br><span class="line">leftPointX &#x3D; centerX + secondRadius * Math.sin(degree - deviation);</span><br><span class="line">leftPointY &#x3D; centerY - secondRadius * Math.cos(degree - deviation);</span><br><span class="line">rightPointX &#x3D; centerX + secondRadius * Math.sin(degree + deviation);</span><br><span class="line">rightPointY &#x3D; centerY - secondRadius * Math.cos(degree + deviation);</span><br><span class="line">path &#x3D; new Path();</span><br><span class="line">path.moveTo((float)topPointX,(float)topPointY);</span><br><span class="line">path.lineTo((float)leftPointX,(float)leftPointY);</span><br><span class="line">path.lineTo((float)rightPointX,(float)rightPointY);</span><br><span class="line">path.close();</span><br></pre></td></tr></table></figure>
<p>这里有一个小插曲：我这里直接简化了公式，得到的角度是精度很高，类型为double的度数，所以动画看起来很平滑，但最开始的时候，我的算式是这样的:overtime % 60000 * 6 / 1000 ，得到的是这样的：</p>
<p><img src="/2018/11/21/Android%E6%97%B6%E9%92%9F%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/8.gif" alt></p>
<p>由于gif的丢帧问题，这里表现的不是很明显，但可以告知的是，因为这样的算式最后计算出的值类型为int，所以表现上会是那种持续跳动的动画，而不是圆滑过渡的动画。这给了我一个教训：<strong>动画的过渡要想平滑，数值的精度一定要高</strong>。</p>
<h2 id="外环刻度盘"><a href="#外环刻度盘" class="headerlink" title="外环刻度盘"></a>外环刻度盘</h2><p>外环刻度盘有两种实现方法，一是通过设定绘制区域不变，边旋转画布边绘制刻度的方法；二是通过计算每个刻度的起点和终点并绘制来实现。讲道理按实现容易度来讲，应该按第一种来实现比较简单，不过因为我前几个实现全采用的三角函数计算，所以这里我的思维还是采用三角函数的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;绘制外环刻度</span><br><span class="line">for(float i &#x3D;0;i&lt;360;i&#x3D;i+2)&#123;</span><br><span class="line">	degree &#x3D; Math.toRadians(i);</span><br><span class="line">    double x1 &#x3D; centerX + outerCircleRadius * Math.sin(degree);</span><br><span class="line">    double y1 &#x3D; centerY - outerCircleRadius * Math.cos(degree);</span><br><span class="line">    double x2 &#x3D; centerX + (outerCircleRadius - outerCircleWidth) * Math.sin(degree);</span><br><span class="line">    double y2 &#x3D; centerY - (outerCircleRadius - outerCircleWidth) * Math.cos(degree);</span><br><span class="line">    if(i &gt;&#x3D; 270 &amp;&amp; i &lt;&#x3D; 360)&#123;</span><br><span class="line">    	paints[2].setAlpha((int)((i-270)*1.5+100));</span><br><span class="line">	&#125;else if(i &#x3D;&#x3D; 0)&#123;</span><br><span class="line">    	paints[2].setAlpha(240);</span><br><span class="line">	&#125;else &#123;</span><br><span class="line">    	paints[2].setAlpha(100);</span><br><span class="line">	&#125;</span><br><span class="line">    canvas.drawLine((float)x1,(float)y1,(float)x2,(float)y2,paints[2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以绘制出来一个静态的刻度盘，这个刻度盘有180道刻度，且为了赋予刻度盘一个动画的效果，最后的45道刻度以及第一道刻度赋予不同的透明度，造成淡化的效果。那么接下来，只要让刻度盘转起来就行了。</p>
<p>在最开始我想仿制分针的转动实现，但想了想，计算量大，考虑的东西有点多，后来就转为了转动画布的想法。不过，刻度盘的绘制以及转动的实现一定要放在其他三个指针的实现之前，不然会带动三个指针一起转动，这样，指针的指向就与当前时间不符了。</p>
<p>有了方向，实现转动效果就可以了。转动效果包括两点：1、每秒转动3次，即每333ms为一次转动契机；2、每次都比上次的转动角度大2度。所以，角度计算如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;计算当前时间是（几时几分）几秒</span><br><span class="line">long overSecond &#x3D; overtime % 60000;</span><br><span class="line">&#x2F;&#x2F;每秒跨格6度，每333ms跨格2度</span><br><span class="line">double degree &#x3D; overSecond &#x2F; 1000 * 6 + overSecond % 1000 &#x2F; 333 * 2;</span><br></pre></td></tr></table></figure>
<p>计算完了，就是画布的旋转。画布的旋转跟想象中的很不一样，但我也不会在这里详解，只贴出来使用流程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas.save();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;计算角度</span><br><span class="line">&#x2F;&#x2F;以圆心为中心旋转</span><br><span class="line">canvas.rotate((float)degree,centerX,centerY);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;绘制刻度盘</span><br><span class="line"></span><br><span class="line">canvas.restore();</span><br></pre></td></tr></table></figure>
<p>这样就可以实现刻度盘的转动了。</p>
<p><del>（神特么这个转动角度让我钻了牛角尖，想了整整一天才想出来怎么计算）</del></p>
<h2 id="3D视角的转动"><a href="#3D视角的转动" class="headerlink" title="3D视角的转动"></a>3D视角的转动</h2><p>3D视角的转动主要借助于camera和matrix的结合实现。这个部分的动画功能设想是，当点击时钟周围，时钟会侧向点击方向；手指松开屏幕时，时钟会重新回到原来的位置，实现效果如下：</p>
<p><img src="/2018/11/21/Android%E6%97%B6%E9%92%9F%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/9.gif" alt></p>
<p>实现思路：给view类添加点击事件的监听，当手指按下时，获取点击点的坐标，与中心点对比后判断时钟旋转方向并旋转；手指松开时，加一个时钟恢复原位的动画，这样就算完成了。</p>
<p>代码实现如下：</p>
<p>1、添加点击事件监听。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private ValueAnimator shakeAnim;</span><br><span class="line">...</span><br><span class="line">@Override</span><br><span class="line">public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">	switch (event.getAction())&#123;</span><br><span class="line">    	case MotionEvent.ACTION_DOWN:       &#x2F;&#x2F;手指按下时，而非向下的手势</span><br><span class="line">        	if(shakeAnim !&#x3D; null &amp;&amp; shakeAnim.isRunning())&#123;</span><br><span class="line">            	shakeAnim.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">			&#x2F;&#x2F;获取点击点的坐标并进行处理</span><br><span class="line">            getCameraRotate(event);</span><br><span class="line">            break;</span><br><span class="line">        case MotionEvent.ACTION_MOVE:       &#x2F;&#x2F;手指移动时</span><br><span class="line">            getCameraRotate(event);</span><br><span class="line">            break;</span><br><span class="line">        case MotionEvent.ACTION_UP:         &#x2F;&#x2F;手指抬起时，而非向上的手势</span><br><span class="line">			&#x2F;&#x2F;抬起后进行时钟恢复原位的动画</span><br><span class="line">            startShakeAnim();</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、获取点击点坐标并进行角度判断。与中心点坐标进行对比，为防止时钟偏移角度过大，设定最大旋转角度为30度，最后获取到角度后，在onDraw()方法中对视图进行视角的旋转操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private float cameraRotateX;				&#x2F;&#x2F;camera视角中x轴转动的角度</span><br><span class="line">private float cameraRotateY;				&#x2F;&#x2F;camera视角中y轴转动的角度</span><br><span class="line">private final maxCameraRotate &#x3D; 30;			&#x2F;&#x2F;最大旋转角度</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F;获取点击点</span><br><span class="line">private void getCameraRotate(MotionEvent event)&#123;</span><br><span class="line">	if(shakeAnim !&#x3D; null &amp;&amp; shakeAnim.isRunning())&#123;</span><br><span class="line">    	shakeAnim.cancel();</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;与中心点坐标进行对比</span><br><span class="line">    float rotateX &#x3D; -(event.getY() - 640);</span><br><span class="line">    float rotateY &#x3D; (event.getX() - 360);</span><br><span class="line">    &#x2F;&#x2F;求出此时旋转的大小与半径之比</span><br><span class="line">    float percentX &#x3D; rotateX &#x2F; outerCircleRadius;</span><br><span class="line">    float percentY &#x3D; rotateY &#x2F; outerCircleRadius;</span><br><span class="line">    if(percentX &gt; 1)&#123;</span><br><span class="line">    	percentX &#x3D; 1;</span><br><span class="line">	&#125;else if(percentX &lt; -1)&#123;</span><br><span class="line">    	percentX &#x3D; -1;</span><br><span class="line">	&#125;</span><br><span class="line">    if(percentY &gt; 1)&#123;</span><br><span class="line">    	percentX &#x3D; 1;</span><br><span class="line">	&#125;else if(percentY &lt; -1)&#123;</span><br><span class="line">    	percentY &#x3D; -1;</span><br><span class="line">	&#125;</span><br><span class="line">    &#x2F;&#x2F;最终旋转的大小按比例匀称改变</span><br><span class="line">    cameraRotateX &#x3D; percentX * maxCameraRotate;</span><br><span class="line">    cameraRotateY &#x3D; percentY * maxCameraRotate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置3D时钟效果</span><br><span class="line">private void setCameraRotate()&#123;</span><br><span class="line">    cameraMatrix.reset();</span><br><span class="line">	&#x2F;&#x2F;camera的旋转与canvas的旋转用法很相似，先save()再旋转最后restore()</span><br><span class="line">    camera.save();</span><br><span class="line">    camera.rotateX(cameraRotateX);</span><br><span class="line">    camera.rotateY(cameraRotateY);</span><br><span class="line">    camera.getMatrix(cameraMatrix);</span><br><span class="line">    camera.restore();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;时钟旋转后视图会发生很大的视角偏差，所以需要通过平移来设定旋转后的时钟中心点</span><br><span class="line">    cameraMatrix.preTranslate(-getWidth()&#x2F;2,-getHeight()&#x2F;2);</span><br><span class="line">    cameraMatrix.postTranslate(getWidth()&#x2F;2,getHeight()&#x2F;2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、时钟恢复原位的动画。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void startShakeAnim()&#123;</span><br><span class="line">    PropertyValuesHolder cameraRotateXHolder &#x3D; PropertyValuesHolder.ofFloat(&quot;cameraRotateX&quot;,cameraRotateX,0);</span><br><span class="line">    PropertyValuesHolder cameraRotateYHolder &#x3D; PropertyValuesHolder.ofFloat(&quot;cameraRotateY&quot;,cameraRotateY,0);</span><br><span class="line">    shakeAnim &#x3D; ValueAnimator.ofPropertyValuesHolder(cameraRotateXHolder,cameraRotateYHolder);</span><br><span class="line">    shakeAnim.setInterpolator(new OvershootInterpolator(10));</span><br><span class="line">    shakeAnim.setDuration(500);</span><br><span class="line">    shakeAnim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">            cameraRotateX &#x3D; (float) animation.getAnimatedValue(&quot;cameraRotateX&quot;);</span><br><span class="line">            cameraRotateY &#x3D; (float) animation.getAnimatedValue(&quot;cameraRotateY&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    shakeAnim.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的ValueAnimator.ofPropertyValuesHolder(PropertyValuesHolder… values)方法可以同时管理多个动画属性，比起之前的分散式管理，代码量少，也更好阅读。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>终于把3D效果的实现部分补上了。沉迷了几天的Win10 UWP应用，这才回来补上没写完的部分。</p>
<p>哦对了，PPT的绘画真好用，以后就用PPT画图好了。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android盖章动画实现</title>
    <url>/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>毕设做完这么久了，我终于回来填我自己挖下的第一个坑了。话不多说，直奔主题。</p>
<a id="more"></a>
<p>在毕设中，有一个模块是赛程数据模块,如下图：</p>
<p><img src="/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/lol_match_data.png" alt></p>
<p>那个胜利图标的显示，其实我是想用一个章印落下的动画来实现的，只不过那时忙于后台，没来得及去细看动画方面的学习。不过这几天得了些兴致，就回来填一下坑。</p>
<p>先贴效果图，如下：</p>
<p><img src="/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/sample.gif" alt></p>
<p>接下来就讲一下实现的过程。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Android动画分为视图动画与属性动画，视图动画又分为逐帧动画与补间动画。逐帧动画的工作原理类似于动画片，将一张张拆分开来的动画通过连续播放的操作，形成动画的效果。补间动画则是对view进行一系列动画操作，包括平移（Translate）、透明度（Alpha）、旋转度（Rotate）与缩放（Scale）。属性动画与补间动画类似，但是这两者有一个最大的不同。比如说，一个仅占手机界面中间一部分的按钮，我们对它进行两种动画操作：一，补间动画，将按钮放大至铺满屏幕，点击屏幕边缘，发现并没有触发按钮点击事件，这是因为补间动画仅仅是将按钮绘制为铺满屏幕而已，按钮本身的大小、位置属性并没有发生变化；而第二种，属性动画，就是为了弥补补间动画的这一缺点，属性动画放大的按钮，大小和位置属性也会发生变化，铺满屏幕后仍然可以点击。</p>
<p>除此之外，补间动画只能实现上述的四种操作，且对象仅针对于可写于布局中的view对象。属性动画可以实现背景颜色的渐变等，且对canvas、point等有一定的支持。所以，说属性动画在一定程度上可以代替补间动画。</p>
<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>先搞清楚这个动画过程中都用到了什么操作，操作的顺序或触发时机是怎样的。</p>
<ul>
<li><p>章印本身是从无到有的，即透明度是从透明过渡到不透明的。</p>
</li>
<li><p>章印是从大到小落下去的，即用到了缩放。</p>
</li>
<li><p>章印在这个过程中有一定角度的旋转。</p>
</li>
<li><p>章印落下后，为给人一种有力的感觉，整个页面布局需要有一定的抖动效果实现，而抖动，就是多个方向的平移的组合实现。</p>
</li>
</ul>
<p>这下就很清楚了。章印在落下的过程中，调用了透明度、缩放、旋转的属性动画；落下后，整个布局调用了平移的属性动画。那么接下来，只要搞清楚每个属性动画怎么实现就行了。</p>
<h1 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h1><h2 id="ValueAnimator"><a href="#ValueAnimator" class="headerlink" title="ValueAnimator"></a>ValueAnimator</h2><p>这个类是Android的属性动画机制中最核心的一个类。属性动画的运行机制，是通过对变化属性的值进行不断的运算，并赋予视图属性来实现的。它使得整个动画过程过渡得比较平滑，使人看起来很舒服。我们可以通过调用这个类，来观察值的变化规律。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ValueAnimator anim &#x3D; ValueAnimator.ofFloat(0f, 1f);</span><br><span class="line">                anim.setDuration(500);</span><br><span class="line">                anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">                        float currentValue &#x3D; (float) animation.getAnimatedValue();</span><br><span class="line">                        Log.d(&quot;TAG&quot;, &quot;cuurent value is &quot; + currentValue);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                anim.start();</span><br></pre></td></tr></table></figure>
<p>值的变化如下：</p>
<p><img src="/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/1.png" alt></p>
<p>通过值的变化可以看出，类似于正弦函数y=sinx位于-π/2到π/2之间的曲线图的变化，很贴近，起步缓，中期变化快，最后缓。不过，ofFloat方法中不止可以只传入两个值，大家可以自行传入更多的值观察变化。</p>
<p>这个类相比于表层的ObjectAnimator类，我们对后者会接触的更多一些。下面就会对效果做一些实现和演示。</p>
<h2 id="透明度-Alpha"><a href="#透明度-Alpha" class="headerlink" title="透明度 Alpha"></a>透明度 Alpha</h2><p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectAnimator animator &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;alpha&quot;,1f,0f,1f,0f,1f);</span><br><span class="line">animator.setDuration(5000);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure>
<p>实现效果：</p>
<p><img src="/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/2.gif" alt></p>
<p>可以看到，这里通过调用ofFloat()方法创建了一个ObjectAnimator的实例，其他效果的实现也大多与此类似。对于alpha属性来说，0表示透明，1表示不透明。对于ofFloat来说，属性后的数值个数传入是没有限制的。这里传入三个值是可以的，传入五个或者更多也是可以的。setDuration方法设置整个动画的时长，注意，是整个，而不是每个变化之间的时长。</p>
<p>还有，在这次实现效果中，可以看到第一次隐去和第二次显现的过程较长，而第一次显示和第二次隐去的过程较短。这就与上面提到的ValueAnimator的值的变化规律有关了。</p>
<h2 id="旋转-rotation"><a href="#旋转-rotation" class="headerlink" title="旋转 rotation"></a>旋转 rotation</h2><p>接下来的其他属性动画代码，不一样的大概就是关键字了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectAnimator animator &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;rotation&quot;,0f,360f);</span><br><span class="line">                animator.setDuration(5000);</span><br><span class="line">                animator.start();</span><br></pre></td></tr></table></figure>
<p>实现效果：</p>
<p><img src="/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/3.gif" alt></p>
<h2 id="平移-translation"><a href="#平移-translation" class="headerlink" title="平移 translation"></a>平移 translation</h2><p>这就要先说一下Android的坐标系了，如下：</p>
<p><img src="/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/4.jpg" alt></p>
<p>以我们要操作的view控件为中心，向右x增加，向下y增加。掌握这个规律后，对view操作就比较好用了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float curTranslationX &#x3D; vicImg.getTranslationX();</span><br><span class="line">                float curTranslationY &#x3D; vicImg.getTranslationY();</span><br><span class="line">                ObjectAnimator animatorX &#x3D; ObjectAnimator.ofFloat(vicImg, &quot;translationX&quot;, curTranslationX, -500f, curTranslationX);</span><br><span class="line">                ObjectAnimator animatorY &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;translationY&quot;, curTranslationY, -500f,curTranslationY);</span><br><span class="line">                animatorX.setDuration(5000);</span><br><span class="line">                animatorY.setDuration(5000);</span><br><span class="line">                animatorX.start();</span><br><span class="line">                animatorY.start();</span><br></pre></td></tr></table></figure>
<p>实现效果：</p>
<p><img src="/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/5.gif" alt></p>
<h2 id="缩放-scale"><a href="#缩放-scale" class="headerlink" title="缩放 scale"></a>缩放 scale</h2><p>缩放也同平移一样，也有x方向和y方向上的缩放。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectAnimator animatorX &#x3D; ObjectAnimator.ofFloat(vicImg, &quot;scaleX&quot;, 1f,3f,1f);</span><br><span class="line">                ObjectAnimator animatorY &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;scaleY&quot;, 1f,3f,1f);</span><br><span class="line">                animatorX.setDuration(2000);</span><br><span class="line">                animatorY.setDuration(2000);</span><br><span class="line">                animatorX.start();</span><br><span class="line">                animatorY.start();</span><br></pre></td></tr></table></figure>
<p>实现效果：</p>
<p><img src="/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/6.gif" alt></p>
<p>这样，基本就学到了每个属性动画的简单用法。</p>
<h2 id="动画组合"><a href="#动画组合" class="headerlink" title="动画组合"></a>动画组合</h2><p>独立的属性动画很难出彩，但如果将多个结合到一起，那就很不错了。而AnimatorSet类整合实现了组合动画的功能。它主要包括了以下四个方法：</p>
<ul>
<li><p>after(Animator anim)：将现有动画插入到传入的动画之后执行</p>
</li>
<li><p>after(long delay)：将现有动画延迟指定时间后执行</p>
</li>
<li><p>before(Animator anim)：将现有动画插入到传入的动画之前执行</p>
</li>
<li><p>with(Animator anim)：将现有动画与传入动画同时执行</p>
</li>
</ul>
<p>有了这个类，我们就可以完成组合动画了。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectAnimator animatorAlpha &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;alpha&quot;,1f,0f,1f);</span><br><span class="line">                ObjectAnimator rotationAnimator &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;rotation&quot;,0f,360f);</span><br><span class="line">                ObjectAnimator animatorX &#x3D; ObjectAnimator.ofFloat(vicImg, &quot;scaleX&quot;, 1f,3f,1f);</span><br><span class="line">                ObjectAnimator animatorY &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;scaleY&quot;, 1f,3f,1f);</span><br><span class="line">                AnimatorSet animatorSet &#x3D; new AnimatorSet();</span><br><span class="line">                animatorSet.play(animatorX).with(animatorY).with(animatorAlpha).before(rotationAnimator);</span><br><span class="line">                animatorSet.setDuration(2000);</span><br><span class="line">                animatorSet.start();</span><br></pre></td></tr></table></figure>
<p>代码可以看出来，组合出来的动画是，x方向和y方向同时放大3倍再缩小回原大小，同时还由不透明变为透明再变为不透明。这三个动画组合播放结束后，再旋转360度。<strong>注意，before和after是相对play和with的动画而言的，传入before的动画，会在最后执行，传入after的动画，会在最开始执行。</strong></p>
<p>效果如下：</p>
<p><img src="/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/7.gif" alt></p>
<h2 id="Xml动画配置"><a href="#Xml动画配置" class="headerlink" title="Xml动画配置"></a>Xml动画配置</h2><p>通过ObjectAnimator类可以完成动画编写，xml格式也可以完成。对于属性配置，我们优先选择xml文件进行编写。我们也可以写动画静态类，不过一般静态类我们用来写业务方面的方法。所以，xml格式的配置学习也是必要的。</p>
<ul>
<li>scale</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;set xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;</span><br><span class="line">    &lt;scale android:duration&#x3D;&quot;2000&quot;</span><br><span class="line">        android:fromXScale&#x3D;&quot;1.0&quot;</span><br><span class="line">        android:fromYScale&#x3D;&quot;1.0&quot;</span><br><span class="line">        android:toXScale&#x3D;&quot;2.0&quot;</span><br><span class="line">        android:toYScale&#x3D;&quot;2.0&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;set&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>rotate</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;set xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;</span><br><span class="line">    &lt;rotate android:duration&#x3D;&quot;2000&quot;</span><br><span class="line">        android:fromDegrees&#x3D;&quot;0&quot;</span><br><span class="line">        android:toDegrees&#x3D;&quot;30&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;set&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>translate</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;set xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;</span><br><span class="line">    &lt;translate android:duration&#x3D;&quot;2000&quot;</span><br><span class="line">        android:fromXDelta&#x3D;&quot;-50&quot;</span><br><span class="line">        android:fromYDelta&#x3D;&quot;-50&quot;</span><br><span class="line">        android:toXDelta&#x3D;&quot;50&quot;</span><br><span class="line">        android:toYDelta&#x3D;&quot;50&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;set&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>alpha</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;set xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;</span><br><span class="line">    &lt;translate android:duration&#x3D;&quot;2000&quot;</span><br><span class="line">        android:fromXDelta&#x3D;&quot;-50&quot;</span><br><span class="line">        android:fromYDelta&#x3D;&quot;-50&quot;</span><br><span class="line">        android:toXDelta&#x3D;&quot;50&quot;</span><br><span class="line">        android:toYDelta&#x3D;&quot;50&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;set&gt;</span><br></pre></td></tr></table></figure>
<p>四种标签属性的代码的基本属性代码如上所示（效果图我就不贴出了，太麻烦了，录制MP4还得转换在线格式）。</p>
<p>不过，在查资料的过程中，还有这么一个基本属性：pivotX、pivotY</p>
<p>这个属性的值有三种：数值、百分数、百分数p，分别比如：50、50%、50%p。当为数值时，表示在当前View的左上角，即原点处加上50px，做为起始缩放点；如果是50%，表示在当前View的左上角加上自己宽度的50%做为起始点；如果是50%p，那么就是表示在当前的左上角加上父控件宽度的50%做为起始点x轴坐标，这个父控件，可以是整个布局，也可以只是一个横行布局等。</p>
<p>标签属性毕竟是跟Animation类一样的，所以它也有如下属性：</p>
<ul>
<li><p>duration：动画时长，单位毫秒</p>
</li>
<li><p>fillAfter：可设置，若为true，则动画结束时，保持动画的结束状态</p>
</li>
<li><p>fillBefore：可设置，若为true，则动画结束时，还原到动画开始前的状态</p>
</li>
<li><p>repeatMode：重复类型，有reverse和restart两个值，前者表示倒序回放，后者表示重放一遍。</p>
</li>
<li><p>interpolator：设定插值器，即指定的动画效果。在此处只用到了CycleInterpolator，用于指定动画循环次数。</p>
</li>
</ul>
<p>其他博客上挂出来的其他属性，我在当前版本的AndroidStudio上是没办法使用的。这种情况遇到过很多次了，很多别人挂出来的代码并不能用，自己还得去找新的实现办法。所以以后如果我觉得有必要的话，挂一下开发环境，省的自己和别人为不能重用代码的问题烦恼。</p>
<p>话题说远了，不过用到的知识差不多也就剩下CycleInterpolator和别的一点东西了。它的用法也很简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;cycleInterpolator xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    android:cycles&#x3D;&quot;2&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>一目了然。cycles属性指定重复动作次数，且这个插值器使用时，动画的值会按照正弦函数一样变化。以后若是需要用到其他的插值器，我再去做深入的了解。</p>
<p>对了，差点忘记了set标签。在单个动画动作xml文件中，其实可以存放多组动作标签，而set就负责对它们的执行顺序进行排列和组合。主要属性：ordering，值有两种：Sequentially（顺序执行）和together（同时执行）。用法也很简单，会直接在实现代码中贴出来。</p>
<h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><p>我采用了两种代码结合的办法。<del>别问我为什么，我也想只用xml，但特喵的就是不抖动，只好还是用原来的两种形式结合的代码了</del></p>
<p>Activity.java:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void gaizhang()&#123;</span><br><span class="line">        &#x2F;&#x2F;透明度渐变动画</span><br><span class="line">        ObjectAnimator alphaAnimator &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;alpha&quot;,0f,1f,1f);</span><br><span class="line">        alphaAnimator.setDuration(1000);</span><br><span class="line">        alphaAnimator.start();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;旋转渐变动画</span><br><span class="line">        ObjectAnimator rotationAnimator &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;rotation&quot;,-30f,0f);</span><br><span class="line">        rotationAnimator.setDuration(500);</span><br><span class="line">        rotationAnimator.start();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;大小变化动画</span><br><span class="line">        ObjectAnimator yAnimator &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;scaleY&quot;,5f,1f,1f);</span><br><span class="line">        ObjectAnimator xAnimator &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;scaleX&quot;,5f,1f,1f);</span><br><span class="line">        yAnimator.setDuration(1000);</span><br><span class="line">        xAnimator.setDuration(1000);</span><br><span class="line">        yAnimator.start();</span><br><span class="line">        xAnimator.start();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;界面抖动动画</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(500);</span><br><span class="line">                &#125;catch (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                handler.sendEmptyMessage(20);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private Handler handler &#x3D; new Handler()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            switch (msg.what)&#123;</span><br><span class="line">                case 20:</span><br><span class="line">                    &#x2F;&#x2F;界面抖动动画</span><br><span class="line">                    Animation shake &#x3D; AnimationUtils.loadAnimation(getApplicationContext(),R.anim.myanim);</span><br><span class="line">                    constraintLayout.startAnimation(shake);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>shake_anim.xml:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;set xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    android:interpolator&#x3D;&quot;@anim&#x2F;cycle_2&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration&#x3D;&quot;100&quot;</span><br><span class="line">        android:fromXDelta&#x3D;&quot;-10&quot;</span><br><span class="line">        android:fromYDelta&#x3D;&quot;0&quot;</span><br><span class="line">        android:toXDelta&#x3D;&quot;0&quot;</span><br><span class="line">        android:toYDelta&#x3D;&quot;-10&quot; &#x2F;&gt;&lt;!--向上十个单位--&gt;</span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration&#x3D;&quot;100&quot;</span><br><span class="line">        android:fromXDelta&#x3D;&quot;0&quot;</span><br><span class="line">        android:fromYDelta&#x3D;&quot;-10&quot;</span><br><span class="line">        android:startOffset&#x3D;&quot;100&quot;</span><br><span class="line">        android:toXDelta&#x3D;&quot;10&quot;</span><br><span class="line">        android:toYDelta&#x3D;&quot;0&quot; &#x2F;&gt;&lt;!--向右十个单位--&gt;</span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration&#x3D;&quot;100&quot;</span><br><span class="line">        android:fromXDelta&#x3D;&quot;10&quot;</span><br><span class="line">        android:fromYDelta&#x3D;&quot;0&quot;</span><br><span class="line">        android:startOffset&#x3D;&quot;200&quot;</span><br><span class="line">        android:toXDelta&#x3D;&quot;0&quot;</span><br><span class="line">        android:toYDelta&#x3D;&quot;10&quot; &#x2F;&gt;&lt;!--向下十个单位--&gt;</span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration&#x3D;&quot;100&quot;</span><br><span class="line">        android:fromXDelta&#x3D;&quot;0&quot;</span><br><span class="line">        android:fromYDelta&#x3D;&quot;10&quot;</span><br><span class="line">        android:startOffset&#x3D;&quot;300&quot;</span><br><span class="line">        android:toXDelta&#x3D;&quot;-10&quot;</span><br><span class="line">        android:toYDelta&#x3D;&quot;0&quot; &#x2F;&gt;&lt;!--向左是个单位--&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;set&gt;</span><br></pre></td></tr></table></figure>
<p>cycleIntepolator.xml：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;cycleInterpolator xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">android:cycles&#x3D;&quot;2&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这篇博客前半部分，即xml属性章节之前，我花了一天就写出来了，但因为个人极度讨厌网页标签这种代码（布局代码还行，但属性xml就特别烦），xml一直拖着不想写，9号了才耐着性子把它写出来。希望，之后的动画学习，不会有太多的xml文件代码。</p>
<p>参考博客：<a href="https://blog.csdn.net/guolin_blog/article/details/43536355">Android属性动画完全解析(上)，初识属性动画的基本用法</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>lemon</title>
    <url>/2020/06/24/lemon/</url>
    <content><![CDATA[<p>歌名：lemon</p>
<a id="more"></a>
<p>应好友的要求，第二首就写一下lemon。<strong>第三行注音是日语注音</strong>。</p>
<h1 id="歌"><a href="#歌" class="headerlink" title="歌"></a>歌</h1><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="430" height="86" src="//music.163.com/outchain/player?type=2&id=536622304&auto=0&height=66"></iframe>

<p>（网易版权原因，可能会无法播放）</p>
<h1 id="MV"><a href="#MV" class="headerlink" title="MV"></a>MV</h1><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
    <iframe src="//player.bilibili.com/player.html?aid=88558801&bvid=BV1e7411V75v&cid=155163214&page=1&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe>
</div>

<h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>１</p>
<p>ゆめ<br>夢　ならばどれほどよかったでしょう<br>yu me na ra ba do re ho do yo ka tta de shou</p>
<p>いま　　　　　　　　　ゆめ<br>未　だにあなたのことを夢　にみる<br>i ma da ni a na ta no ko to wo yu me ni mi ru</p>
<p>わす　　もの　と　　かえ　<br>忘　れた物　を取りに帰　るように<br>wa su re ta mo no wo to ri ni ka e ru yo u ni</p>
<p>ふる　　おも　で　ほこり　はら<br>古　びた思　い出の埃　　を払　う<br>fu ru bi ta o mo i de no ho ko ri wo ha ra u</p>
<p>もど　　　しあわ<br>戻　らない幸　　せがあることを<br>mo do ra na i shi a wa se ga a ru ko to wo</p>
<p>さいご         おし<br>最後　にあなたが教　えてくれた<br>sa i go ni a na ta ga o shi e te ku re ta</p>
<p>い　　　かく　　　くら　かこ<br>言えずに隠　してた昏　い過去も<br>i e zu ni ka ku shi te ta ku ra i ka ko mo</p>
<p>　　　　　　　　えいえん　くら<br>あなたがいなきゃ永遠　　に昏　いまま<br>a na ta ga i na ki ya e i e n ni ku ra i ma ma</p>
<p>　　　　　　　いじょうきず<br>きっともうこれ以上　　傷　つくことなど<br>ki tto mo u ko re i jyou ki zu tsu ku ko to na do</p>
<p>ありはしないとわかっている<br>a ri wa shi na i to wa ka tte i ru</p>
<p>　　ひ　かな　　　　　　　ひ　くる<br>あの日の悲　しみさえ　あの日の苦　しみさえ<br>a no hi no ka na shi mi sa e   a no hi no ku ru shi mi sa e</p>
<p>　　　　　　あい<br>そのすべてを愛　してた　あなたとともに<br>so no su be te wo a i shi te ta  a na ta to to mo ni</p>
<p>むね　のこ　はな　　　　にが　　　　　にお<br>胸　に残　り離　れない　苦　いレモンの匂　い<br>mu ne ni no ko ri ha na re na i   ni ga i remon no ni o i</p>
<p>あめ　ふ　や　　　かえ<br>雨　が降り止むでは帰　れない<br>a me ga fu ri ya mu ma de wa ka e re na i</p>
<p>いま　　　　　　　　　　ひかり<br>今　でもあなたはわたしの光<br>i ma te mo a na ta wa wa ta shi no hi ka ri</p>
<p>２</p>
<p>くらやみ　　　　　せ<br>暗闇　　であなたの背をなぞった<br>ku ra ya mi te a na ta no se wo na zo tta</p>
<p>　　りんかく　せんめい　おぼ<br>その輪郭　　を鮮明　　に覚　えている<br>so no ri n ka ku wo se n me i ni o bo e te i ru</p>
<p>う　と　　　　　　　　であ<br>受け止めきらないものと出会うたび<br>u ke to me ki ra n i mo no to de a u ta bi</p>
<p>あふ　　　　　　　　なみだ<br>溢　れてやまないのは涙　　だけ<br>a fu re te ya ma na i no wa na mi da da ke</p>
<p>なに　　　　　　　なに　み<br>何　をしていたの　何　を見ていたの<br>na ni wo shi te i ta no   na ni wo mi te i ta no</p>
<p>　　　　し　　　よこがお<br>わたしの知らない横顔　　で<br>wa ta shi no shi ra na i yo ko ga o de</p>
<p>　　　　　　　　いま　　　　　おな　よう<br>どこかであなたが今　　わたしと同　じ様　な<br>do ko ka de a na ta ga i ma    wa ta shi to o na ji yo u na</p>
<p>なみだ　　　　さび　　　なか<br>涙　　にくれ　淋　しさの中　にいるなら<br>na mi da ni ku re   sa bi shi sa no na ka ni i so na ra</p>
<p>　　　　　　　　　　　　わす<br>わたしのことなどどうか　忘　れてください<br>wa ta shi no ko to na do do so ka    wa su re te ku da sa i</p>
<p>　　　　　　こころ　　ねが<br>そんなことを心　　から願　うほどに<br>so n na ko to wo ko ko ro ka ra ne ga u ho do ni</p>
<p>いま　　　　　　わたし　ひかり<br>今　でもあなたは私　　の光<br>i ma de mo a na ta wa wa ta shi no hi ka ri</p>
<p>３</p>
<p>じぶん　おも<br>自分　か思　うより<br>ji bu n ka o mo u yo ri</p>
<p>こい<br>恋　をしていたあなたに<br>ko i wo shi te i ta a na ta ni</p>
<p>　　　　おも<br>あれから思　うように<br>a re ka ra o mo u yo u ni</p>
<p>いき<br>息　ができない<br>i ki ga de ki na i </p>
<p>　　　　そば<br>あんなに側　にいたのに<br>a n na ni so ba ni i ta no ni</p>
<p>　　　うそ<br>まるで噓　みたい<br>ma ru de u so mi ta i </p>
<p>　　　わす<br>とても忘　れらない<br>to te mo wa su re ra na i</p>
<p>　　　　　たし<br>それだけが確　か<br>so re da ke ga ta shi ka</p>
<p>　　ひ　かな　　　　　　　ひ　くる<br>あの日の悲　しみさえ　あの日の苦　しみさえ<br>a no hi no ka na shi mi sa e   a no hi no ku ru shi mi sa e</p>
<p>　　　　　　あい<br>そのすべてを愛　してた　あなたとともに<br>so no su be te wo a i shi te ta  a na ta to to mo ni</p>
<p>むね　のこ　はな　　　　にが　　　　　にお<br>胸　に残　り離　れない　苦　いレモンの匂　い<br>mu ne ni no ko ri ha na re na i   ni ga i remon no ni o i</p>
<p>あめ　ふ　や　　　かえ<br>雨　が降り止むでは帰　れない<br>a me ga fu ri ya mu ma de wa ka e re na i</p>
<p>き　わ　　かじつ　かたほう　よう<br>切り分けた果実　の片方　　の様　に<br>ki ri wa ke ta ka ji tsu no ka ta ho u no yo u ni</p>
<p>いま　　　　　　　　　　ひかり<br>今　でもあなたはわたしの光<br>i ma de mo a na ta wa wa ta shi no hi ka ri</p>
]]></content>
      <categories>
        <category>Song</category>
      </categories>
  </entry>
  <entry>
    <title>《小情歌》读后感</title>
    <url>/2018/09/22/%E3%80%8A%E5%B0%8F%E6%83%85%E6%AD%8C%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉，密码不正确" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">这里有东西被加密了，需要输入密码才能查看</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="091760458396d93197b8a994bac35f27c30170881833434f936187ccb83330ab">c8bd79c51856d12e53d92667dc5fb8193b88cb7d2adcaa5d92d9fef875a199ee54ce597b36dee96b8c2a4d0c670271254d6c31f124379ed9433bb8625cfa2aabb0f2a30e5ba1acf7d43610173e8d78daadd35b7af9f2b7431841350cab4a9aa4c526d73aeca9384193615156f583204c6ef5c11032191463a225c9ef588fcd379897e9145a0877fcb50e04db01ca21607b636d1639eacd4f84d5c06457f4bc40730fbc6ec762f36387c61d43661db20cd13733d7cae0004453eec0d5d6301843d302b604c4d6296bb5802211f7da0a6628c3f431c09dff928dcc7b82fc0febb7877c64be2cfb4d3206bef84fbdd1f94f8295c39eb2717f9e5ee477c7866b4076c007a50e885ac224f22712b6a18fe64adb67ac610d41364c2de57c40acc72111f7d78218c8a526cfaf00395047a574740e6e121e8e448c316a41e230cb64b39da5ed3a3c0f140f70c9fad5b01ac7c4c3565bef71cf9c5309e069d0a4ec364bb0540b49b906506c36f1cca69b3f332e498b3d294a34e99fdc2e5e087c2098046f9f71874eef7237d67e48064cd69b652e7f28f6437713fa8f942c7330319c5ec91532088bea49ddd69eeb9a86f38f20518df7756dfec2e4b9da812c1f121c12969b451a2b3504e73b1b268742029d29fcbca7c52bf1bc0f1814f837bb6f8c918541a0f0771b970f1b04430084ebe890baf5f141b748b7196246b0855c71d96b37cf50867bfaf0f20e7a3e3c2b8f7900addc1453d8dda7b7aad7a64b4dfce269bb118edce8cbd0b347c0a72573b64f07fa3ec3deb2f84a4446de1119b453eda03b153b482c14f34433b6cc1a325652472eb66fbe9d473627e5c6008f83ea906599e3494caf1c4df408601155d33faff4fc122a1f961d858c34ca559544692c76ad9b1c02ae69c329cada1cfb3eaa40ac163a23eace4bc9369c77ffcb00bdceda76772edb9258c36b20fc073f7a26660dae7d5dad602095cfd2963305acb3b96aed256fda22173cf57ef583aa2629b01645080886d2ac52a844a805cdc00bef37307497f8e5249dcece0c4382f7f4f92a6ab97207a3ed85c0b1be30048003b5a90663dc68b5aceb3b4d3f742c7398f02f71e9e3f2f2241803bff632e93947fe9f7420370d8b364f26611670b61dc85ea030ed4851ed1b9f4b456d43c9c31cf6d7026e03e51d598c32fd0b260e06df95fc4ec24f80ea07679c0e7a4e653ec6b1054ae41ce98519ca368a0e330beafc77242926c295663107208edc9fc6b9547ab63683b69385659efe54c091d9cb746872dda13b3150bdf7ebedea2691fe59a055af9a14457366582a96e889d25288bae83b29bc9ab0a2b667a06264cbabd24d64092be7e306c54ae950684876c63b1ee95b61101c550f08e116880dff667c65cce2ae9e5d2bc9dfdb3f5d9f04d6d1bdb9e39be575f9367118e01e2de386870218c0bc3e480b09c327c4157cd1d6516f09cf27ad4aa5a70bb641f58ebbbf895f478ac2db352672c02969bfcfdcf1cd88100f51274f1a8b80095a8e814ad9b546d1c3d3e5b75253c8f35f9b7992e878a071593225e629f4fda39f26bec50084ef4845220f3ce24f823f7346f83f75bfc7e9db896c52129f2588394a302a08aebbfa996837b832df3090ed305a1d9a246eb4e8ecf911109129154d07992ddbfc5e7ebe0dfa37e904e7209d04cc0bc075fe0e11085f81c8ecdaf6f265ba4c00d09235d7983430b5dcc41be05cfb3b834765eb59e46e126ad3316b7ff39efd3c5cea2614dd9b5c51baf6aac612c96ff90fe5de2d38c4941b5fd8b218e650a6660e1b17580075dd00c85edf21176357c95837703573ac68ed9d4158f0c6fc8d1d682b329afc2f638e952e4d408ad0b3fba30179ad552ad2b279149c71421ed8fbfc8580486b176960fceb56611ecbe071dce903dc9a0bf030892a212f3d0b074d9a72f8225c218c9b1db6ea575e87a4ff66192ffaebeb6a582f0428062e8ceafec3058e0d5235e4d33cf9e1c3701f60493b77c5a2ff61d19c9b889ec49f0d97ed733cb00c40b3e9aea68f793dc4700c9191ab724dffd93661f20904a49ac726f96a13821c37cb38f776e5c25dfabb14a3ef51667aad7d349d2c7744de16f404dadecad20e939f8f5d35fdc6fefb4e645ac6e22a15e9d3d3b95a0e52b7faf578ce360a2e6af6af7f9adca3655bc0b96e15fd52c82ad2b3f6501bba19993d0dd6611aef7c1c0fa85ce67f5d07bd0c3f67bb6a5cf852f85415677ed0d46e7a067d5aeed1d3e996f191bb72291548aa579b9caf262a7e0e62bf29b2c2f854d8b6fe8f7807ce22cd47d4fa166fbf15cbb15b8691992d5d7622029990e013582ad1369ed1cd0e2316eba9cb7509e9575eb361bf5f567ef9346d7b2bf09855256fc0327e2eecc1921f115db89abd7636576013f178b0d1f541cae649afb89ec7083683b5d35fd6b6b9b31a702e1ec3cffe68c188af8964da04964fbf26f81bb18f8bca47806cb75dfc558f404b49c99568d25c92817966247dd24fc7fa805addc05ac4312eb5212784745c6597a4b34a4da9f5093cc5357b755e93738a1b9ffd34509c6ab0097446029167317736fbbc3ed0b38c4f0c29ef0f9d909ad3209ae53d43a802f515ea16bd4a3ab8f6c7ddcf3b2f0ca30d53c0054e21a17d18ff0e91de2c9980fc62ddb384624f59b19fa9ecfc10f91f12ed873961196e32f0c627807bad2d5a2ab7ce13202838e410146fab40e7f2a03f029239733092f930c6711d793acccc87504a1e1ff189863c068d1a2453702d466ad25fac25db3c29e6a9984fe03773f8f472e48940dcd001116b95518d52e6bd799877e9f6743a731e36bb1c404227b44b666bdf4ffe4ed3346a4387980c8cbdcfcbfb9c2ffdb6d1d1155233ae23978cb22aba117a724feb44e7f2d08e1804eda25d9c74359c3919482b0f01d2070c61090a4b7451cf6e4d1a54c366b9d0861e92ab944cfd958dab955e7415f925ab99528168e5ad27c652091fed75246ac9574cbe15d36664e03754b73b3ef6000b3a9873045609b2c8c2123e20612427ada128e74848e7773e14c71b5140833564fcfbb599617de00212fad3b8fea158aacb4b8fe3e451a6a00c3beee7d3140641961772e182f6c5f37dcb86bb77e8172569cd49465ad1868fc2c32e98543c383dfeb9f7915c04811120fa62788826a034959118e2c2836bb2b555512d8271020dd383c79b20a247d38b23cab395765a622aebc95e2524a844307aec40491441a3ae5b9796a0aa17cdf4333cc27c67e9cc329f0d59e44dbfa05ea73ef6ddbbb3b9a33eec810839128ada9eafa4ead9d6b31945324bb0e718de3865a0962c3e9ffb5820c47fce82dd12b8d5d1a9b1e495fd997554d2d63f929003854d3fa93a908a035c1ff571f3246e0d97b4a6a240b703a1b412191ad3b2f12febfd2a10b1e3fad69a8c7963226c58c89ab9d780aae150ff5be9ced955cd79679ee4fc8b30c250bc43906458b3f35fa3d0ff6287f3716600488d83e01bd7e1df5fe41b009b176dc56e6cab97ea552e209ed0f4c7218aa87423545828e98de702b2de959bcf5afbfde43fe9a250ca984e21f5053ca75ca92061637596b6c164f553f9f11fe18821f6a018595e1690dfa1536e2b45cb5847a570555b9b9b55c990c03b5d9351283fce4be738e599a6af96f7f0e6c8a1f5f69417e78114b28fdd9040cbb24d9bbd994f8cfd0243d0efd65a4fa8f1448d0f6be9e09d4ebca5f007e83148a56d568f46324fcd389933055afdb59aeda1f1f1f4efbed10929751b28e497df7a7e00103c8d1e1ff205b9d83731179258b4fc967c153cac797d9b8b6702dc86dd50c18044f4db52b6197eacba9d0aeffc301d5eda8c86d65ddaef18c5068b31db85606bd7c66055d7868b68e0a885b6ed5fa65acda2ea2739582cd61df775a030d8da1463427bfedaed5dd0e43eb153999f4ba23248010ab11ac78d1487c3b4a009d4275140255bbac77a26d293290f4c94b1a575b9e01c96dc1cb6cdcd3fbf05b6185f8be5b277a88e0b99608f4e51e870ee0870fe4afffa7cf968df7ec0b4ce6f2e8dbf6e5d85237ac00e8ec335b2dacff36232a89dcca65e789fd192ce6de2b3588329140268e14bbe9ec69a55b7f4eff69cb079c5e8a6b9a91b4418083f97ca32912da80910e49481b9f7dbb1819cf13f0c470a1aa9def63d45413dbbe0421be8d18cd9f24d8d04933293bd65865fb17217904e27fabf8af2d583069e72178aae266d12e7764c8f3afaebbecacd60c53a79be5eb4d2295994c8fb2f2d9fbaa356e8e56769f96565903c73b953f3b97d08fcfc80b45eddcefe80dc77df5d0f28e813646a437660eb7ab328ca4ef67e497c46dfd5563834587cc221e9d629b5d30ce75763e49a87c3e187c20d315678df587450705bcad6bec01d8a42a677ce30b6a832446b0d19ab8039ebc2bf288d16180b6de73aafc0b2aecdc574e014ff2d521a04cea0f0bcd17f89172dc6cb5fa83682b7354cfea416b66e10b49c81aef2b31128290d871df00c4e15184eeb8cbc316f1a09ca0d2cb8b775aab9a1b56c66149ef3bc3ab58f8557b226571c0e97c6c6301c7e5826f497869ff70ba54916faac4d3443cae602d2985346294cfd2be06266134c919313508223f0a915957abf4bd0229de84cb885b33f8dbd962cc62b3a1443cce9f3d5608052892d66f96fa3eb8586d8ec502967c2cc1ddf7a98dc53352ec69db0cbb71d5f3c2faf4a8fc15c0c79bca6ce9b6f6e426bc641f5f4b937938899ae673f557b320235e51f72a88047ec1d4ba55255fb6f45ed0f72850c863c3b25ec3c30ef34dc2116dd786aea2f8a9e0e1793dc02a57ec9dd8b25d25cc371e9cb114763ccccda0da791f4e206b39d46e316e4a16517e0bd0d0c9ad0d615a6361e032e1d654d64603a1f7f2bd8e751b00b665ec736aeace87cbd89a8c4004fa459a491965ee2e1cf17a0d286dafdf95414ca11ba8a8d9fb91a8800ecf7623997066ad634ce6943d26f869a57674676de9ebbb0128e8fc519eab05e052b3e92504986330e21774925d975322ea0baf9b16baca9348aa063807f7bae4900b3aeb86a430c6ac4ef038e83bcc6150abb256ab0c310d8ef9dc097c1deb098f56930a8dae7138d5bfd0aa9eee809bff9aedb3d5a6393936514d6b4ab90ce263f7c492406e569e999d3d0021891a7943a9c4a97c843bf450e6645f8059e51823ebc3187425bf51fa4998aec08ac9768175a3aa568aa5b857426ac4bd78b34947dda120f8ecde1e00f449c4eff45c96a8a36c888d9143cf4a3a15102bf5b22f46378e50b41aabcbd32d57c93bf73bf0947203281cdef40c02415789c256086e7cc9578e4c6c6e44798019e76f0be1769ec425ea11d0768f417b6c14a8fa524c8e90c0cdc357d37ea8af6f3fe7abfbcfe03419b30d5214840328ddebf5bc8a7267bd214334023c53c17ee7b81c36a49806a1664b79667684d89b98134d3743c9b242ae99c70329d244f3226332e9adb6f4af7942133c298cc409daff9a2e7e167381ac41b8c0756bfc68a965b2bf969259756fb9e2dea4dae978b805419809f990b1708bd02ad557b1465a09b6b9c004e39a6a7fdc6639fa63fdd91f339ff9df11f04f748762f776557b2ceca2ec1509bfa800d1890e43917d9a4b0b36516dc276bd1c43f6b2cb6deb4cb07e7ea84a9aefdfd66b1500ae9cbcf93abc9c5c4fa322157f4ae3e9173a6f358542625d17d236bd2a4051277a07e7d976367c71da67971d8d4b797a21c2602b144384f1187e785f86353f8e913e1cb7de18768efaad4f201d5dffb47895fc4d57a5f230745d3c64939cdcbf9fb842f3c5bdf09c8ee2991485979a6fb0dddb9e5e810ba9c51f02ef9635fb92bd29af0850713cb4b906015c2343ebcc4560238897a63dcfd2f8f3c7f15cd7499e5945bc468cf289da6ad0695c1a6ce3366f17c421ec8acb508e3420998611a88ff8704a5b54dc8b2dce01490d39ac90da8bac9f046ddee1880f62d5cba044d6c3be11b8cdf4e5c47029ae1bb84fa028318b2f9befacf19c81ba24c34ad4a9048366156f305cc2ae4bc5afeca2b71398d947dc1075e2343b038a7958bc3366e93d5d0326da5b05ea7885fbdeafbdf0fd5568ef9fa8d7030359aced1a0bc2e2f74d5bff10e98b6a36c2b812317b8715eb40a9c22e191d31856c585d96c33e9cb0edbedd7aece0fe3a662d89a97344683ca9a22c836b2fcbb422b08b52071fd94f9ff024c0b768f78e480fded9c81a0983f9b11dd195ab99fa4aa4dc78067089ecb281156817a9bc1e64726d9135f94cf678b8765cd64d4c6e3e8d1065f2c34e1f11a37cf0343e025cdb189aeeee85b98d3b9f8f831b7f294f7a8fd0270514dbb7886b9b17d8ac19b7261a4b394adb35fab81f22e6157ea3cb3c378dd4f4d302dc0ce94b9d9fe4f6bae14d8aafd8e4dce5b3898a3005cb47946d8f68f04e873053afb897076c10da07c240bacb8ca4ca4a97c593643431af6a644822126f45fa6739f6b6b59957a5b433cca3e48caad85e038e25aae6747d9ef8da50bceb56ce18920372a0eeed0b668141689f0dc880f81a51ff58c0a18497971248c841d818531233eb0283092e3a86bdb07cdd2f2ebed3b77b8fb02dccfa9f8978e4ac0affa5d1bf8e690a88ac15ffd6c4484fd71ba6e9d4c44a3d449cbddd6484519fd12b8c53a8ad58655135ce1af9b97be9e6348183b8fbc82092ece43e1c5e4bf257b9241e84817365a85fd091a6442b2ae6fc43ad4ce2d4e511fb3d5348ff830c51963e39413aa4b4eea2646bdffac2be20d3fc58ea75b10af9ed51571c3bd50c111dcb6780f849b59fc5f7a9f752c6683cdf0c33b51f162e7af4ebf4c6a06a2dddf37ff37051494134c8d2c408035861ad4e444e07848354d85a70883440b1020487b5803aa26475cf26e852c925cd5abd1d18f251c9eaf12835d7c7e2f5f7eef2c02181d3477209a0742efd51ad84179560bec395eea5b596a37a128dbb3f1cd4ad21fba3099aa92aa5b25ab5c823ae89759f5d7d0cb5e690bcdadd0c1b6407b77d665c978e807c2faec42953e207278ec64b99602296e606dabdfec78d889a58dd0f76abb7d1216b01b4e449ca146916989a4a99e894fb1db48f699f7be9117127b023449bd9c3e8dbd866dc41f83a0e39726bc42422bf74fd04754756ab101866cfed678801e088d8f9e89177ca4d950a3c283963d14290c05f550569d03f3ebde48c04f4d6d5d5e557913cb83548baba5d5deda2e04a5d019911c406c15209b3b7b031b2722d15f97b92baba7531e9100b0efb8484459ec67c9dd4cddd13219fda416566985b6e76a007797a153deb399b87be0d238c5227fdb535478a33f7c80116e6e91366f0e65dcb2cd257b1716b914355ea971d7c6ebd273024784859b684caf8c3f1a5c322a73742f949e996fdcd51722821cd83c92a57b08afa2ad90728fcdcf94b183cb557d59ab1031e935b8d032fc4ba88ae1010f3c179737cb7c69eb88860a39e9f1b384b02bc4a61acf423dfc92ebaecb3360871698b4e698f8a5af78ab5a654b3229bfbb17a695cf94f5da1b8720e1eb10262be17300f97551118585d1a8a5b5c1cc9fa857a3c972628de2ddd09f69dbcb4a947d3b06f70db8a17ed60f926e861715423929d3fb5a1d0ab86e533500b3dbee5da3d39bc1e0689dcb8e233184c84c70e685e17df7d65bd4c13ad52f56a274452ad45092aa56c38abe7ea236ef740ab909ba3ab83ef8fc4b9c51cbfddc1872bedcf6161b7788d0d9f6c4ac91b40aa69159074569ea606d07363e02d84b6e32fb31bb0f2be5e76a657494ce5d96e1c16cc36bf708769d1195cfc31752c15030e30ac10371470cf61fcb46028aefda4fbe0f82a008b4eca17f9c22be2ccc37d53ebec7bcfb649a2e9d0d108f9477bf7abf38fcefc6f376c330229da536d3a766f3224fea21a547e27ae75fdd2d0420bfdf461d291eddd71c3322287ae3f3cc815ce0ec72f78954429c03abcf8a9f803900dcd4fd50914196aaa12814dcc92ef1c81d85be5325cefd28e0057d2aa206b6ddc0e16eea859d2b9d3110b07b56654a494c3ba7c30e7b6dd1edbcdc0ff7124ffb5439095f92c5bdbba78fbc3c3db2ca388234819e5e7e5a32fe0e82f58f039a3b263b38c62faf26d7bf2f9072dcdbc2f15477e942461c90c7dc9d2e0e0951fb73682dcab60a944da5a02ea6561d54f0386bf40e3f7468dcbf8aa950b2abaeb24616ae88e4e2048401f0d80e505ed0c11b0a34e149db54c13e964579488c09e98bd2b43581c1de0f62815e980f5e96d550c38b8c1c747f4299bf5ba3b4cb5e496a01e992f9fe8e7bb913fdbd035b6248e18987ef0583448a74a302c8783d624e6e093e187e1b02953bc888baea60ac91bd9231516022a150719a889ec275a35491fb150dbbd0f1df5fa7fd71c8310ec61f452b9f5245a88cf1e11df55352069a9fff6c6b8378ce10fd07a34f7f32035d2f7f16131954547981395380e12c08d3f0ef80184bb6dec2fdb77d069d584c8ee79d39c2ee80ec83c8c40af0bd0cf8079f96590ed43b4ffd5b54e97e0dd92c066cb826fbe7438313886f7554e4708ede8cd3348fc73219b58ff40321b190a3f4c4ed8929ed34d52de06549413df3d198265e8d834ee04a3afeec999a616ef40b235e5d6ff1d9706cd3f7a18e0b284505075b5f27cb768515144d9ae4b1a61b9f16c837e34551f9c0bc84eff580ce6ba44c7bf3f4b6731f8cac3b354fd09a4174ecfca7c01ef765d3a2a4325ef5063f906ae2b6c2b0cf33208b5acea98930088a6ed498a3996915fbc43d13654280c198cdce96fc7185e8a6460690d5a8a10f0029e147686a7e998ca7c35a9585562ce0350ae4f318bd9baa74662da5e15138e88a5a33a218f7984af7fb2ae17c32d4dc687c912740564c373339544569737c03c3eddf55bed4f4d2dd6a476af46b8d1723e4c137040c81ff2548adb60d71519b66ede831c19fe07a4912203aa03e791dd8ac8c5c61e435ef6f4d513346d52bac03c7882ba10dbc1897c78be4f01325a6ba89f291bbf7aee2fb281654a16af8f4c86fa1ef436556124954014f7aeb693069c5504417f15c527dc99e3c75efa71f886b115d71d5afce61fe7a7cfaef28699440a349488a06c01045e839a6ac72e6ac11577ef1be676f3c63b493ee759102f8880413756b95e5b2eed6d65f2ab581f097f52870d57a884443db61978f13c5b65955a599c40cd0387189269cb16028187e38f7f17b008c4ef9490c6cc7584420ebee5b12f35042b68dcfa0efbb2592e073de9ba6cbf7f73da2d7c1bac26f6d8de63652035ab95cb37b73b13c349496a4a0d5eeb73ed00805fa2e8ad5cc07698a9271377ee1cdb5bed2835d008fe3f2fd2427750e9fb385989e87036f725915abb10670b5fc9a42cf286cfb2503644d19eae23bfc558c955f8ef508035b314889e0d16f17fd1c89fbad45ea285d9f6dcde1a30250c6cecea525ea9286c64c859ba4bafcae401c8520b1f910bc4350e781cb3846817496e7a52190dfeb2e932d762c188e24f27726affbfe551de8c2a33118802629e4489f80e905a05d742bb14dca833326662e60cec02a9a970d5eb5feaf2c1074f46164c263a17f1c3127d863976867e8640fb2c504d5d7dac9eb7f8b1ef98c3180fd1b0892914ff30b2a2bc3e39bbe370463638dc0cc85a0fe7f3861bf6655600c03c4ed0384711a18a34c32dcb24d358d1a57ffecc1fa2ee48d324fff7f2c721443bba5ad568d21886512a51999805d0da5a454acdc289c3c3a0eb33b61d1ab0eeacb243d21fe83958678089ff27a0585097271acc8d8a14d7bcf55421229888d331eed13c391bd9d75b97a44c8799acbc3ad05ab862a333336993579588e531b71f5bbf31d96a863e264b9e46ba5964589bbbe6e4e524caccee1641d7654805731bca55c7d41a0faeb3660bce49b9f963d79624a96ca68f18062e0b7424d727df6f2fa3218ea90e70a525284dc583db0c4e95c57239379945e00a5acd4621e533d54172900883d46ff1452b5736bea7c736ed7dc67ae403f4aebd1cc688edcfc59cb4347a7a402a1294401e909f396ddfa22558f50511e83095ca1ff12495cefdc30e3316da36a3004c46974d35aeb60a1597f9f4e49dfbdfc91fc9145935023eccf82ee87b64d90ee9c4e5c6af290f4b000c143cc1ee358fa2b4c3b08c7eab5e067f90939a9201d722b4043ceeaf3e0aa38286e6a9eba254f87364bce35d05cbb6eabe3efa6774b737450f9cc5789ad8169b21e6dc5ccf260868d32e02816321960c44d66db3d7951d0f4e33024b3498d82c2b4f494eb22a98c519029cc2d5b8bcb851934282cc3414b1f2545e7b4da047a759152337c1c44f0dcec27091d22fb69e7f2d5d00a6cfe3fcb7bbfe3f25e543ca0264d59bbfeba699151e979b7811ec4208a7df2373084ce6e7bd7179fd3aaf381d500a9cb4523a5b6d41da54f2d5e39e3f8d08ec35df236308f15671b45e186da77521b149a24623d6c021af74b98a6d12b4e7a39cc0a545c55217cc4423dfad8d800dd648946db770e4e0710fc8deb6f027b75f6054a2d583e8ddba23769bf03e73efbb5e18aa2239fd92c0fa90a9104967fc7fb5fe9bfabaea8e5ee67a2fe81a51065c8e856203a8b75fcf99dc189739ca0db7f8dbf43ce81257c2f8e70d76f3e8445f725c92d98da9443d6d934dacc7037128692372fca053f4f2937c7cf8d2a012453ee3071ffd55cc87b3789999c19c7e22f648a4a2a05b7ff4829b68de769dd49ead7368bb50a210adbfdb263ba04b2891d5b646c42cb0d7ea290a2f81d4f41273fc3452d6ce772b53d1ab6f0f1885c41b64edf78322889505720880a16cadd7c0e2bad6d303829d8441aba9685b588cc571a05ba10c57cc99ead120db7b73045d183b28974369afbb38a5066d75210b8f3b736c20508567354ff008728a8c99ae31e24426c153799bd997017debfa6167c00865ca2dd6a8fc79a2e326f9c0385483336d9e23de79473decccf956594a1018adb1ad3afc9a99e9433a10ffa695784e293f230e11f2a563b22c372e21280a04b07af378f769fdebe88a7186abd5758b15682b3da3f71fb847b4caf4da95bd41b1169bd6fa653489d7c71a86edbffd64332258b488b43bf258e4bc7779ccd77e7e524b6c9718cd601549c7606dd94085c8a148b73b745074148277cdca1494587834115e45246e49379c9b1025d560999e51a4d8719a95423524a758bdd256abedcb2039f514cd122e7375993540347248a16e2881cf68f81e97473232fca120143c439a8faaf204a5bb0911505e1ba8c5ea3766c685ac9ec355664b381cdae375e067729bec09ef5f4e91ae9cd48b69006d2b3254ff6d5470c31bdc5fbf63787112a73ab886338e8c1b47bf97a930e68e646e071ed9e19bf523ce7067124c7d1b885c9b86689a780f641b219580c7a70958fb714be8b70466b26b5f66c9497ff587a80e9d225c81aa030e7667fdbabc4a28543b9dd3c6ddb7d2b79ec29cdbc28f7d7736d1c960784eb3eb00073af41c8de3fc597ca0c9346ac5e483cd26f6bed7ad51ea8530b3591e0b29ab5e6ba3926e7857abf4a30b4e4f3369a9a6257413eebc3cc200d2a7a56b510ad80f19ec5e6f3e1e5eca99ef248bc0203c3f56bbfa8474cd2fff178941f35e88db9eaed68a953993f79cb4ccf5bf359ef769e5ec0307c2d2491f75f871184110be27d91b745bf4748489c54f3a0affe912d16b01af6e402d22525bf4f0ac37b7b4e0613ec92deb897e51e160d78f1a00fefd8feb94edacf947d531f87fb9043484bfb530a6f44e340b5dd847a55da5fd83ff08ad7edada846fcde457d5949d7af29ee555f85674e5e95acd8725976e209067eb4fc98ce853363feec67da011b9b21723a7e09700612a041681cee79969a6c8fbb756d831b114cbf936bab7b57f26cde5641257e2c47ee662e2d001ea6447cfc6e4ac8a40c7017b15337a99513028887b384b3da7db66befcf42bb04cde5b694de15658358e1c9e84b65843573c67a70b415f29b5dd4abcf90de74d8487b4a65a792ad55ed6efb113d0c0d7a58081c610cb375bfe2aefa37f72a18aea824b682ce6e4a68e0f5bc19d4b062faba1882f6b7643c1859578252d484e6a1c465ab9533d1cdfe58c70b4a65cc405b5f55bdf9af9b53990de08c4149978e19de81eb4b8b5f65682f0f27dc7cb3774db822c04ebd4889125d7725a69ff620f40db95419e195ca8c4d0ebfbdda0778780900b145eaf7d8967d2f6d2232a7664756ad32852b64d187b1141e12b36aaeb5d7e30d304266b759e83aa56ebcb097af1c577f7f55835b156b7d0c1dabaaa9395074c84911e607119a3a411fe5af2ae0c3ae9bf875f5ddb4684b4e30ca78d87b85455e2a7867ab2daa57a287021d5898bd42593a86cd76531ba788b1a654888339b56e45855ecf09fc23c1d148e27ffcb21be5dfe92aab5a9244513a010ceff785f5118fa7508e664bc4810b92a46ba94837eb29adf3e6f0c66090d0fdf1cb422da5cc7fd1b6b5248e228a0d3d2c31daac12ee99da720ce3c99a29b0aa4e416161d97f134da8363e6f757848caa4be6395de3c7c7188b39235ac4f9d7ca934a5501d996de0e654e6e606acf878e355804bbcfce4222d530eb4c4aaa7b72c5e6a39cad255f3d9c8417477e1a0d663e0b6b119778cb520e629aa2a86d105f83be44335f700988fab166d89da899d25d6f5d93ce5f8ca84b61f1f7e66e58496bc576e0bc4df3553711f830a0cf8c84a6ff832f6072e98fd751e939e9e462e5252f6a60acbd23b843c93c1ce33f8b8e2fb2dc8dc36ade3877f677dd6007913b003229bd3a2ad0b0e31f68320eeee7cc34841cd05ab35b6df634480135ab9c1a0d847cc57c4ae060064d124fbda5684ddfc33c825f4e84a0eb787ef6a1a18ee3ca6e2082e8c5f363bbb488dfb1a41eb401159543b03b5bcfe235d9f2e16ec04111b6df7a73a2022b3cd2b90d49d342111539b4b7945a466b6525afc670bcb69d352764bab31121a4ac1220174cde99883e7a6c3d10346858e2aa89707c3262e486a82df02742a20372dc171d0ff35311c0cebf9f2cf3bcdaa18ec5aa528af07e4428a65172f04060d3bea16c252a60359fe78816eb97256a896e8111697df25d47e4a11da2547b116593d5e5d854c89f85c7330cf2c0a780aaa44f2f8a4a558fbf1083e66bfb62bad90a60187adf79fcbcb66d9f54155cc15dd3b67787346b6ca4146758ede08f4b7cb0a1ffbd8dfac0c347edfe2825662174bf3570309f167aa2af0ea5c5502b9688b0922f5e9e5f9a3d02219e674ca2f3a8d3fa5c79340212a19c68669c6ba7625b50c1876baac1ada731ab029d9b4b5c5013f12a5730829f802de8403ee7c15b27c904d76bb1fa8de967bbe5cf5fe84709b791997df573099c7a519479ba04a80459013844994ca23715d315c302f0659352495f1173c791116aac086e8b6afdc64fef5d84cd69cadea17f33e99e48a38bdfc7dbcabb7e5ff7b201aa99516d672dbe45a2807d361417fa678da9ff37b36ff046339a7e0f1de0bde1daef7484d4fc64dc82d4acf50a04831467716a997dd5798de84e85f3876540e822510570d97cdb095e101f13f4e1406f050cfc02177d5c451095f8d601a550ab6bfd71873080f0e9f3067c465dbb4cc8df06a23de295fdc003dca8eddec9dc42db3b33874498970ab4bb91777659d64f6e757ae45011ac5d542c8d7bf1c690272746986aa6115639986e8aa028da23cfd34710d5ac837f5d494a48ddceb787879fe22eda212d6e9258a754d791a2fdc52701a0aafa686b94c30afd664c85595def2f0950777e125c70ceb23f9ba7e6c18d1237dffd9afaf80ad1d52d3e1493c3909fdd5c8d0669ad6331475e07e1b90eadacdf9125b8e469bfb17d7a3d951cc3d16b3272739f013241dc39ee5df3857fa336e20a3b14f3801cf740e387e8f4377a41a52dd727f26500dcbc648d37da3fbf03eab75f4c924e5a1da2816d0f206489ba46760fa540bcb393a1f73e1a5c879ed358127decc38ecf193a9a9ad145852834a9893d9cb7d002645067c905e1d9de7ae1d0d13443d4f088bbf6bc68ddd47f457afd3f876feb814f5363aa39f85c58a4f8f2774e2b79274b4089507ba8b8bbd2c2be3ee3395c84949eedcfbdb2c55f3fa4c548bea1f271a987c5c0349a1dab8f45f9eaa87b1d337f4592211946c426a6f9c863182a68f1a2927e6570e33f437250a6639351a877b4c609add2bb5fe5bd75f8cceaa3de7fdb3b024eb85376789c539ea63cd7a4ba85995aec69bdf5fb5cadef0bada026927d438f36c12d96c25e6c5740bb7ab005f4ec1c650716a73b6719224a5dc53a495dcb4c48b5ec9c2a755ade02d5c759c3e50439855e44fc39a5917a7127e62526f61737fe8d28aec9ff8069394c46f5b37b40764dd2dc18b048367151d0034bb50f8dd152bcdaa89d0bd6a15eb5a928d2fb060da984b210c830ae821532452db5548680f76c56d9eaeb22886500d70658847e1e7cabb707615fa4212de68890e61e3cb96254ac528cb589210404703bd21924048626283ff7740ca1e6d5f4681c78e4af7db0eb6069bdedb9627a186901afed8a1ae2a3409c42e11c6a64853863ff8a60d090c67aa796636553b76e7a30918fa28eaeea3863bc580c39ffe032c3aec3cec1162c3eec303e6d041bb7166abbc68584c00669b59ca85b67e65ad1c807ebd5ef2bb8f69020622c366b446dbed93e168093f332fdc6e00df738d1a0a41e92be9e3a5dc6ad41754db2a7cd9e6b2aa0323dc3d0fd2aaf48817baf305eca36c1d55c897b6d44a4b6c042656d5b3d7958687c30775a2df6425a8f700ff5f84617ce060a282864178e8fcd431c7f7d6649df1fe352f50c818279453e6fc40937b3dd5c89a563d174865cf51169c3cd327a27923c1e8e61700087f4268d808d4fc25f92ea23bba93e754853db3595a42673044d594dc3ac9a53feb900ab450edf44d9a2d46428cd32a43de0c4bef4bb51ca807872b68103c0b514605a985c60c453270a6da78b03e20c14c1e6555667e549fec22617b56de030dc55d5f658c2d4d8d9b1e5d3ee7e6fa9970e9fb488a167f4fe2e1a46c2889cadd3c806fe7cbe93b27924b579a5604716e5f1a4d763b62b722469814f778a95feb7bd1cdbcc4514ef58efda06f8f05d7e24e067b0eb5fe2a679c119bfb54cc1489a199885de31adbc20155fe9fb228989b15ea2ab07a7deb954ace9cf6af822a740c76aad5f53de7d53da172ecf1b433460d81a7350820be22920317d97b2a9dde5ba66550cb5776eb010c3e74c3f57d28f722fc81508022e19242bc96f974b0e68e36e67b9759e873eacae3f806f354873132f3c2d91520bffd2baf5c074798f65c29f5697a2a76325985c37ca80c048485bfac669d3a0d4534b64e25f9c989406d6e9f99f9d6cfcf8b5c4c5b126ceb49ac570977ec7198e7af44de63596ea9d54c02c0cd1a0b872b792ae31667fe91af27fea184a8799d265c61e7d7ad740114d811a882b7e5e0a29c4bac28f8f0113f2ad5a278500186bbcb0acb1f21c20cc6f58533e30b0fc119536cbecf7f1f0cc5f11fd28d7cc7de536dd96adaacda4986556f1bb8e6f62a38cca455458fa6a6549391f895bf5b957e31757432f830e0f2161364cbba898ad9675d9f1a535f790b475ddf40b324de593d1bbe59a03c38234bce4bb95c8ce1b8668b89253f36d756a52ee4db42148879aff213b889a7d4b5468408133b448a98b06f516ac9e791cbc7a2a55e11bce7ac7cff3fcdcf7a1792335754153a700af60e13e7a5c9c56a83810b7a378c570c8ee73921c9c9a70052e7ed6fae054fe27e70791c96f83012b31258af675f91e8a4b0d5e36846b4d4501bf2c2c79520abad2bd50841eedd011a57522803c754e504e3b538d669b0eec035becd76e92d0fe263512c7548af143aef8fa2a8bc7a9d8707905fc4faad8591a87a448b2b554ffeb0645a811a2ee907f7a791b83151fba4e7f008612a0983b04290a3cbb67b35000d1c068da4c8daf04ac034716f9305e4f1fedc43e2e3f687aa28912e9e775712d9a6817285cc409a2fd9e36f2e0dd94becef39e0052c5e298e247ffc66e882476030a4173677b7922b9aaa13f1d5dab71e178e70660f30ae0efe1041c626f0982e1066eea6fe4684cdc6e3a74874ff194858afb08cebc760767b21b5feca8ee6461a9e3e62aba7374f3d2494168801d5c1c0df721988012fe215626fb49aecb2f307592ac2d062779626d93019993288d4b38ebb2983d10dd3cb50f89c28e107dabf4680c15563e773579cc251306cc9f5d48a966d657806ed7a2666691f677a43338b91761f5a2cd5a39b622401af9c1e738eb076bf1a2888c067cfcdd1ceaeaed24fbe91c3ec8dd38899e9471bdebced7bb097e22d9995c258b662dfabea54185726b3c7dd0da90b5c85ab0cd9f143fabff6c1bdc57a062761be59b5b922bfd9509744c779eda6b7619fe7e5f043eb4cc38aa744ad1490da26216d60047ffbf3c27cfee152e17de4bd80bf1bab583c1cba713a89273b6012f90d42285818a5996b499f86d1a20f7d91</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Book</category>
      </categories>
  </entry>
  <entry>
    <title>任务和返回堆栈</title>
    <url>/2020/07/08/%E4%BB%BB%E5%8A%A1%E5%92%8C%E8%BF%94%E5%9B%9E%E5%A0%86%E6%A0%88/</url>
    <content><![CDATA[<p>了解任务与返回堆栈的内容，对于合适地设置activity的启动模式，有很大的启发作用。</p>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>任务</strong>，是用户在使用时，产生的一系列activity的集合。一般来说，当启动一个新的activity时，系统会创建一个activity的新实例，并将这个实例放到一个堆栈中，这个堆栈即是<strong>返回堆栈</strong>。一般情况下，在第一次启动应用时，一个应用会创建一个相对应的任务和返回堆栈；同时，该应用的主activity也会作为返回堆栈的根activity。</p>
<p>返回堆栈的特点是，activity遵循<strong>“先进后出”（也可为“后进先出”）</strong>的原则，而且不会被重新排列。</p>
<p><img src="/2020/07/08/%E4%BB%BB%E5%8A%A1%E5%92%8C%E8%BF%94%E5%9B%9E%E5%A0%86%E6%A0%88/1.png" alt></p>
<p>图示即演示了新activity是如何添加到返回堆栈的。当用户按返回按钮时，当前activity会销毁，上一个activity将恢复。当堆栈中所有activity被移除后，任务也将不复存在。</p>
<p>Activity和任务的默认行为总结如下：（这段官网的描述很详细）</p>
<ul>
<li><p>当 Activity A 启动 Activity B 时，Activity A 会停止，但系统会保留其状态（例如滚动位置和输入到表单中的文本）。如果用户在 Activity B 中按返回按钮，系统会恢复 Activity A 及其状态。</p>
</li>
<li><p>当用户通过按主屏幕按钮离开任务时，当前 Activity 会停止，其任务会转到后台。系统会保留任务中每个 Activity 的状态。如果用户稍后通过点按该任务的启动器图标来恢复该任务，该任务会进入前台并恢复堆栈顶部的 Activity。</p>
</li>
<li><p>如果用户按返回按钮，当前 Activity 将从堆栈中退出并销毁。堆栈中的上一个 Activity 将恢复。Activity 被销毁后，系统不会保留该 Activity 的状态。</p>
</li>
<li><p>Activity 可以多次实例化，甚至是从其他任务对其进行实例化。</p>
</li>
</ul>
<h1 id="launchMode"><a href="#launchMode" class="headerlink" title="launchMode"></a>launchMode</h1><h2 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h2><p><strong>Activity的默认模式</strong>，这种模式下activity可以多次实例化。<strong>每个实例可以属于不同的任务，一个任务可以拥有多个实例。</strong></p>
<p>适用场景：大多数应用场景</p>
<h2 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h2><p><strong>栈顶复用模式</strong>。若堆栈的顶部已为当前activity实例，系统则会调用onNewIntent()方法获取已有实例；若栈顶不为当前activity实例，则会创建新的activity实例。</p>
<p>适用场景：通知消息打开的页面；登录页面等。</p>
<p>反面教材：<strong>微博</strong>：在A用户主页，<em>不进入单条微博详情</em>，点击任意一条微博的A用户头像，都会再次进入A用户主页，即生成新的Activity实例，进入一种“俄罗斯套娃”的怪圈。</p>
<p>正面教材：<strong>QQ</strong>和<strong>微博国际版</strong>：同样是在主页进行以上操作，QQ不会再次进入用户主页，微博国际版更是有屏幕抖动的效果来提醒当前已是目标用户主页。</p>
<h2 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h2><p><strong>栈内复用模式</strong>。与singleTop不同的是，此模式会检索栈内所有activity实例，而非仅限于栈顶。若存在对应实例，则调用onNewIntent()方法获取已有实例，并将其之上的所有activity实例出栈；若不存在对应实例，则新建实例。</p>
<p>适用场景：大多数APP的主页。这样的话，在退至主页时，之上的activity都会出栈，保证了退出应用时所有activity都会被销毁。</p>
<h2 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h2><p><strong>单一实例模式</strong>。这种模式下，activity实例会<strong>单独占用一个栈</strong>，在系统中具有全局唯一性。与前两者的区别在于，此模式的检索范围要扩大至整个系统。</p>
<p>适用场景：呼叫来电、闹钟响铃等界面。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>僕らの手には何もないけど、</title>
    <url>/2020/06/19/%E5%83%95%E3%82%89%E3%81%AE%E6%89%8B%E3%81%AB%E3%81%AF%E4%BD%95%E3%82%82%E3%81%AA%E3%81%84%E3%81%91%E3%81%A9%E3%80%81/</url>
    <content><![CDATA[<p>歌名：尽管我们手中空无一物</p>
<a id="more"></a>
<p>其实这类博客，严格来说也不算是在学日语，只是在学日语歌。我只是对将日语歌词，换成平假名和片假名。这样的话，一定程度上，可以加深我对这些音节的记忆。仅此而已。</p>
<h1 id="歌"><a href="#歌" class="headerlink" title="歌"></a>歌</h1><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="430" height="86" src="//music.163.com/outchain/player?type=2&id=32317208&auto=0&height=66"></iframe>

<h1 id="MV"><a href="#MV" class="headerlink" title="MV"></a>MV</h1><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
    <iframe src="//player.bilibili.com/player.html?aid=2361621&bvid=BV1Js411U7d5&cid=3691844&page=1&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe>
</div>

<h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>１</p>
<p>きみ　み<br>君　に見せたいものがあるんだ</p>
<p>こどく　よる<br>孤独　な夜　にもきっと</p>
<p>とお　　かがや　つづ<br>遠　くて輝　　き続　ける</p>
<p>いくせん　ほし<br>幾千　　の星　を</p>
<p>うしな<br>失　　うこと</p>
<p>わ　き<br>割り切れぬこと</p>
<p>はじ<br>弾　かれること</p>
<p>かの<br>叶　わないこと</p>
<p>　　あが<br>でも足掻くこと</p>
<p>しん<br>信　じぬくこと</p>
<p>うえ　む<br>上　を向いて</p>
<p>ある　だ<br>歩　き出すこと</p>
<p>ぼく　　て　　なに<br>僕　らの手には何　もないけど</p>
<p>かわりに　つなきあえるから</p>
<p>　　　　　　　まよ<br>ひとりきりで　迷　わないで</p>
<p>　　　ひ　　　て　はな<br>どんな日もこの手を離　さないから</p>
<p>２</p>
<p>きみ<br>君　にあげたいものがあるんだ</p>
<p>こご　　よる<br>凍　える夜　にはいつも</p>
<p>　　なに　しんぱなる(?)<br>もう何　も心配　等     せず</p>
<p>ねむ　　もうふ<br>眠　れる毛布　を</p>
<p>わす<br>忘　れられぬこと</p>
<p>た<br>耐えきれぬこと</p>
<p>すべ<br>術　がないこと</p>
<p>うば<br>奪　われること</p>
<p>　　きづ<br>でも気付くこと</p>
<p>きみ<br>君　がいること</p>
<p>まも<br>守　りたいものが</p>
<p>つよ<br>強　くさせること</p>
<p>じぶん　いろ　ほこ<br>自分　の色　を誇　れるうよに</p>
<p>じゆう　いろ　た<br>自由　に色　を足せばいい</p>
<p>　　　　　　　　　せかい<br>ぼやけていた　この世界　を</p>
<p>　　て　あや<br>この手が彩　ってゆくんだ</p>
<p>３</p>
<p>みと　　　　　ひと<br>認　めてくれる人　がいなくても</p>
<p>　　　　　かたが<br>サマになる肩書　きがなくても</p>
<p>ぼく　　ちさい　て　あした<br>僕　らの小　さな手は明日　きっと</p>
<p>だれ　　えがお<br>誰　かを笑顔　にできるから</p>
<h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>如果“君の日本语本当上手”的话，那么这段话请大佬自动跳过，若有兴趣还望指点一二。</p>
<p>在通过“一字一句一翻译”对比纠正发音的过程中，发现有些单词在结合某些单字的情况下，发音会发生变化。这一点在大学上日语选修课的时候就有了解，只不过当时没认真学，不知道这些变化的缘由及规则。</p>
<p>比如，“孤独”读作“さびしい”，但“孤独な”却又读作“こどくな”；“向”单字读“こ”，“向いて”又读作“むいて”。哦对了，还有“もう何も心配等せず”的“等”的读音也很让我迷惑，我用日语输入法没打出来这个字……</p>
<p><img src="/2020/06/19/%E5%83%95%E3%82%89%E3%81%AE%E6%89%8B%E3%81%AB%E3%81%AF%E4%BD%95%E3%82%82%E3%81%AA%E3%81%84%E3%81%91%E3%81%A9%E3%80%81/让人头大.jpg" alt></p>
]]></content>
      <categories>
        <category>Song</category>
      </categories>
  </entry>
  <entry>
    <title>牧场物语：重聚矿石镇个人记</title>
    <url>/2020/08/25/%E9%87%8D%E8%81%9A%E7%9F%BF%E7%9F%B3%E9%95%87/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉，密码不正确" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">这里有东西被加密了，需要输入密码才能查看</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="fd55bc54e38bd5199cda90154a9aad1b63a07d1c26c4b3603b64c974a4b70a94">c8bd79c51856d12e53d92667dc5fb819ef0ba5fd75ea6fc71333cb1e7836123cf45d1e285bd20de89b97770c394db5462dbe890475c7568e809cc2e7285eb9aada3dccdc746d084651b62f9286f98d28ac616bee88e7ed322e3ff1e2b1f2e093b79764b0b3c40981319c90080ddfbe45e9804d566984756359e62b7a726d133eeda412f1aef6bd1a2119fa7c7d6f641ce4ca0586cb00c24f96536c988c764349527917d51fb9e1c3f6aaa5be07ec6f54489bf471edc1e0bd27df697ffe9faafa2ad3cc02a7dbfc8aadc61b1b4afcdd7d1915e62aaa4650876003bcb1885d01b608eec8f83674746b839743c113d584c394975564457334cc6c301b5f87cfacf695acb6ec2235e599aab0614a829fa433280437dfa77debf14111d1ff46e976e4133297339d8abfdb30e9f3eb86f943230132e67b7690ecab5f6924b6196cfb3697d2709509e50ac25abeb65088d82c04a338c398b8a4608a0bd5d938291f18293f19e1be4dc54af0e750ddaabd87a4f71899692e1d3490dda597e319e9a91aed5eedd64cbb2d8cc268fd8a6da8fec471a13dcf8beddf107e4b6cfa072a2f2e8ef033ed209c4bdd55143fd03463426a6eb93bcb27cd4e5ac4c416ea9d62a6f73e52e953c8f60d8ff0f3f82a301b03ebde59855de93c1c5fcae7d621d0746b153d23ac9ad8623968b27513eb3275ecf12b3465dd8898fe46ca2d7fb7dc1b0781178cd9f16b48c0d84cf0d310d3f7140cc835dc1c5f2e55fc427e288f7b92fa13cfe12090337e054b06a1322547ed6e7ba36d177ddfb9e69b9351ba3b66f4b0fae9706b3a59bfa4f45c39402b02d9f33b50a71e4fa872e8caab9dbb1fd42100d2c1d966fb46b83a393dca3b966a931e48c5a61af2d84885d56a32e31a144d747c4834fe38394c2c1eb426b2481e6d5f32ef83c7b14c4feab8df5d6828d974907ba358484fbb79da53bf221d28e4ec8deabafd2b2776ad1e08ba938272553fb004fc77bc50cffd4eb2e7285133e203695ea40689a5505761258b38868797c3d0fc33fbb0fbd3b3d0466c8c807b05ef7ab16ccea4da8322ca3a090876dc80e6ab4e16a425064d5d7127a5c0752cfa1c3ae0648e9cd3bcb5e10623794396f458a3adefedfa8aeb98e5d6ecc43016559d0884f26803554fea2798087033bcaac943ecc499399d34230287a57990348e739c276b71b4347852379819069618683f4e88be4cd0b00b73db243cbd3ce63463afd9f5f4343a35ec3fb633600f540dbcba7b4137aecd76ec6ed1820ac861e002d235bc21f5f38666e42e468a38b83e6d57a30675c7f8242b5036dd1fccdf643778f54d795a82de39a7a620388742bc42713c42478b4e2061200cf8d4b0abcefcdfa28b1d4eb8d9a1d547b2a07b0048a527a516e5fd24955e4820a66899fd7928d7da112389098368510a58b3fc9b7fc64b182baa5d700214ab12fa4f94732d6ff8fb1b29611a0c54099a0497eb7c552a36a3afdfdf6dc136cbd710fffe8ced2b7b87f1c74896b80d634f5ef2bbf67932144945990cbbbab47ffef7f336fe4a7f2a2ba54ebf46a37e5916092c12b8ce8ac351d75d4a5ea4c3e3c8c38c7214461e63f95ccd0e1225906f19a558f686acb38b6b303974f5d7cabb112dfb523dd036b25cc9fdc5dbf9c22343ad82919bd332e9d415d9ed67a3dbd00644f89e4f4a95e8741a5d2d98234a8066172d7fea1af477b4baa82e8000c9d82c2671bdc575ab4c9746e75d28ce858f76a8327a9a77908692b57d4d0c048a386b8a72ef8258efe0c9c05af95b3dbbd9ef399cb212f3784d36444eee1523e04dabd6953bb90d4675973dcf54e5ce40104f894b1709fb6f62ff81cb9369a4191b8f1e2bb64383e171422d4451be141f0bdcd0753ebc634b8d5bd00d585c2a419a00829dbb205f6b2beb9047952f3020658e4986f975169450ccc50b91dde6d6a81bccf335f2cfdea0e55f0986678e2a16ac23f73a97e037b6c1ce5868fc834ae0c1af17c070c493c4d63f5e926394a144bfc915b46f9ea27bb6b670d90f20ee565507ec76a5a5540ea6f73e325dab55a707b49c583579352fe4bb0feb0b2d8d69fd38777a53b98e7b383e5b23db314ee926dd99dcf18f71c01d19ca74902ffc8c60eb3a2645c59f581aa446669d36474422164dd00dafb697e141f5b5092e69ddcb7131da777d9432114a95a40582eaa30c9321acbf175611908505996adc3065aed75e633941f37f41df6dd840e12ae49b18e41cf77d3ad3d474f7f529e46bb176ace249166c00e76db79c6617b7c721f531a7669a6df0b771d8ad19bc99b4c113dd8b8a4de3626dcc7c4a6abc0797e9d0b08042f807299f995116a6e4256a7daf427234788c34e4fc17ff53fcfcf28c91ce6b280f942dde19a666cd73959e8eb462de53fc5d61aa94e724b6dbd379a26973d13d6afa53356e547ab4c5064fb3ff72aa59b435699f27e1c229f68279717a1e679c0909f9737395e328ace5c294c8427552bcdf4ab4b345aa50de8ccd5932363bbad6c8f37986cac2ceea5a53f8ad706ca1c9da42396985b3680fcf786306ef99a4c4045d3fb743c0f118b0f9656c2005dbc6d902113fe1fea1d04ffe20a65b2f69f40e13d1a2c9b1cb949688bc6232dfa41bfce5206b66292008342b751edb099556d67b2547be779b0fa5414a240d93ce87e68bc6aac3cf1b3f23626201ffae9015e046faeaeff20ed5684c973c7e40e7429ad7df1d1959436138c9989e6c33d1c4bf935428d0d201b6675b07df8b682179f39d6fe054ec817e4fa0c20aa01d548324fb7681aa39cc82ddf1f25d97e60123f98f252c9423cec8cca168fd5595f18767cf67f85d432b38997e607cb5ed4b6dc29f5ccfb10b94abb31a6340113087a8eb107cc66be7f321e74faa35e16deff6969edb640f16bbe33cf8cbe11d4e5a12f7d350f99103677749efccb2f92c048d583505a6f611cac640f0ea8a7ac8f20f34b327e0d135c423479918318efaf45b2c97033a0ffe73eb67152e39aca3091c3c9944ffcc8980009d2db913110f13882b52208f057635707f87aa0eeb7975f6c7c2d139f4a72c97a390f7906aaeb543f08812887fbfed1d92732e09dd601a5ee6168c2aa3c952ee4e1bf55282d4059b665314a5ec005e7e8a600e6fa69befe864d05643e50b4e71f1707cc32d10de90a3551e0eba3831886147d71f17bfcf59926326a919</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Game</category>
      </categories>
  </entry>
  <entry>
    <title>Android绘画学习-Paint相关</title>
    <url>/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>想做Android动画的时候，有的时候又需要自己画一些图形，比如自定义的进度条这样的。所以，学一些基础的绘画代码也是必要的。</p>
<a id="more"></a>
<p>我这里的Androi动画学习笔记是从CSDN的一位大佬的动画博客教程那里学来的，其实很多部分都与原博客相似，且内容不如原博客详细。这里直接贴上原博客，原博客有更丰富、更全面的教程，以方便大家学习，毕竟我自己的学习习惯有些问题，笔记并不一定全面。</p>
<p>原博客：<a href="https://blog.csdn.net/harvic880925/article/details/50995268">Android自定义控件学习三部曲</a></p>
<h1 id="Paint与Canvas"><a href="#Paint与Canvas" class="headerlink" title="Paint与Canvas"></a>Paint与Canvas</h1><p>Paint是画笔，Canvas是画布。画笔可以负责的，比如颜色，粗细，透明度等；而画布负责的，是画笔在画布上画的位置，大小，形状等。所以，搞清楚各部分负责的职能，逻辑会更清晰些。</p>
<p>参数稍后再写，先写怎么能让应用运行起来，这样，在改一些参数设置的时候，就用不着只是看，可以亲自感受变化了。</p>
<h2 id="基本实现方法"><a href="#基本实现方法" class="headerlink" title="基本实现方法"></a>基本实现方法</h2><p>1、先将布局更换为FrameLayout，并添加id，用于添加视图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;FrameLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class="line">    android:id&#x3D;&quot;@+id&#x2F;main_frame&quot;</span><br><span class="line">    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">    tools:context&#x3D;&quot;com.example.administrator.animationtest.activity.MainActivity&quot;&gt;</span><br><span class="line">&lt;&#x2F;FrameLayout&gt;</span><br></pre></td></tr></table></figure>
<p>2、创建一个自定义视图类，继承自View类。在这个类中，重点在于重写OnDraw()函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CustomView extends View &#123;</span><br><span class="line"></span><br><span class="line">    Context context;</span><br><span class="line"></span><br><span class="line">    public CustomView(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        this.context &#x3D; context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">        super.onDraw(canvas);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;示例代码</span><br><span class="line">		&#x2F;&#x2F;设置画笔基本属性</span><br><span class="line">        Paint paint &#x3D; new Paint();</span><br><span class="line">        paint.setAntiAlias(true);           &#x2F;&#x2F;抗锯齿</span><br><span class="line">        paint.setColor(Color.RED);          &#x2F;&#x2F;画笔颜色</span><br><span class="line">        paint.setStyle(Paint.Style.FILL);   &#x2F;&#x2F;填充样式</span><br><span class="line">        paint.setStrokeWidth(5);            &#x2F;&#x2F;画笔宽度</span><br><span class="line">        &#x2F;&#x2F;paint.setShadowLayer(1,15,15,Color.GREEN);      &#x2F;&#x2F;设置阴影</span><br><span class="line"></span><br><span class="line">        canvas.drawRGB(255,255,255);</span><br><span class="line">        &#x2F;&#x2F;画图</span><br><span class="line">        canvas.drawCircle(200,200,150,paint);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、在Activity类中添加绘画显示代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bind(R.id.main_frame) FrameLayout mainFrame;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mainFrame.addView(new CustomView(MainActivity.this));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行效果如下：</p>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/1.jpg" alt></p>
<p>我记得还有一个实现方法，是在布局文件中直接引用view类，不通过addView()方法也可以显示view。但由于忘了一些细节，没办法实现这个操作，所以在这里插个眼，等找到实现方法了TP回来。</p>
<h2 id="Paint的基本参数设置"><a href="#Paint的基本参数设置" class="headerlink" title="Paint的基本参数设置"></a>Paint的基本参数设置</h2><ul>
<li><p>setAntiAlias(Boolean boolean)    设置是否开启抗锯齿</p>
</li>
<li><p>setColor(int color)                设置画笔颜色</p>
</li>
<li><p>setStrokeWidth(int width)        设置画笔宽度</p>
</li>
<li><p>setStyle(Paint.Style style)        设置填充样式</p>
</li>
</ul>
<p>样式有三种：</p>
<p>Paint.Style.FILL                  填充内部</p>
<p>Paint.Style.FILL_AND_STROKE        填充内部以及描边</p>
<p>Paint.STyle.STROKE                仅描边</p>
<p>其中一和二其实没有什么区别。（起初我以为画笔如果够宽，一和二就会有明显的内部、边框之分，但实验过后发现并没有区别）</p>
<ul>
<li>setShadowLayer(float radius, float dx, float dy, int shadowColor)        设置阴影（对图形无效，对字体有效）</li>
</ul>
<p>其中radius指角度，即阴影倾斜度，dx水平位移，dy垂直位移</p>
<h2 id="基本几何图形绘制"><a href="#基本几何图形绘制" class="headerlink" title="基本几何图形绘制"></a>基本几何图形绘制</h2><p>canvas本身就提供了一些基础图形的绘制方法，接下来就是各个方法的使用设置。</p>
<h3 id="一条直线"><a href="#一条直线" class="headerlink" title="一条直线"></a>一条直线</h3><p>方法：drawLine (float startX, float startY, float stopX, float stopY, Paint paint)</p>
<p>参数不用多解释，起点的横纵坐标，终点的横纵坐标，最后就是已经设置好参数的画笔。最后一项参数，在后面的绘制方法里也会有，就不再赘述了。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas.drawLine(100,200,300,400,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/2.png" alt></p>
<h3 id="多条直线"><a href="#多条直线" class="headerlink" title="多条直线"></a>多条直线</h3><ul>
<li>方法：drawLines (float[] pts, Paint paint)</li>
</ul>
<p>由于每个pts的元素，都必须是以四个数，即一组点，即一条线为单位的，所以，在写多条直线的数组时，要<strong>注意数组的元素个数是否符合标准，即数的个数是否能被4整除</strong>。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float []opts&#x3D;&#123;10,10,100,100,200,200,300,300,400,400,500,500&#125;;</span><br><span class="line">canvas.drawLines(opts,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/3.png" alt></p>
<ul>
<li>方法：drawLines (float[] pts, int offset, int count, Paint paint)</li>
</ul>
<p>这个方法与上个方法相比，多出来两个不同的参数。offset表示跳过的数据个数，count表示实际参与绘制的数据个数。什么意思呢？就是在绘制的时候，会先跳过已设置的offset个数的点，只将接下来的count个数的点所构成的直线绘制出来。由此可以得知，两个参数均必须是4的倍数，且两者之和不超过数据的长度。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float []opts&#x3D;&#123;10,10,100,100,200,200,300,300,400,400,500,500&#125;;</span><br><span class="line">canvas.drawLines(opts,4,8,paint);</span><br><span class="line">&#x2F;&#x2F;canvas.drawLines(opts,4,4,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/4.png" alt></p>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/5.png" alt></p>
<p>可以看出来，第一行的运行效果，跳过了第一条直线，显示了第二、三条直线；第二行的运行效果，跳过了第一条直线，只显示了接下来四个点，也就是第二条直线；第三条直线则不再计入绘制。</p>
<h3 id="单个点"><a href="#单个点" class="headerlink" title="单个点"></a>单个点</h3><p>方法：drawPoint (float x, float y, Paint paint)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas.drawPoint(100,100,paint);</span><br></pre></td></tr></table></figure>
<h3 id="多个点"><a href="#多个点" class="headerlink" title="多个点"></a>多个点</h3><ul>
<li><p>方法：drawPoints (float[] pts, Paint paint)</p>
</li>
<li><p>方法：drawPoints (float[] pts, int offset, int count, Paint paint)</p>
</li>
</ul>
<p>这里的方法就跟直线的很类似了，就不再赘述了。</p>
<h3 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h3><p>绘制矩形有两个类：RectF类与Rect类。两个类的区别不大，目前看来的区别是构造参数类型不同。如下：</p>
<ul>
<li><p>RectF(float left, float top, float right, float bottom)</p>
</li>
<li><p>Rect(int left, int top, int right, int bottom)</p>
</li>
</ul>
<p>绘制方法：</p>
<ul>
<li><p>方法：drawRect (float left, float top, float right, float bottom, Paint paint)</p>
</li>
<li><p>方法：drawRect (RectF rect, Paint paint)</p>
</li>
<li><p>方法：drawRect (Rect r, Paint paint)</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas.drawRect(10,10,100,100,paint);</span><br><span class="line">canvas.drawRect(new Rect(120,10,210,100),paint);</span><br><span class="line">canvas.drawRect(new RectF(230,10,320,100),paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/6.png" alt></p>
<h3 id="圆角矩形"><a href="#圆角矩形" class="headerlink" title="圆角矩形"></a>圆角矩形</h3><p>方法：drawRoundRect (RectF rect, float rx, float ry, Paint paint)</p>
<p>这里的rx与ry是指矩形四角生成的椭圆的x轴半径与y轴半径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RectF rectF &#x3D; new RectF(100,100,300,300);</span><br><span class="line">canvas.drawRoundRect(rectF,20,20,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/7.png" alt></p>
<h3 id="圆形"><a href="#圆形" class="headerlink" title="圆形"></a>圆形</h3><p>方法：drawCircle (float cx, float cy, float radius, Paint paint)</p>
<p>这里的cx与cy是指圆心点的x轴与y轴坐标,radius则是圆的半径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas.drawCircle(200,200,100,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/8.png" alt></p>
<h3 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h3><p>椭圆是根据矩形生成的，根据矩形的左顶点与右底点坐标，决定了椭圆的x轴与y轴半径，以及中心点。</p>
<p>方法：drawOval (RectF oval, Paint paint)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RectF rectF &#x3D; new RectF(100,100,300,200);</span><br><span class="line">canvas.drawRect(rectF,paint);</span><br><span class="line"></span><br><span class="line">paint.setColor(Color.RED);</span><br><span class="line">canvas.drawOval(rectF,paint);</span><br></pre></td></tr></table></figure>
<p>为了直观些观察，这里临时将填充样式改为了描边，且将绘制第二个图形的画笔颜色改变一下。</p>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/9.png" alt></p>
<h3 id="弧"><a href="#弧" class="headerlink" title="弧"></a>弧</h3><p>弧是椭圆的一部分，椭圆与矩形相关，所以弧也与矩形相关。</p>
<p>方法：drawArc (RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint)</p>
<p>startAngle是弧开始的角度，sweepAngle是弧持续的角度，useCenter是是否需要弧的两边（详见例图）。<strong>注意，开始角度的起始位置是建立在Android的界面坐标系上的，而不是数学上的坐标系。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">paint.setStyle(Paint.Style.FILL);   &#x2F;&#x2F;填充样式</span><br><span class="line">RectF rectF &#x3D; new RectF(100,100,300,300);</span><br><span class="line">canvas.drawArc(rectF,0,70,true,paint);</span><br><span class="line"></span><br><span class="line">RectF rectF2 &#x3D; new RectF(400,100,600,300);</span><br><span class="line">canvas.drawArc(rectF2,0,70,false,paint);</span><br><span class="line"></span><br><span class="line">paint.setStyle(Paint.Style.STROKE);     &#x2F;&#x2F;描边样式</span><br><span class="line">RectF rectF3 &#x3D; new RectF(100,300,300,500);</span><br><span class="line">canvas.drawArc(rectF3,0,70,true,paint);</span><br><span class="line"></span><br><span class="line">RectF rectF4 &#x3D; new RectF(400,300,600,500);</span><br><span class="line">canvas.drawArc(rectF4,0,70,false,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/10.png" alt></p>
<h2 id="路径绘制图形"><a href="#路径绘制图形" class="headerlink" title="路径绘制图形"></a>路径绘制图形</h2><p>除了通过canvas直接调用绘制图形的专用方法外，还可以通过对path的参数编写并调用drawPath方法，画出想要绘制的图形。其实path有很多方法的参数跟上面的方法都很相似，这下面我就不赘述参数了。</p>
<p>方法：drawPath (Path path, Paint paint)</p>
<h3 id="直线"><a href="#直线" class="headerlink" title="直线"></a>直线</h3><ul>
<li>方法：moveTo (float x, float y)</li>
</ul>
<p>设定直线的起始点</p>
<ul>
<li>方法：lineTo (float x, float y)</li>
</ul>
<p>设定当前直线的终点，也是下一条直线的起始点</p>
<ul>
<li>方法：close ()</li>
</ul>
<p>闭环，即将最后一条直线的终点与第一条的起点连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">paint.setStyle(Paint.Style.FILL);   &#x2F;&#x2F;填充样式</span><br><span class="line"></span><br><span class="line">Path path &#x3D; new Path();</span><br><span class="line">path.moveTo(10,10);</span><br><span class="line">path.lineTo(10,100);</span><br><span class="line">path.lineTo(300,100);</span><br><span class="line">path.lineTo(500,50);</span><br><span class="line">path.close();</span><br><span class="line"></span><br><span class="line">canvas.drawPath(path,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/11.png" alt></p>
<h3 id="矩形-1"><a href="#矩形-1" class="headerlink" title="矩形"></a>矩形</h3><p>方法：addRect (RectF rect, Path.Direction dir)</p>
<p>矩形生成有两个方法，方法的区别主要在于矩形绘制的方向不同，一个是Path.Direction.CCW，为逆时针方向；另一个是Path.Direction.CW，为顺时针方向。为方便观察，可以通过绘制文字的生成路径来观察。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Path CCWpath &#x3D; new Path();</span><br><span class="line">RectF rectF1 &#x3D; new RectF(50,50,240,200);</span><br><span class="line">CCWpath.addRect(rectF1, Path.Direction.CCW);</span><br><span class="line"></span><br><span class="line">Path CWpath &#x3D; new Path();</span><br><span class="line">RectF rectF2 &#x3D; new RectF(290,50,480,200);</span><br><span class="line">CWpath.addRect(rectF2, Path.Direction.CW);</span><br><span class="line"></span><br><span class="line">canvas.drawPath(CCWpath,paint);</span><br><span class="line">canvas.drawPath(CWpath,paint);</span><br><span class="line"></span><br><span class="line">String text &#x3D; &quot;世间安得双全法，不负如来不负卿&quot;;</span><br><span class="line">paint.setColor(Color.RED);</span><br><span class="line">paint.setTextSize(35);</span><br><span class="line">canvas.drawTextOnPath(text,CCWpath,0,18,paint);</span><br><span class="line">canvas.drawTextOnPath(text,CWpath,0,18,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/12.png" alt></p>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/13.png" alt></p>
<h3 id="圆角矩形-1"><a href="#圆角矩形-1" class="headerlink" title="圆角矩形"></a>圆角矩形</h3><p>方法：addRoundRect (RectF rect, float[] radii, Path.Direction dir)</p>
<p>方法：addRoundRect (RectF rect, float rx, float ry, Path.Direction dir)</p>
<p>两个构造函数的区别主要在于第二个参数，即设定矩形的圆角大小。第一个方法可以对每个圆角进行定制，共8个数，方向则取决于绘制的方向，比如逆时针绘制圆角矩形，圆角则从左上角、左下角到右下角、右上角；而第二个方法则统一了每个圆角的大小。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Path path &#x3D; new Path();</span><br><span class="line">RectF rectF1 &#x3D; new RectF(50,50,240,200);</span><br><span class="line">path.addRoundRect(rectF1,10,15, Path.Direction.CCW);</span><br><span class="line"></span><br><span class="line">RectF rectF2 &#x3D; new RectF(290,50,480,200);</span><br><span class="line">float radius[] &#x3D; &#123;10,10,20,20,30,30,40,40&#125;;</span><br><span class="line">path.addRoundRect(rectF2,radius, Path.Direction.CCW);</span><br><span class="line"></span><br><span class="line">canvas.drawPath(path,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/14.png" alt></p>
<h3 id="圆形路径"><a href="#圆形路径" class="headerlink" title="圆形路径"></a>圆形路径</h3><p>方法：addCircle (float x, float y, float radius, Path.Direction dir)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Path path &#x3D; new Path();</span><br><span class="line">path.addCircle(200,200,100, Path.Direction.CCW);</span><br><span class="line">canvas.drawPath(path,paint);</span><br></pre></td></tr></table></figure>
<h3 id="椭圆路径"><a href="#椭圆路径" class="headerlink" title="椭圆路径"></a>椭圆路径</h3><p>方法：addOval (RectF oval, Path.Direction dir)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Path path &#x3D; new Path();</span><br><span class="line">RectF rectF &#x3D; new RectF(100,100,300,500);</span><br><span class="line">path.addOval(rectF, Path.Direction.CCW);</span><br><span class="line"></span><br><span class="line">canvas.drawPath(path,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/15.png" alt></p>
<h3 id="弧形路径"><a href="#弧形路径" class="headerlink" title="弧形路径"></a>弧形路径</h3><p>方法：addArc (RectF oval, float startAngle, float sweepAngle)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Path path &#x3D; new Path();</span><br><span class="line">RectF rectF &#x3D; new RectF(100,100,300,500);</span><br><span class="line">path.addArc(rectF,0,100);</span><br><span class="line"></span><br><span class="line">canvas.drawPath(path,paint);</span><br></pre></td></tr></table></figure>
<h3 id="线段"><a href="#线段" class="headerlink" title="线段"></a>线段</h3><p>方法：quadTo (float x1, float y1, float x2, float y2)</p>
<p>这个方法的特点是绘制的曲线遵循了“贝塞尔曲线”，所以在连续的绘制时看起来会很平滑，这里我也不多深究，也可能以后专门写个博客来描述一下区别吧。这里就贴一下别人的博客好了。</p>
<p>参考博客：<a href="https://blog.csdn.net/stevenhu_223/article/details/9229337">quadTo()方法与lineTo()方法的区别</a></p>
<h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><p>1、Paint相关设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">paint.setColor(Color.RED);                  &#x2F;&#x2F;画笔颜色</span><br><span class="line">paint.setStrokeWidth(5);                    &#x2F;&#x2F;画笔宽度</span><br><span class="line">paint.setAntiAlias(true);                   &#x2F;&#x2F;抗锯齿</span><br><span class="line">paint.setStyle(Paint.Style.FILL);           &#x2F;&#x2F;绘图样式</span><br><span class="line">paint.setTextSize(80);                      &#x2F;&#x2F;文字大小</span><br><span class="line"></span><br><span class="line">paint.setFakeBoldText(true);                &#x2F;&#x2F;是否为粗体</span><br><span class="line">paint.setTextSkewX((float) -0.25);          &#x2F;&#x2F;字体水平倾斜度</span><br><span class="line"></span><br><span class="line">paint.setUnderlineText(true);               &#x2F;&#x2F;下划线</span><br><span class="line">paint.setStrikeThruText(true);              &#x2F;&#x2F;删除线</span><br><span class="line"></span><br><span class="line">paint.setTextAlign(Paint.Align.CENTER);     &#x2F;&#x2F;对齐方式</span><br><span class="line">paint.setTextScaleX(1);                     &#x2F;&#x2F;只会将水平方向拉伸</span><br></pre></td></tr></table></figure>
<p>这就是paint绘制文字时的几个主要设置选项了。画笔颜色、宽度、抗锯齿、文字大小、下划线、删除线等这些很浅显的就不具体展示了，我只对绘图样式、是否为粗体、水平倾斜度、方向拉伸做一下展示，每行字之间至少有三个设置的不同（不包括最后两行的比较，最好两行是是否为粗体和设置阴影的区别）。示例代码及效果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">paint.setFakeBoldText(false);</span><br><span class="line">paint.setTextSkewX((float) -0.25);</span><br><span class="line">paint.setTextScaleX(1);</span><br><span class="line">canvas.drawText(&quot;おれはおまえが好きだ&quot;,10,100,paint);</span><br><span class="line"></span><br><span class="line">paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">paint.setFakeBoldText(false);</span><br><span class="line">paint.setTextSkewX((float) 0.25);</span><br><span class="line">paint.setTextScaleX((float) 0.75);</span><br><span class="line">canvas.drawText(&quot;わたしはあなたが好きだ&quot;,10,200,paint);</span><br><span class="line"></span><br><span class="line">paint.setStyle(Paint.Style.FILL_AND_STROKE);</span><br><span class="line">paint.setFakeBoldText(false);</span><br><span class="line">paint.setTextSkewX((float) -0.25);</span><br><span class="line">paint.setTextScaleX((float) 1.3);</span><br><span class="line">canvas.drawText(&quot;君の名は。&quot;,10,300,paint);</span><br><span class="line"></span><br><span class="line">paint.setShadowLayer(1,15,15,Color.GRAY);</span><br><span class="line">paint.setStyle(Paint.Style.FILL_AND_STROKE);</span><br><span class="line">paint.setFakeBoldText(true);</span><br><span class="line">paint.setTextSkewX((float) -0.25);</span><br><span class="line">paint.setTextScaleX((float) 1.3);</span><br><span class="line">canvas.drawText(&quot;君の名は。&quot;,10,400,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/16.png" alt></p>
<p>还有一个属性是文字对齐方式的区别。其实这里面细致的东西有很多，我在这里放上一篇讲的很细致的文章以供参考。<a href="https://www.jianshu.com/p/8b97627b21c4">博客链接</a>。我这里就只展示一下效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">paint.setTextAlign(Paint.Align.LEFT);</span><br><span class="line">canvas.drawText(&quot;君の名は。&quot;,360,100,paint);</span><br><span class="line"></span><br><span class="line">paint.setTextAlign(Paint.Align.CENTER);</span><br><span class="line">canvas.drawText(&quot;君の名は。&quot;,360,200,paint);</span><br><span class="line"></span><br><span class="line">paint.setTextAlign(Paint.Align.RIGHT);</span><br><span class="line">canvas.drawText(&quot;君の名は。&quot;,360,300,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/17.png" alt></p>
<p>根据设置的位置、属性以及效果可以看出，如果设置左对齐，则文字会以设置的原点为左基准线临界点，向右展开；如果为居中对齐，则文字以原点为基准线中心点；右对齐则为右基准线临界点。</p>
<p>2、canvas绘制文字的函数</p>
<ul>
<li><p>方法：void drawText (String text, float x, float y, Paint paint)</p>
</li>
<li><p>方法：void drawText (CharSequence text, int start, int end, float x, float y, Paint paint)</p>
</li>
</ul>
<p>第一个方法在上面的示例已经用过了，x和y表示位置，不用多说。而第二个方法，则可以额外对传入的字符串进行截取。不过我觉得也可以对字符串进行提前截取，再放入第一个方法，所以暂时想不到第二个方法的优势之处，可能少一行代码也算优势吧。</p>
<ul>
<li><p>方法：void drawPosText (char[] text, int index, int count, float[] pos, Paint paint)</p>
</li>
<li><p>方法：void drawPosText (String text, float[] pos, Paint paint)</p>
</li>
</ul>
<p>这两个方法可以指定要绘制的文字的位置，跟上面一样，位置也是两两数字一组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float pos[]&#x3D;new float[]&#123;10,200,60,300,110,400,160,500,210,600&#125;;</span><br><span class="line">canvas.drawPosText(&quot;君の名は。&quot;,pos,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/18.png" alt></p>
<ul>
<li><p>方法：void drawTextOnPath (String text, Path path, float hOffset, float vOffset, Paint paint)</p>
</li>
<li><p>方法：void drawTextOnPath (char[] text, int index, int count, Path path, float hOffset, float vOffset, Paint paint)</p>
</li>
</ul>
<p>这两个方法属于沿路径绘制，在上面的示例中也已经见过一次了。这里主要讲hOffset、vOffset，hOffset是与路径起始点的<strong>水平</strong>偏移增量，vOffset是与路径中心的垂直偏移增量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String text &#x3D; &quot;君の名は。&quot;;</span><br><span class="line"></span><br><span class="line">Path circlePath &#x3D; new Path();</span><br><span class="line">RectF rectF &#x3D; new RectF(100,100,300,300);</span><br><span class="line">circlePath.addRoundRect(rectF,10,15,Path.Direction.CCW);</span><br><span class="line">canvas.drawPath(circlePath,paint);</span><br><span class="line"></span><br><span class="line">Path circlePath2 &#x3D; new Path();</span><br><span class="line">RectF rectF2 &#x3D; new RectF(400,100,600,300);</span><br><span class="line">circlePath2.addRoundRect(rectF2,10,15, Path.Direction.CCW);</span><br><span class="line">canvas.drawPath(circlePath2,paint);</span><br><span class="line"></span><br><span class="line">canvas.drawTextOnPath(text,circlePath,0,0,paint);</span><br><span class="line">canvas.drawTextOnPath(text,circlePath2,80,30,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/19.png" alt></p>
<p>此外字体还有其他的样式设置等等。个人感觉暂时不会用到，就不做学习了。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>妈耶，我再也不一口气写这么长的博客了。写到后边，总觉得累了，都不想写的很详细了。真佩服那些能写出一本教程书的大佬。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin语法初入门</title>
    <url>/2020/12/14/Kotlin%E8%AF%AD%E6%B3%95%E5%88%9D%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>从 Java 来初入 Kotlin ，因目前在学习阶段，还没有投入到项目中去使用，很多语法规则在学过之后慢慢地忘记了，所以写一写学到的语法，以便回顾。</p>
<p>本文内容来源于《第一行代码》第三版第二章，代码上可能不尽相同，内容上仅仅做一些粗略概括罢了，想细致学习建议参考书籍。</p>
<a id="more"></a>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>声明变量的两个关键字： <strong>val</strong> 和 <strong>var</strong></p>
<blockquote>
<ul>
<li><strong>val</strong> ( value 的简写) 用来声明不可变变量。使用 val 声明的变量经赋值后无法再度赋值。</li>
<li><strong>var</strong> ( variable 的简写) 用来声明可变变量</li>
</ul>
</blockquote>
<p>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val a &#x3D; 10</span><br><span class="line">var b &#x3D; 100</span><br><span class="line">println(&quot;a &#x3D; $a b &#x3D; $b&quot;)</span><br></pre></td></tr></table></figure>
<p>Kotlin 拥有出色的<strong>类型推导机制</strong>，在之上的代码中可窥一斑。必要时，也需要声明变量的类型。其与 Java 中的声明对照如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Java 基本数据类型</th>
<th style="text-align:center">Kotlin 对象数据类型</th>
<th style="text-align:center">数据类型说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">Int</td>
<td style="text-align:center">整数</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">Long</td>
<td style="text-align:center">长整型</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">Short</td>
<td style="text-align:center">短整型</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">Float</td>
<td style="text-align:center">单精度浮点型</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">Double</td>
<td style="text-align:center">双精度浮点型</td>
</tr>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">Byte</td>
<td style="text-align:center">字节</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">Char</td>
<td style="text-align:center">字符</td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">布尔型</td>
</tr>
</tbody>
</table>
</div>
<p>显式声明如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a: Int &#x3D; 10</span><br></pre></td></tr></table></figure>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>常用关键字：<strong>fun</strong>。示例函数体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun method(param1: Int, parma2: Int): Int &#123;</span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小括号之外的 Int 声明了返回的变量类型。再比如如下的函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun largerNumber(param1: Int, param2: Int): Int &#123;</span><br><span class="line">    return max(param1, param2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种函数主体内容仅有一行代码的函数可以简写为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun largerNumber(param1: Int, param2: Int): Int &#x3D; max(param1, param2)</span><br></pre></td></tr></table></figure>
<p>又因为 Kotlin 的类型推导机制，还可以简化为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun largerNumber(param1: Int, param2: Int) &#x3D; max(param1, param2)</span><br></pre></td></tr></table></figure>
<h1 id="控制逻辑部分"><a href="#控制逻辑部分" class="headerlink" title="控制逻辑部分"></a>控制逻辑部分</h1><h2 id="if-与-when"><a href="#if-与-when" class="headerlink" title="if 与 when"></a>if 与 when</h2><p>if 的用法相差不多。比如上面的函数可改写为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun largerNumber(param1: Int, param2: Int): Int &#123;</span><br><span class="line">    return if(param1 &gt; param2)&#123;</span><br><span class="line">        param1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        param2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可简化为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun largerNumber(param1: Int, param2: Int) &#x3D; if(param1 &gt; param2)&#123;</span><br><span class="line">    param1</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    param2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再简化为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun largerNumber(param1: Int, param2: Int) &#x3D; if(param1 &gt; param2) param1 else param2</span><br></pre></td></tr></table></figure>
<h2 id="when"><a href="#when" class="headerlink" title="when"></a>when</h2><p>相当于 Java 中的 switch，又远强于 switch。Java 中的 switch 仅可传入整型，JDK1.7 之后添加了对字符串的支持（我好像从没传过字符串）。而 when 则相当强大。它允许传入任意类型的参数，判断的条件也可以多种多样，格式为：</p>
<blockquote>
<ul>
<li>匹配值 -&gt; {执行逻辑}</li>
</ul>
</blockquote>
<p>常见如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun getPrice(game: String) &#x3D; when(game)&#123;</span><br><span class="line">    &quot;Dark Souls 3&quot; -&gt; 268</span><br><span class="line">    &quot;Devil May Cry 5&quot; -&gt; 137</span><br><span class="line">    &quot;Left 4 Dead 2&quot; -&gt; 37</span><br><span class="line">    else -&gt; 68</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还支持复杂条件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun getPrice(game: String) &#x3D; when&#123;</span><br><span class="line">    game.startsWith(&quot;Dark&quot;) -&gt; 268</span><br><span class="line">    game.endsWith(&quot;Cry 5&quot;) -&gt; 137</span><br><span class="line">    game.contains(&quot;Dead&quot;) -&gt; 37</span><br><span class="line">    else -&gt; 68</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for-in 循环"></a>for-in 循环</h2><p>Kotlin 有以下几种表示区间的写法：</p>
<blockquote>
<ul>
<li>val rangeA = 0..10 表示 [0,10] 。这是一个双端闭区间</li>
<li>val rangeB = 0 util 10 表示 [0,10) 。这是一个单端闭区间</li>
<li>val rangeC = 10 downTo 0 表示[10, 0] 。这也是一个双端闭区间</li>
</ul>
</blockquote>
<p>对于循环，便有了如下写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(i in 0..10)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(i in 0 util 10)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但在以上的循环中，i 是以 1 为差递增的。有时需要改变一下递增规则，则需要用到 <strong>step</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(i in 0 util 10 step 2)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><p>新建一个类，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Game &#123;</span><br><span class="line">    var name &#x3D; &quot;&quot;</span><br><span class="line">    var price &#x3D; 0</span><br><span class="line"></span><br><span class="line">    fun info()&#123;</span><br><span class="line">        println(&quot;The Game : $name is sold in $price on steam&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kotlin 在实例化一个对象时不使用关键字，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun main() &#123;</span><br><span class="line">    val g &#x3D; Game()</span><br><span class="line">    g.name &#x3D; &quot;Dark Souls 3&quot;</span><br><span class="line">    g.price &#x3D; 268</span><br><span class="line">    g.info()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Kotlin 中，[类.属性] = [值] 这一写法相当于 Java 的 set() 方法</p>
<h2 id="继承与构造"><a href="#继承与构造" class="headerlink" title="继承与构造"></a>继承与构造</h2><p>不同于 Java 中一个类本身就可以被继承的默认规则，在 Kotlin 中，这个类需要添加 <strong>open</strong> 关键字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open class Game &#123;</span><br><span class="line">    var name &#x3D; &quot;&quot;</span><br><span class="line">    var price &#x3D; 0</span><br><span class="line"></span><br><span class="line">    fun info()&#123;</span><br><span class="line">        println(&quot;The Game : &quot; + name + &quot; is sold in &quot; + price + &quot; on steam&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，让一个类继承 Game 类。在 Java 中，关键字为 extends，而在 Kotlin 中，则变成了一个冒号，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class RPG : Game() &#123;</span><br><span class="line">    var fullName &#x3D; &quot;&quot;</span><br><span class="line">    var roleName &#x3D; &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒号后的 “Game()” 涉及到了构造函数的问题。每个类都存在一个不带参的主构造函数，比如 Game 类，在实例化时并未带进任何参数， RPG 也是如此。不过，也可以改写为主构造函数带参的形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class RPG (val fullName: String, val roleName: String) : Game() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主构造函数中，被声明了 val 和 var 的变量会成为该类的字段，而未声明的变量则是主构造函数内的局域变量。</p>
<p>这之后实例化 RPG 类的时候就需要携带参数了。那如果 Game 类也变成主构造函数带参后，则继承 Game 类时需要赋予参数，这样一来 RPG 也需要携带一些其他参数，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class RPG (val fullName: String, val roleName: String, name: String, price: String) : Game(name, price) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若是想在主构造函数中做一些初始化操作的话，需要在 init 结构体中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class RPG (val fullName: String, val roleName: String, name: String, price: String) : Game(name, price) &#123;</span><br><span class="line">    init&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，还可以通过 constructor 关键字来定义主构造函数和次构造函数。只不过，在定义主构造函数时，无法用 val 和 var 声明变量，即变量无法变成类的字段，只能作为局域变量使用；在定义次构造函数时与Java差别不大，不再赘述。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h2 id="函数可见性修饰符"><a href="#函数可见性修饰符" class="headerlink" title="函数可见性修饰符"></a>函数可见性修饰符</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">Java</th>
<th style="text-align:center">Kotlin</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">所有类可见</td>
<td style="text-align:center">所有类可见（默认）</td>
</tr>
<tr>
<td style="text-align:center">private</td>
<td style="text-align:center">当前类可见</td>
<td style="text-align:center">当前类可见</td>
</tr>
<tr>
<td style="text-align:center">protect</td>
<td style="text-align:center">当前类、子类、同一包路径下的类可见</td>
<td style="text-align:center">当前类、子类可见</td>
</tr>
<tr>
<td style="text-align:center">default</td>
<td style="text-align:center">当前类、同一包路径下的类可见</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:center">internal</td>
<td style="text-align:center">无</td>
<td style="text-align:center">统一模块中的类可见</td>
</tr>
</tbody>
</table>
</div>
<h2 id="数据类与单例类"><a href="#数据类与单例类" class="headerlink" title="数据类与单例类"></a>数据类与单例类</h2><p>数据类的关键字为 <strong>data</strong>，在 class 前添加，它会帮一个类自动生成 equals()、hashCode()、toString() 等方法</p>
<p>单例类的关键字为 <strong>object</strong>，替换掉 class 即可</p>
<h1 id="Lambda-编程"><a href="#Lambda-编程" class="headerlink" title="Lambda 编程"></a>Lambda 编程</h1><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Kotlin提供了内置的简化初始化集合的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val gameList &#x3D; listOf(&quot;Dark Souls&quot;, &quot;Devil May Cry&quot;, &quot;Sekiro: Shadows Die Twice&quot;, &quot;The Legend Of Zelda&quot;, &quot;Super Mario Odyssey&quot;, &quot;Ori And The Will Of Wisps&quot;)</span><br></pre></td></tr></table></figure>
<p>但是，listOf() 函数创建的是一个不可变的集合，要创建可变集合需要 mutableListOf() 函数</p>
<p>对于 set 集合，函数变成了 setOf() 和 mutableSetOf()</p>
<p>对于 map 集合，写法要特殊一些：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val gameMap &#x3D; mapOf(&quot;Dark Souls&quot; to 268, &quot;Devil May Cry 5&quot; to 137, &quot;Sekito: Shadows Die Twice&quot; to 274, &quot;Ori And The Will Of Wisps&quot; to 90)</span><br><span class="line">for ((game, price) in gameMap)&#123;</span><br><span class="line">    println(&quot;The game : $game is sold in $price on steam.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数式API"><a href="#函数式API" class="headerlink" title="函数式API"></a>函数式API</h2><p>Lambda 表达式在函数式 API 中用的比较多，先说一下语法结构：</p>
<blockquote>
<ul>
<li>{参数名1： 参数类型， 参数名2： 参数类型 -&gt; 函数体}</li>
</ul>
</blockquote>
<h3 id="maxBy-函数"><a href="#maxBy-函数" class="headerlink" title="maxBy 函数"></a>maxBy 函数</h3><p>这是一个提值函数，比如从 gameList 中提出长度最长的 game 单词，先从普通写法开始：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val gameList &#x3D; listOf(&quot;Dark Souls&quot;, &quot;Devil May Cry&quot;, &quot;Sekiro: Shadows Die Twice&quot;, &quot;The Legend Of Zelda&quot;, &quot;Super Mario Odyssey&quot;, &quot;Ori And The Will Of Wisps&quot;)</span><br><span class="line">var maxLengthGame &#x3D; &quot;&quot;</span><br><span class="line">for (game in gameList)&#123;</span><br><span class="line">    if (game.length &gt; maxLengthGame.length)&#123;</span><br><span class="line">        maxLengthGame &#x3D; game</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">println(&quot;max length game is $maxLengthGame&quot;)</span><br></pre></td></tr></table></figure>
<p>此时先了解一个函数：maxBy。它可以根据传入的条件来遍历集合，从而找到最大值，那么此时的条件就是单词的长度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val gameList &#x3D; listOf(&quot;Dark Souls&quot;, &quot;Devil May Cry&quot;, &quot;Sekiro: Shadows Die Twice&quot;, &quot;The Legend Of Zelda&quot;, &quot;Super Mario Odyssey&quot;, &quot;Ori And The Will Of Wisps&quot;)</span><br><span class="line">var lambda &#x3D; &#123; game: String -&gt; game.length&#125;</span><br><span class="line">var maxLengthGame &#x3D; gameList.maxBy(lambda)</span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var maxLengthGame &#x3D; gameList.maxBy(&#123; game: String -&gt; game.length&#125;)</span><br></pre></td></tr></table></figure>
<p>当 lambda 参数是函数最后一个参数时，可将表达式移出括号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var maxLengthGame &#x3D; gameList.maxBy() &#123; game: String -&gt; game.length&#125;</span><br></pre></td></tr></table></figure>
<p>当 lambda 参数是函数唯一一个参数时，可将函数括号省略：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var maxLengthGame &#x3D; gameList.maxBy &#123; game: String -&gt; game.length&#125;</span><br></pre></td></tr></table></figure>
<p>介于 Kotlin 的类型推导机制，对参数类型的声明可省略：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var maxLengthGame &#x3D; gameList.maxBy &#123; game -&gt; game.length&#125;</span><br></pre></td></tr></table></figure>
<p>当 lambda 表达式中只有一个参数时，不必声明参数名，条件里的参数名可用 it 来代替：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var maxLengthGame &#x3D; gameList.maxBy &#123; it.length&#125;</span><br></pre></td></tr></table></figure>
<h3 id="map-函数"><a href="#map-函数" class="headerlink" title="map 函数"></a>map 函数</h3><p>这是一个映射函数，同上映射规则在 lambda 表达式中指定，最终生成一个新的集合。比如将单词名全部变为大写模式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val gameList &#x3D; listOf(&quot;Dark Souls&quot;, &quot;Devil May Cry&quot;, &quot;Sekiro: Shadows Die Twice&quot;, &quot;The Legend Of Zelda&quot;, &quot;Super Mario Odyssey&quot;, &quot;Ori And The Will Of Wisps&quot;)</span><br><span class="line">val newList &#x3D; gameList.map &#123; it.toUpperCase() &#125;</span><br><span class="line">for (game in newList)&#123;</span><br><span class="line">    println(game)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter 函数"></a>filter 函数</h3><p>这是一个过滤函数，示例用法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val gameList &#x3D; listOf(&quot;Dark Souls&quot;, &quot;Devil May Cry&quot;, &quot;Sekiro: Shadows Die Twice&quot;, &quot;The Legend Of Zelda&quot;, &quot;Super Mario Odyssey&quot;, &quot;Ori And The Will Of Wisps&quot;)</span><br><span class="line">val newList &#x3D; gameList.filter &#123; it.length &lt;&#x3D; 20 &#125;</span><br><span class="line">        .map &#123; it.toUpperCase() &#125;</span><br><span class="line">for (game in newList)&#123;</span><br><span class="line">    println(game)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="any-amp-all-函数"><a href="#any-amp-all-函数" class="headerlink" title="any &amp; all 函数"></a>any &amp; all 函数</h3><p>这是两个判断函数，any 函数用于判断集合中是否至少存在一个元素满足条件，而 all 函数用于判断是否全部元素满足条件，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val gameList &#x3D; listOf(&quot;Dark Souls&quot;, &quot;Devil May Cry&quot;, &quot;Sekiro: Shadows Die Twice&quot;, &quot;The Legend Of Zelda&quot;, &quot;Super Mario Odyssey&quot;, &quot;Ori And The Will Of Wisps&quot;)</span><br><span class="line">val anyResult &#x3D; gameList.any &#123; it.startsWith(&quot;Dark&quot;) &#125;</span><br><span class="line">val allResult &#x3D; gameList.all &#123; it.length &gt; 10 &#125;</span><br><span class="line">println(&quot;anyResult is $anyResult, allResult is $allResult&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="Java-函数式-API"><a href="#Java-函数式-API" class="headerlink" title="Java 函数式 API"></a>Java 函数式 API</h2><p>使用函数式 API  有一定的限制条件，就是调用的方法是单个Java单抽象方法接口参数。示例，创建一个线程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread(object : Runnable&#123;</span><br><span class="line">    override fun run() &#123;</span><br><span class="line">        println(&quot;Thread is running&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start()</span><br></pre></td></tr></table></figure>
<p>创建匿名类实例的时候，Kotlin 需要用关键字 object 来声明。接下来进行简化。因 Runnable 类中只有一个待实现方法，指 run() 方法，Kotlin 能自动明白 Runnable 后面的 Lambda 表达式就是要在 run() 方法中实现的内容。可简化为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread(Runnable&#123;</span><br><span class="line">    println(&quot;Thread is running&quot;)</span><br><span class="line">&#125;).start()</span><br></pre></td></tr></table></figure>
<p>若方法的参数列表内仅有一个Java单抽象方法接口参数，可对接口名进行省略：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread(&#123;</span><br><span class="line">    println(&quot;Thread is running&quot;)</span><br><span class="line">&#125;).start()</span><br></pre></td></tr></table></figure>
<p>根据在 maxBy 函数环节的最后且唯一函数为 Lambda 表达式时，可将 () 省略：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread &#123;</span><br><span class="line">    println(&quot;Thread is running&quot;)</span><br><span class="line">&#125; .start()</span><br></pre></td></tr></table></figure>
<p>这种写法在后面会用的很多。</p>
<h1 id="空指针检查"><a href="#空指针检查" class="headerlink" title="空指针检查"></a>空指针检查</h1><p>在 Kotlin 中，编译时期就存在对空指针异常的检查。它提供了一个可为空的类型系统和一个 <strong>?</strong> 。比如，Int 表示不可为空的整型，而 Int? 就表示可为空的整型。</p>
<h2 id="判空辅助工具"><a href="#判空辅助工具" class="headerlink" title="判空辅助工具"></a>判空辅助工具</h2><h3 id><a href="#" class="headerlink" title="?."></a>?.</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a?.doSomething()</span><br></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (a !&#x3D; null)&#123;</span><br><span class="line">    a.doSomething()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="-1"><a href="#-1" class="headerlink" title="?:"></a>?:</h3><p>这个操作符的左右两边各接收一个表达式，结果不为空则返回左边表达式的结果，否则返回右边表达式的结果，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val c &#x3D; a ?: c</span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val c &#x3D; if (a !&#x3D; null)&#123;</span><br><span class="line">    a</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="-2"><a href="#-2" class="headerlink" title="!!"></a>!!</h3><p>如果确信某处的对象不会为空，不必做空指针检查，则在对象后加上 !! ，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a!!.doSomething()</span><br></pre></td></tr></table></figure>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>let 是一个函数，它可以处理变量的判空问题。用法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a?.doSomething()</span><br><span class="line">a?.doElse()</span><br></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a?.let &#123; a -&gt;</span><br><span class="line">    a.doSomething()</span><br><span class="line">    a.doElse()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又介于 Lambda 的表达式，可简化为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a?.let &#123;</span><br><span class="line">    it.doSomething()</span><br><span class="line">    it.doElse()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="一些-Kotlin-小常识"><a href="#一些-Kotlin-小常识" class="headerlink" title="一些 Kotlin 小常识"></a>一些 Kotlin 小常识</h1><h2 id="字符串内嵌表达式"><a href="#字符串内嵌表达式" class="headerlink" title="字符串内嵌表达式"></a>字符串内嵌表达式</h2><p>在表达式中，用 ${} 来替代之前的 + ，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val game &#x3D; Game(&quot;Dark Souls&quot;, &quot;268&quot;)</span><br><span class="line">println(&quot;The game name is $&#123;game.name&#125;. The Price is $&#123;game.price&#125;.&quot;)</span><br></pre></td></tr></table></figure>
<p>如果字段不是 类.属性 这样的情况，则可以省略 {}:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val ff7game &#x3D; &quot;Final Fantasy VII&quot;</span><br><span class="line">val ff7price &#x3D; 40</span><br><span class="line">println(&quot;Another game is $ff7game. Its price is $ff7price.&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h2><p>先看一下示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun printPrice(game: String, price: Int &#x3D; 428)&#123;</span><br><span class="line">    println(&quot;The game $game is sold price in $price on Steam.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用情况如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printPrice(&quot;Tomb Raider: Shadow&quot;)</span><br></pre></td></tr></table></figure>
<p>但这个函数的参数情况比较特殊，默认参数正好是第二位。如果默认参数改到第一位，代码就会报错。这时候 Kotlin 提供了键值对的方法来对参数赋值，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun printPrice(price: Int &#x3D; 428, game: String)&#123;</span><br><span class="line">    println(&quot;The game $game is sold price in $price on Steam.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用时变为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printPrice(game &#x3D; &quot;Tomb Raider: Shadow&quot;)</span><br></pre></td></tr></table></figure>
<p>这个方法还可以用到类的主构造函数中去：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Game (val name: String &#x3D; &quot;Dark Souls 3: Deluxe Edition&quot;, val price: String &#x3D; &quot;396&quot;) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="标准函数与静态方法"><a href="#标准函数与静态方法" class="headerlink" title="标准函数与静态方法"></a>标准函数与静态方法</h1><h2 id="with、run、apply-函数"><a href="#with、run、apply-函数" class="headerlink" title="with、run、apply 函数"></a>with、run、apply 函数</h2><h3 id="with-函数"><a href="#with-函数" class="headerlink" title="with 函数"></a>with 函数</h3><p>它接收两个参数：第一个是一个任意类型的对象；第二个是 Lambda 表达式。大致结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val result &#x3D; with(obj) &#123;</span><br><span class="line">    &quot;value&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val gameList &#x3D; listOf(&quot;Dark Souls&quot;, &quot;Devil May Cry&quot;, &quot;The Legend Of Zelda&quot;, &quot;Sekiro: Shadows Die Twice&quot;, &quot;Call Of Duty&quot;)</span><br><span class="line">val builder &#x3D; StringBuilder()</span><br><span class="line">builder.append(&quot;Start playing games: \n&quot;)</span><br><span class="line">for (index in gameList.indices)&#123;</span><br><span class="line">    builder.append(index).append(&quot;: &quot;).append(gameList[index]).append(&quot;\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line">builder.append(&quot;That&#39;s all.&quot;)</span><br><span class="line">val result &#x3D; builder.toString()</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure>
<p>可以改写为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val gameList &#x3D; listOf(&quot;Dark Souls&quot;, &quot;Devil May Cry&quot;, &quot;The Legend Of Zelda&quot;, &quot;Sekiro: Shadows Die Twice&quot;, &quot;Call Of Duty&quot;)</span><br><span class="line">val result &#x3D; with(StringBuilder()) &#123;</span><br><span class="line">    append(&quot;Start playing games: \n&quot;)</span><br><span class="line">    for (index in gameList.indices)&#123;</span><br><span class="line">        append(index).append(&quot;: &quot;).append(gameList[index]).append(&quot;\n&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    append(&quot;That&#39;s all&quot;)</span><br><span class="line">    toString()</span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure>
<h3 id="run-函数"><a href="#run-函数" class="headerlink" title="run 函数"></a>run 函数</h3><p>run 函数的大致结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val result &#x3D; obj.run &#123;</span><br><span class="line">    &quot;value&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val gameList &#x3D; listOf(&quot;Dark Souls&quot;, &quot;Devil May Cry&quot;, &quot;The Legend Of Zelda&quot;, &quot;Sekiro: Shadows Die Twice&quot;, &quot;Call Of Duty&quot;)</span><br><span class="line">val result &#x3D; StringBuilder().run &#123; </span><br><span class="line">    append(&quot;Start playing games: \n&quot;)</span><br><span class="line">    for (index in gameList.indices)&#123;</span><br><span class="line">        append(index).append(&quot;: &quot;).append(gameList[index]).append(&quot;\n&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    append(&quot;That&#39;s all.&quot;)</span><br><span class="line">    toString()</span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure>
<h3 id="apply-函数"><a href="#apply-函数" class="headerlink" title="apply 函数"></a>apply 函数</h3><p>apply 函数与 run 函数类似，但在返回结果上还是存在一定差异的。run 函数返回的对象是最后一行的运算结果，而 apply 函数返回的对象还是调用的对象本身。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val gameList &#x3D; listOf(&quot;Dark Souls&quot;, &quot;Devil May Cry&quot;, &quot;The Legend Of Zelda&quot;, &quot;Sekiro: Shadows Die Twice&quot;, &quot;Call Of Duty&quot;)</span><br><span class="line">val result &#x3D; StringBuilder().apply &#123;</span><br><span class="line">    append(&quot;Start playing games: \n&quot;)</span><br><span class="line">    for (index in gameList.indices)&#123;</span><br><span class="line">        append(index).append(&quot;: &quot;).append(gameList[index]).append(&quot;\n&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    append(&quot;That&#39;s all.&quot;)</span><br><span class="line">    toString()</span><br><span class="line">&#125;</span><br><span class="line">println(result.javaClass)</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure>
<p>其中，输出结果中表明 result 本身还是 StringBuilder, 并未变为 String：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class java.lang.StringBuilder</span><br></pre></td></tr></table></figure>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>在 Java 中，在方法前加上 static 即可。但由于 Kotlin 极度弱化了静态方法这个概念，所以在 Kotlin 中定义一个静态方法要麻烦一些。</p>
<p>首先，要知道在 Kotlin 中，使用单例类的写法会将整个类中的所有方法变成类似于静态方法的调用方式。故要先将单例类变为一个普通类，即将 object 变为 class。然后，将方法放在 companion object 结构体中，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Util &#123;</span><br><span class="line">    </span><br><span class="line">    fun doAction1()&#123;</span><br><span class="line">        println(&quot;do action 1&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line"></span><br><span class="line">        fun doAction2()&#123;</span><br><span class="line">            println(&quot;do action 2&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时就可以直接使用 Util.doAction2() 的方式调用。不过，这样也并不是静态方法，companion object 这个关键字会在 Util 类的内部创建一个伴生类，而 doAction2() 方法就是这个伴生类的实例方法。</p>
<p>若要真正地定义一个静态方法，则有两种方式：注解和顶层方法。</p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>在普通类的 companion object 的结构体内的方法前添加 @JvmStatic 注解，或在单例类的方法上添加 @JvmStatic 注解，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Util &#123;</span><br><span class="line">    </span><br><span class="line">    fun doAction()&#123;</span><br><span class="line">        println(&quot;do Action 1&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line"></span><br><span class="line">        @JvmStatic</span><br><span class="line">        fun doAction2()&#123;</span><br><span class="line">            println(&quot;do Action 2&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">object Singleton &#123;</span><br><span class="line"></span><br><span class="line">    @JvmStatic</span><br><span class="line">    fun singletonTest()&#123;</span><br><span class="line">        println(&quot;Now it&#39;s singleton test.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="顶层方法"><a href="#顶层方法" class="headerlink" title="顶层方法"></a>顶层方法</h3><p>新建一个 File 文件（后缀为 .kt），那么这个文件中定义的任何方法都将是顶层方法。</p>
<h1 id="扩展函数与运算符重载"><a href="#扩展函数与运算符重载" class="headerlink" title="扩展函数与运算符重载"></a>扩展函数与运算符重载</h1><h2 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h2><p>一般来说，当需要编写一个新的工具方法时，在 Java 里往往会新建一个 Util 类并编写方法。在 Kotlin 中，则可以通过使用扩展函数的方式来完成。语法结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun ClassName.methodName(param1: Int, param2: Int): Int &#123;</span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ClassName 可以与一些常见类同名，文件名也可同名，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun String.lettersCount(): Int &#123;</span><br><span class="line">    var count &#x3D; 0</span><br><span class="line">    for (char in this) &#123;</span><br><span class="line">        if (char.isLetter()) &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val info &#x3D; &quot;My favorite game is Dark Souls 3&quot;</span><br><span class="line">println(&quot;这句话含有 $&#123;info.lettersCount()&#125; 个字符&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>加密算法初步学习</title>
    <url>/2018/10/16/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>最近发现学的东西杂七杂八的，总是看到什么，觉得有意思，就查一下看看。像这次加密算法也是，这是个我应该不会去涉及的领域，毕竟我也不做后台数据库，也不玩python去破解什么东西，可能学了也没什么用。但兴趣来了，就学一学好了，总比整日一味刷着b站无聊的视频好多了。</p>
<a id="more"></a>
<p>最初用到加密算法，是和锎锎他们做一个英语学习平台应用，在对用户密码进行申请提交的时候，考虑到信息流安全性的问题，对密码进行了一个简单的MD5加密算法加密。我们在加密之前先在密码末尾加一串内部约定的字符串，再对密码进行加密，最后截取其中一部分字符串进行密码提交与登录匹配。这是我第一次对加密算法有了接触。后来在使用支付宝支付SDK集成的过程中，我又知道了Base64、RSA、SHA1、SHA2加密算法，前者是在提交支付信息时有进行加密，后三个则是对商户私钥公钥等的计算加密。不过，我完全不了解这些算法的加密原理和使用领域，今天来了兴趣，就查一下吧。至于加密算法代码的实现，以后再说。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>加密算法主要分为以下三类：</p>
<ul>
<li>对称加密算法</li>
</ul>
<p>包括AES、DES、3DES等。加密和解密用到的密钥相同，加密速度快，适合经常发送数据的场所，但密钥传输需要格外注意。</p>
<ul>
<li>非对称加密\公钥加密算法</li>
</ul>
<p>包括RSA、DSA、ECC等。加密和解密的密钥不同，加密方式通常采用数学难题所构造，加密速度慢，适合偶尔发送数据的场所，密钥传输方便。</p>
<ul>
<li>安全散列算法</li>
</ul>
<p>包括MD5、SHA1、HMAC等。严格意义来说，加密算法需要满足加密与解密两个条件；而安全散列算法是不可逆的算法计算，所以其实不是加密算法之流。</p>
<h1 id="Base64加密算法"><a href="#Base64加密算法" class="headerlink" title="Base64加密算法"></a>Base64加密算法</h1><p>第二次碰到Base64加密算法，是在金云天的个人简历博客看到的。当时不太懂，只是觉得联系方式那串字符串末尾有一个熟悉的“=”号，在查找加密算法的时候歪打正着的查到了Base64加密算法，也就有了初步的认识。起因说完了，现在就来学习一下加密原理。</p>
<h2 id="加密原理"><a href="#加密原理" class="headerlink" title="加密原理"></a>加密原理</h2><p>我们先拿到一个要加密的字符串，将单个字符先按照ASCII码表转换为对应的数字，再将数字转换为8位的二进制数。得到全部的二进制数后，按6位划分开来，得到一个6位二进制数的全新数列，此时，再将数列转换为10进制。转换完毕后，按照Base64索引表，将数字转换为对应的字符，这样就完成了转换。</p>
<p>下面我附上Base64的索引表：</p>
<p><img src="/2018/10/16/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/1.jpg" alt></p>
<h2 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h2><p>举例，以我的博客名称“QingMi”为要加密的字符串。我们先将QingMi转换为ASCII码表对应的数字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">81 105 110 103 77 105</span><br></pre></td></tr></table></figure>
<p>再转换为二进制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01010001 01101001 01101110 01100111 01001101 01101001</span><br></pre></td></tr></table></figure>
<p>将这个数列按6位一组划分开来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">010100 010110 100101 101110 011001 110100 110101 101001</span><br></pre></td></tr></table></figure>
<p>转为十进制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20 22 37 46 25 52 53 41</span><br></pre></td></tr></table></figure>
<p>按照Base64索引表转换为字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UWluZ01p</span><br></pre></td></tr></table></figure>
<p>跟在线转换的网站的结果对比了一下，没有问题。</p>
<p>但是，这个转换过程存在一个问题：8位的二进制按6位划分的时候，最后的末尾不足6位怎么办。不急，这里还是有解决方案的。我们还是拿“QingM”来举例，接着走一遍刚才的步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">81 105 110 103 77</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01010001 01101001 01101110 01100111 01001101</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">010100 010110 100101 101110 011001 110100 1101</span><br></pre></td></tr></table></figure>
<p>走到这一步的时候，我们就需要在末尾补足0了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">010100 010110 100101 101110 011001 110100 110100</span><br></pre></td></tr></table></figure>
<p><strong>但是，还没有结束。</strong>我们还需要对加密的字符串的长度进行一下除3求余计算。这里长度是5，除3余2。如果余2，则在补足0后，<strong>在数列后加一个000000，但此数列不参与索引表转换，在最后只转换为“=”号</strong>；如果余1，<strong>则加两个000000</strong>。</p>
<p>那么此时，应当添加一个000000：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">010100 010110 100101 101110 011001 110100 110100 000000</span><br></pre></td></tr></table></figure>
<p>转换为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20 22 37 46 25 52 52</span><br></pre></td></tr></table></figure>
<p>末尾不参与索引表字符转换，直接在末尾添加一个“=”：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UWluZ00&#x3D;</span><br></pre></td></tr></table></figure>
<p>ok，转换完成。</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p><del>（我本不想讲用途的，但一想到以后若是与人谈论加密算法，却不知道用途，未免也太尴尬了些）</del></p>
<p>Base64编码在Java的Hibernate中有应用，也可用于HTTP环境下传递标识信息，但碍于“/”与“+”号在URL中会发生形式变化，不利于数据库数据的存储，所以有一些改进的Base64编码将最后的“/”与“+”号替换为“-”与“_”等。</p>
<h1 id="RSA加密算法"><a href="#RSA加密算法" class="headerlink" title="RSA加密算法"></a>RSA加密算法</h1><p>在查RSA加密算法之前，我绝没有想到它竟然是如此重量级的安全加密算法。它的加密原理，跟我上一个查过的Base64加密算法原理相差如此之大，涉及了很多高数的算法，让我这个高数一般的人学起来简直头大的不行。但既然已经查了，那我就把看来的东西整理一下。</p>
<p>首先要学习RSA用到的四个数学概念。</p>
<h2 id="理论知识准备"><a href="#理论知识准备" class="headerlink" title="理论知识准备"></a>理论知识准备</h2><p>1、<strong>互质</strong></p>
<p>如果两个正整数，没有除1以外的公约数，则这两个数是互质关系。并不一定只有质数之间才是互质关系，比如8和9，也是互质关系。</p>
<p>2、<strong>欧拉函数</strong></p>
<p>给定一个正整数$n$，求在小于等于$n$的正整数之中，与$n$构成互质关系的数的个数。计算这个数的函数称作欧拉函数，公式用$Φ(n)$表示。</p>
<ul>
<li><p>$n$=1时，$Φ(n)=1$</p>
</li>
<li><p>$n$是质数，则$Φ(n)=n-1$</p>
</li>
<li><p>$n$是质数的某一个次方，则$Φ(p^k)=p^k-p^{k-1}=p^k(1-\cfrac{1}{p})$</p>
</li>
<li><p>$n$可以分解为两互质整数之积，如$n=p_1p_2$，则$Φ(n)=Φ(p_1p_2)=Φ(p_1)Φ(p_2)$</p>
</li>
<li><p>因为任意一个大于1的正整数，都可以写成一系列质数的积，即$n=p_1p_2……p_r$;</p>
</li>
</ul>
<p>转换为$Φ(n)=Φ(p_1)Φ(p_2)……Φ(p_r)$；</p>
<p>最后得出$Φ(n)=n(1-\cfrac{1}{p_1})(1-\cfrac{1}{p_2})……(1-\cfrac{1}{p_r})$。</p>
<p>such as:$Φ(1323)=Φ(3^3*7^2)=1323(1-\cfrac{1}{3})(1-\cfrac{1}{7})=756$</p>
<p>3、<strong>欧拉定理</strong></p>
<p>如果两个正整数$a$与$n$互质，则满足以下等式：</p>
<p>$a^{Φ(n)}≡1\pmod n$</p>
<p>这个等式的意思是，$a$的$Φ(n)$次方被$n$除的余数为1，或者说，$a$的$Φ(n)$次方减去1可以被$n$整除。</p>
<p>当两者互质，且$n$为质数的时候，欧拉定理又可以写成：</p>
<p>$a^{p-1}≡1\pmod p$</p>
<p>这个等式又可以成为费马小定理。</p>
<p>4、<strong>模反元素</strong></p>
<p>如果两个正整数$a$和$n$互质，那么一定可以找到整数$b$，使得$ab-1$被$n$整除，即：</p>
<p>$ab≡1\pmod n$</p>
<p>此时$b$就成为$a$的模反元素。比如4与7互质，那么4的模反元素就是$2+7k$（$k$为整数）。欧拉定理有计算函数如下：</p>
<p>$a^{Φ(n)}=a*a^{Φ(n)-1}≡1\pmod n$</p>
<p>所以，$a^{Φ(n)-1}$就是$a$的模反元素。</p>
<h2 id="秘钥生成步骤"><a href="#秘钥生成步骤" class="headerlink" title="秘钥生成步骤"></a>秘钥生成步骤</h2><p>1、随机选择两个不相等的质数，$p$与$q$</p>
<p>此处取59和83</p>
<p>2、计算这两个数的乘积$n$</p>
<p>$59 * 83 = 4897$</p>
<p>3、计算乘积的欧拉函数$Φ(n)$</p>
<p>$Φ(4897)=58 * 82 = 4756$</p>
<p>4、随机选择一个整数$e$，条件是<strong>1&lt;e&lt;Φ(n)，且e与Φ(n)互质</strong></p>
<p>此处取23</p>
<p>5、计算$e$与$Φ(n)$的模反元素$d$</p>
<p>$ed≡1\pmod Φ(n)$</p>
<p>等价于 $ed - 1 = kΦ(n)$</p>
<p>得到 $ed + kΦ(n) = 1$ （不用在意$k$转换前后的符号，计算的时候代入符号转换即可）</p>
<p>代入数，得到 $23d + 4756k = 1$</p>
<p>采用<a href="https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95">扩展欧几里得算法</a>求解，过程如下：</p>
<p>先用类似辗转相除法，做以下计算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4756&#x3D;23*206+18</span><br><span class="line">23&#x3D;18*1+5</span><br><span class="line">18&#x3D;5*3+3</span><br><span class="line">5&#x3D;3*1+2</span><br><span class="line">3&#x3D;2*1+1</span><br></pre></td></tr></table></figure>
<p>然后改写成“余数等于”的形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18&#x3D;4756+23*(-206)	&#x2F;&#x2F;式1</span><br><span class="line">5&#x3D;23+18*(-1)		&#x2F;&#x2F;式2</span><br><span class="line">3&#x3D;18+5*(-3)			&#x2F;&#x2F;式3</span><br><span class="line">2&#x3D;5+3*(-1)			&#x2F;&#x2F;式4</span><br><span class="line">1&#x3D;3+2*(-1)</span><br></pre></td></tr></table></figure>
<p>然后开始“倒回来：计算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#x3D;3+2*(-1)</span><br><span class="line"> &#x3D;3+[5+3*(-1)]*(-1)				&#x2F;&#x2F;代入式4</span><br><span class="line"> &#x3D;3*2+5*(-1)</span><br><span class="line"> &#x3D;[18+5*(-3)]*2+5*(-1)			&#x2F;&#x2F;代入式3</span><br><span class="line"> &#x3D;18*2+5*(-7)</span><br><span class="line"> &#x3D;18*2+[23+18*(-1)]*(-7)		&#x2F;&#x2F;代入式2</span><br><span class="line"> &#x3D;18*9+23*(-1)</span><br><span class="line"> &#x3D;[4756+23*(-206)]*9+23*(-7)	&#x2F;&#x2F;代入式1</span><br><span class="line"> &#x3D;4756*9+23*(-1861)</span><br></pre></td></tr></table></figure>
<p>到此可以得出，$d=-1861$,$k=9$。</p>
<p><del>（这方法对整数形式的二元一次方程真是一个万能解，流弊）</del></p>
<p>6、将$n$和$e$封装成公钥，$n$和$d$封装成私钥</p>
<p>先回顾一下我们算过的所有有用的数：$p=59$,$q=83$,$n=4897$,$Φ(4897)=4756$,$e=23$,$d=-1861$</p>
<p>公钥用$(n,e)$表达，私钥用$(n,d)$表达，那么计算出来的公钥就是$(4897,23)$，私钥为$(4897,-1861)$</p>
<p>7、加密与解密</p>
<p>费心费力的算了半天，还不知道这公钥私钥怎么用，我都感觉自己差不多白学了，所以这里就讲一下怎么用。</p>
<ul>
<li>加密</li>
</ul>
<p>假设A向B发送信息$m$，A用公钥$(n,e)$进行加密。注意，$m$必须是证书且$m&lt;n$。而加密，就是要算出下式的$c$：</p>
<p>$m^e=c\pmod n$</p>
<p>公钥是$(4897,23)$,取$m$为7,则式为： $7^{23}≡c\pmod {4897}$</p>
<p>计算得出：$c=3855$。那么3855就是加密后的数字，A把它给了B。</p>
<p><del>(这里我只能取个比较小的数。最开始取了个101，然后，101的23次方，计算器炸了，，，，，)</del></p>
<ul>
<li>解密</li>
</ul>
<p>B拿到了3855，又有私钥$(4897,-1861)$，那要怎么解密呢？代入以下等式计算：</p>
<p>$c^d=m\pmod n$</p>
<p>代入得 $3855^{-1861}≡m\pmod {4897}$</p>
<p>emmmmmmm，等等，3855的-1861次方，这尼玛怎么算，等等，参考的博客是2790的2753次方，他怎么算的？芽儿哟，这怎么解啊。。。。。。这特么尴尬了，举了个例子结果有私钥都没法算，嗯……这大概就是RSA的安全性所在吧。。。。。</p>
<p>8、RSA的算法可靠性</p>
<p>维基百科这样说：“对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。”但维基百科又报道，到目前为止，并没有一种固定可靠的算法可以破解RSA算法。尽管如此，曾有暴力破解的方式破解过768位的秘钥，但花费时间漫长，从破解512位到768位花了漫长的10年。不过，普遍建议应将秘钥从1024位升级到2048位。</p>
<p>至于算法的安全性证明，我就不看了，光是上面这个次方计算都有点头疼。我知道有些算法可以优化次方运算，不过那是以后学习其他算法的事情了。原理明白就行了。想看安全性证明的，我在这里挂上参考博客链接：</p>
<p><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">RSA算法原理</a></p>
<h1 id="MD5摘要算法"><a href="#MD5摘要算法" class="headerlink" title="MD5摘要算法"></a>MD5摘要算法</h1><p>好吧，看来是Base64算法过于简单，让我产生了一部分算法都是简单的符号映射的错觉。在查阅MD5加密算法的资料过程中，MD5算法的过程运算让我更加头大。嘛，行吧，加密算法不难的话怎么能称为加密算法呢。</p>
<p>MD5算法是经由MD2、MD3、MD4发展而来。它的最大特点是，可以将任意长度的字节串变换成定长的字符串，现目前流行的有16位与32位。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>MD5算法是将输入的不定长度信息，输出固定长度为128-bits的算法。</p>
<h3 id="数据填充"><a href="#数据填充" class="headerlink" title="数据填充"></a>数据填充</h3><p>MD5算法对数据填充分两个步骤：</p>
<ul>
<li>1、<strong>填充信息至信息长度对512取模得448</strong></li>
</ul>
<p>填充方法：在信息后面填充一个1与无数个0，直至满足第一个条件</p>
<ul>
<li>2、<strong>在信息末尾添加信息长度的信息</strong></li>
</ul>
<p>看起来很绕，其实就是在上一步填充完的信息后，添加一个64位长度的二进制位数信息。这样一来，448+64=512，整个信息的长度还是可以被512整除的。这样做的话，在后面处理信息的时候也比较方便。</p>
<p>MD5会把信息以512位分组，再将每一分组划分为16个32位子分组。</p>
<h3 id="数据计算"><a href="#数据计算" class="headerlink" title="数据计算"></a>数据计算</h3><ul>
<li>四个被称作链接变量的常数：$A=0x67452301$,$B=0xEFCDAB89$,$C=0x98BADCFE$,$D=0x10325476$</li>
</ul>
<p>分别赋予小写$a$、$b$、$c$、$d$</p>
<p><del>(常数值与部分博客有出入，但观察一下，发现四个常数值的数字顺序是有规律的颠倒放置，至于原因还不知道)</del></p>
<ul>
<li>四个非线性函数</li>
</ul>
<p>$F(X,Y,Z)$ = ($X$ &amp; $Y$) | ($~X$ &amp; $Z$)</p>
<p>$G(X,Y,Z)$ = ($X$ &amp; $Z$) | ($Y$ &amp; $~Z$)</p>
<p>$H(X,Y,Z)$ = $X$ ^ $Y$ ^ $Z$</p>
<p>$I(X,Y,Z)$ = $Y$ ^ ($X$ | $~Z$)</p>
<p>准备完毕，下面就开始讲计算过程。</p>
<p>计算过程主要是四轮循环运算；每轮循环运算的次数，是512位信息分组的数目，即多少个32位信息组；每次运算，对$a$、$b$、$c$和$d$的其中三个做一次非线性函数运算，然后将所得结果加上第四个变量，文本信息的一个子分组，一个常数，将结果向右移一个不定的数，加上$a$、$b$、$c$、$d$其中之一，并用结果取代$a$、$b$、$c$、$d$之一。听起来很糊涂，那就看一下算式：</p>
<p>$F(a,b,c,d,M_j,s,t_i)表示a=b+(a+F(b,c,d)+M_j+t_i)&lt;&lt;$</p>
<p>其中$M_j$指文本信息子分组，$t_i$是常数，至于$s$，我猜是位移的数吧</p>
<p>这样经过几轮计算之后，将最后计算出来的$a$、$b$、$c$、$d$输出，就是最后的MD5值了。32位的MD5值是完整的计算结果，而16位的MD5值是截取的32位值的9~24位。</p>
<h2 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h2><p>1、常用作文件下载的核对，用于校验文件在下载过程中是否遭到不法程序篡改。</p>
<p>2、很多网站用来存储用户的密码，鉴于MD5算法的不可逆性，很难算出密码原文内容，所以经常用来做用户注册时密码的存储与登录时密码的核对。</p>
<p>3、数字签名。MD5也经常用作第三方认证机构的文件摘要信息比对，称“数字签名”。</p>
<p>PS：MD5算法现在已经不再完全可靠，已经有国内的科学院研究者破解了MD5的碰撞抵抗。</p>
<h1 id="AES加密算法"><a href="#AES加密算法" class="headerlink" title="AES加密算法"></a>AES加密算法</h1><p>查阅资料的时候，发现DES算法因已遭到破解，不再是安全的加密算法，所以又改换成学习AES加密算法。因为我实在看的有些困难，所以先贴上我参考的两篇比较好的详解博客：</p>
<p><a href="https://blog.csdn.net/qq_28205153/article/details/55798628">AES加密算法的详细介绍与实现</a></p>
<p><a href="https://www.cnblogs.com/luop/p/4334160.html">密码算法详解——AES</a></p>
<h2 id="加密原理-1"><a href="#加密原理-1" class="headerlink" title="加密原理"></a>加密原理</h2><p>AES是一种区块加密算法，即分组加密，将明文分成多个等长的模块，直至加密完所有明文。AES标准规范中，分组只能是128位，即每个分组为16个字节。但密钥的长度可以选择128位、192位或256位，每个选择对应的推荐加密轮数也不同，如下所示：</p>
<p><img src="/2018/10/16/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/3.jpg" alt></p>
<h2 id="加密步骤"><a href="#加密步骤" class="headerlink" title="加密步骤"></a>加密步骤</h2><p>因为过程很长，所以我先对整个过程做一个概要阐述：以AES-128举例，AES算法先将明文分组，每组被分为16个字节，用4x4的明文矩阵表示；然后将每组的明文矩阵转换为状态矩阵；然后进入AES的10轮加密，每轮加密均需要依次进行4个步骤，字节代换、行移位、列混合、轮密钥加（第一轮加密之前需先进行一次轮密钥加，最后一轮加密不需进行列混合）；最后，将输出的加密过后的状态矩阵替换为字符串，得到的即是密文。解密的过程，则是将上述的加密过程逆向进行即可。流程如下图所示：</p>
<p><img src="/2018/10/16/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/2.jpg" alt></p>
<h3 id="矩阵预处理"><a href="#矩阵预处理" class="headerlink" title="矩阵预处理"></a>矩阵预处理</h3><p>假设明文已被分好，第一组如下所示：</p>
<script type="math/tex; mode=display">
  \left[
  \begin{matrix}
   a & e & i & m \\\
   b & f & j & n \\\
   c & g & k & o \\\
   d & h & l & p
  \end{matrix}
  \right] \tag{1}</script><p>先将矩阵转换为状态矩阵，方法是只需将字符串转换为对应的十六进制即可：</p>
<script type="math/tex; mode=display">
  \left[
  \begin{matrix}
   0x61 & 0x65 & 0x69 & 0x6D \\\
   0x62 & 0x66 & 0x6A & 0x6E \\\
   0x63 & 0x67 & 0x6B & 0x6F \\\
   0x64 & 0x68 & 0x6C & 0x70
  \end{matrix}
  \right] \tag{2}</script><p>接下来该进行轮密钥加了。但考虑到我没办法进行10次加密运算，只能将每个步骤的计算方法讲清楚就行了，所以我把轮密钥加放在每轮的加密步骤中讲解。</p>
<h3 id="字节代换"><a href="#字节代换" class="headerlink" title="字节代换"></a>字节代换</h3><p>字节代换其实是一个查表替换字符的操作，AES算法为此定义了一个S盒和逆S盒（S盒与逆S盒的字符位置是固定的，是按照公式<script type="math/tex">GF(2^8) = GF(2)[x]/(x^8 + x^4 + x^3 + x + 1)</script>计算来的，有兴趣的可以去查一下）。表如下所示：</p>
<p><img src="/2018/10/16/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/4.jpg" alt></p>
<p><img src="/2018/10/16/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/5.jpg" alt></p>
<p>替换规则其实很简单：将原文的高4位作为行值，低4位作为列值，找到对应的元素，输出即可：</p>
<script type="math/tex; mode=display">
  \left[
  \begin{matrix}
   0xEF & 0x4D & 0xF9 & 0x3C \\\
   0xAA & 0x33 & 0x02 & 0x9F \\\
   0xFB & 0x85 & 0x7F & 0xA8 \\\
   0x43 & 0x45 & 0x50 & 0x51
  \end{matrix}
  \right] \tag{3}</script><p>逆向解密则从逆S盒取值即可。</p>
<h3 id="行移位"><a href="#行移位" class="headerlink" title="行移位"></a>行移位</h3><p>行移位是一个左循环移位操作。密钥长度为128位时，加密时，矩阵第0行左移0位，第1行左移1位，第2行左移2位，第3行左移3位。同理，解密时逆向即可。</p>
<script type="math/tex; mode=display">
  \left[
  \begin{matrix}
   0xEF & 0x4D & 0xF9 & 0x3C \\\
   0x33 & 0x02 & 0x9F & 0xAA \\\
   0x7F & 0xA8 & 0xFB & 0x85 \\\
   0x51 & 0x43 & 0x45 & 0x50
  \end{matrix}
  \right] \tag{4}</script><h3 id="列混合"><a href="#列混合" class="headerlink" title="列混合"></a>列混合</h3><p>列混合运算是将移位后的状态矩阵与固定的壶镇相乘，得到计算后的状态矩阵。固定矩阵如下：</p>
<script type="math/tex; mode=display">
  \left[
  \begin{matrix}
   02 & 03 & 01 & 01 \\\
   01 & 02 & 03 & 01 \\\
   01 & 01 & 02 & 03 \\\
   03 & 01 & 01 & 02
  \end{matrix}
  \right] \tag{5}</script><p>比如第一行第一列的元素的计算：</p>
<p>$S=(2\times0xEF)\bigotimes 0x4D \bigotimes 0xF9 \bigotimes (3\times0x3C)$</p>
<p>运算规则：1、对于2进制来说，乘以2即是将数左移一位。如果原数最高位为1，则需要在移位后再同（0001 1011）进行异或运算，比如$2\times0xEF$:</p>
<p>EF转换为二进制即为：1110 1111</p>
<p>乘2左移一位：1101 1110</p>
<p>因原最高位为1，故与0001 1011进行异或运算，得到：</p>
<p>1100 0101</p>
<p>这就是$2\times0xEF$的运算结果。</p>
<p>2、对于乘3运算，需要用分配率来进行运算，如$3\times0x3C$：</p>
<p>$3\times0x3C=(2+1)\times0011 1100=0111 1000\bigotimes0011 1100=0100 0100$</p>
<p>3、这样一来，就只剩下异或运算了，这就不用多说了吧：</p>
<p>1100 0101<br>0100 1101<br>1111 1001<br>0100 0100</p>
<p>得到结果：0011 0101</p>
<p>转换为十六进制即为：$0x35$</p>
<p>计算的过程如果手算那就太麻烦了，所以尽管可能多花了点时间，我还是写了点Java代码来实现计算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;存放状态矩阵</span><br><span class="line">        int a[][] &#x3D; new int[][]&#123;&#123;0xEF,0x4D,0xF9,0x3C&#125;,&#123;0x33,0x02,0x9F,0xAA&#125;,&#123;0x7F,0xA8,0xFB,0x85&#125;,&#123;0x51,0x43,0x45,0x50&#125;&#125;;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;存放要相乘的固定矩阵</span><br><span class="line">        int b[][] &#x3D; new int[][]&#123;&#123;2,3,1,1&#125;,&#123;1,2,3,1&#125;,&#123;1,1,2,3&#125;,&#123;3,1,1,2&#125;&#125;;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;存放计算后的状态矩阵</span><br><span class="line">        int c[][] &#x3D; new int[4][4];</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;先将后状态矩阵赋值为0</span><br><span class="line">        for(int i&#x3D;0;i&lt;4;i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;4;j++)&#123;</span><br><span class="line">                c[i][j]&#x3D;0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Main main &#x3D; new Main();</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;0;i&lt;4;i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;4;j++)&#123;</span><br><span class="line">                &#x2F;&#x2F;为方便理解下面的循环，在这里列出16次计算时每次计算的公式</span><br><span class="line">				&#x2F;&#x2F;c[i][j]&#x3D;a[i][0]*b[0][j]+a[i][1]*b[1][j]+a[i][2]*c[2][j]+a[i][3]*b[3][j];</span><br><span class="line">                int res &#x3D; 0;</span><br><span class="line">                for(int k&#x3D;0;k&lt;4;k++)&#123;</span><br><span class="line">                    if(b[k][j]&#x3D;&#x3D;2)&#123;</span><br><span class="line">                        res &#x3D; res ^ main.doubleCal(a[i][k]);</span><br><span class="line">                    &#125;else if(b[k][j]&#x3D;&#x3D;3)&#123;</span><br><span class="line">                        res &#x3D; res ^ main.tripleCal(a[i][k]);</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        res &#x3D; res ^ a[i][k];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                c[i][j]&#x3D;res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;输出计算后的状态矩阵</span><br><span class="line">        for(int i&#x3D;0;i&lt;4;i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;4;j++)&#123;</span><br><span class="line">				&#x2F;&#x2F;Integer.toHexString方法，可将十进制转化为十六进制输出；十六进制转化为十进制则为Integer.parseInt方法</span><br><span class="line">                System.out.print(Integer.toHexString(c[i][j])+&quot;  &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;乘2运算的情况处理</span><br><span class="line">    public int doubleCal(int a)&#123;</span><br><span class="line">		&#x2F;&#x2F;若a的最高位为1，即a大于127，则先移位，但移位不减值，故再减去超出8位的值，再与0001 1011，即27，进行异或运算</span><br><span class="line">        if(a&gt;127)&#123;</span><br><span class="line">            a &#x3D; a &lt;&lt; 1;</span><br><span class="line">            a -&#x3D; 256;</span><br><span class="line">            a &#x3D; a ^ 27;</span><br><span class="line">            return a;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            a &#x3D; a &lt;&lt; 1;</span><br><span class="line">            return a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;乘3运算的情况处理</span><br><span class="line">    public int tripleCal(int a)&#123;</span><br><span class="line">        a &#x3D; doubleCal(a) ^ a;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后计算出的结果是：</p>
<script type="math/tex; mode=display">
  \left[
  \begin{matrix}
   0x35 & 0x75 & 0xED & 0xCA \\\
   0x1E & 0x64 & 0xBA & 0xC4 \\\
   0x39 & 0xB4 & 0xF4 & 0xD0 \\\
   0x54 & 0x60 & 0x4E & 0x7D
  \end{matrix}
  \right] \tag{6}</script><p>逆运算的话，则是乘以上述固定矩阵的逆矩阵即可，该逆矩阵如下：</p>
<script type="math/tex; mode=display">
  \left[
  \begin{matrix}
   0x0E & 0x0B & 0x0D & 0x09 \\\
   0x09 & 0x0E & 0x0B & 0x0D \\\
   0x0D & 0x09 & 0x0E & 0x0B \\\
   0x0B & 0x0D & 0x09 & 0x0E
  \end{matrix}
  \right] \tag{7}</script><h3 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h3><p>轮密钥加则是将128位轮密钥同状态矩阵中的数据进行异或运算。密钥分成4组，每组32位字，状态矩阵取每列四个元素组成的32位字，依次对应进行异或运算，得到加密后的新状态矩阵。</p>
<p>在逆运算时，密钥不需改变，因为异或运算的特性，再次运算即可得到加密前的矩阵。</p>
<h3 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a>密钥扩展</h3><p>有一项事情需要注意：每一轮异或运算的密钥是在不断变化的。接下来就是了解一下，密钥变化的规律。</p>
<p>假设密钥Key为“abcdefghijklmnop”，则有$W[0]=“abcd”$,$W[1]=“efgh”$,$W[2]=“ijkl”$,$w[3]=“mnop”$。这是在进行10轮加密之前，最初的加密密钥。而接下来10轮所用到的40个新列$W[i]$，则以以下的规律计算：</p>
<p>1、如果i不是4的倍数</p>
<p>$W[i]=W[i-4] \bigotimes W[i-1]$</p>
<p>2、如果i是4的倍数</p>
<p>$W[i]=w[i-4] \bigotimes T(W[i-1])$</p>
<p>这里，T是一个由3部分组成的函数，包括字循环、字节代换和轮常量异或，分别如下：</p>
<p>$a$.字循环：将字节循环左移1个字节，如“abcd”变为“bcda”。</p>
<p>$b$.字节代换：这个不用多说，使用表为S盒。</p>
<p>$c$.轮常量异或：将值与轮常量进行异或，每一轮异或的值均不同，其表如下：</p>
<p><img src="/2018/10/16/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/6.jpg" alt></p>
<p>比如上述密钥可转化为“61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F 70”。那么4个初始值为：</p>
<p>$W[0]$=61 62 63 64</p>
<p>$W[1]$=65 66 67 68</p>
<p>$W[2]$=69 6A 6B 6C</p>
<p>$W[3]$=6D 6E 6F 70</p>
<p>求$W[4]$、$W[5]$、$W[6]$、$W[7]$</p>
<p>$W[4]=w[0] \bigotimes T(W[3])$</p>
<p>$T(W[3])$计算步骤：</p>
<p>1、6D 6E 6F 70输出变为6E 6F 70 6D</p>
<p>2、在S盒中找到对应字节，输出9F A8 51 3C</p>
<p>3、第一轮加密异或的数组为01 00 00 00,运算后输出9E A8 51 3C。</p>
<p>所以$T(W[3])$=9E A8 51 3C。</p>
<p>所以$W[4]$=61 62 63 64 $\bigotimes$ 9E A8 51 3C=FF CA 32 58</p>
<p>$W[5]=W[1] \bigotimes W[4]$=65 66 67 68 $\bigotimes$ FF CA 32 58=99 AC 55 30</p>
<p>$W[6]=W[2] \bigotimes W[5]$=69 6A 6B 6C $\bigotimes$ 99 AC 55 30=F0 C6 3E 5C</p>
<p>$W[7]=W[3] \bigotimes W[6]$=6D 6E 6F 70 $\bigotimes$ F0 C6 3E 5C=9D A8 51 2C</p>
<p>将所有结果组合起来，即为第一轮的密钥:FF CA 32 58 99 AC 55 30 F0 C6 3E 5C 9D A8 51 2C</p>
<h2 id="用途-2"><a href="#用途-2" class="headerlink" title="用途"></a>用途</h2><p>介于DES算法已被破解的事实，很多文件开始向3DES和AES加密靠拢。AES加密算法也并非牢不可破，目前已有成功的对AES算法的尝试攻击，不过距离算法的正式破解，还有一些难度。此外也有一些不针对算法，而针对算法系统或是安全系统的旁道攻击，不过这些攻击，就都是算法研究的题外话了。</p>
<p><del>（哇，终于把这个AES写完了，累死了。）</del></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这几章算法我均只讲解了初步原理。在查询及亲自使用在线加密算法的时候，深感每个算法均有很多不同的模式，而这些模式在原理讲解的博客中均未提及，可能是在代码实现的过程中有所差异？不过鉴于目前我还不会过度深入代码的实现，所以就点到为止。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>排序算法一直以来是我学的比较乱的一个部分，分不太清很多常用算法的特点。这次趁着写博客，我仔细捋一捋我听说过的算法。wiki百科上给出了很全的算法目录，我点了点，有一半的算法连名字都没听过，尤其是不实用算法的那五个，就不多做阐述了。</p>
<p>本篇博客排序的适用规模从小到大。</p>
<a id="more"></a>
<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>在讲解算法之前，要先考虑清楚，一个算法孰优孰劣，应该有怎样的评判标准。我觉得wiki百科上给出的几点很明确了，我就在这里直接引用了。</p>
<p>评判标准：</p>
<blockquote>
<ul>
<li><strong>计算的时间复杂度</strong>：（最差、最优及平均），依据列表的大小($n$)。一般而言，好的性能是$O(nlogn)$，坏的性能是$O(n^2)$。</li>
<li><strong>内存使用量</strong>：以及其他电脑资源的使用</li>
<li><strong>稳定性</strong>：稳定排序算法会让原本有相同键值的记录维持相对次序。比如说5，2，5，6，排完序后第一个5依然在第二个5之前，称稳定。但很多情况下，排列的元素并不会只是一个数字，多数为有很多属性的元素，所以稳定性就显得格外重要。</li>
</ul>
</blockquote>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>工作原理：重复走访过要排序的数列，一次比较两个元素，如果顺序错误就把他们交换过来，重复至到没有再需要交换，则排序完成。</p>
<p>算法描述：<br>1、比较相邻元素。如果第一个比第二个大（或小），则交换。<br>2、对当前范围每一对相邻元素做比较。结束时，最后的元素是最大值（或最开始的元素是最小值）。<br>3、缩小比较范围。<br>4、重复操作2、3，直至范围变为1，即不再需要比较。</p>
<p><strong>计算的时间复杂度</strong>：</p>
<blockquote>
<ul>
<li>最坏：$O(n^2)$</li>
<li>最优：$O(n)$</li>
<li>平均：$O(n^2)$</li>
</ul>
</blockquote>
<p><strong>内存使用量</strong>：</p>
<blockquote>
<ul>
<li>空间复杂度：需要辅助空间$O(1)$</li>
</ul>
</blockquote>
<p><strong>稳定性</strong>：<strong>稳定</strong></p>
<p><strong>特点</strong>：简单，稳定，但效率低下。</p>
<p>Java代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void bubbleSort(int arr[]) &#123;</span><br><span class="line">        int len &#x3D; arr.length;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">            for(int j &#x3D; 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class="line">                if(arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                    int temp &#x3D; arr[j];</span><br><span class="line">                    arr[j] &#x3D; arr[j + 1];</span><br><span class="line">                    arr[j + 1] &#x3D; temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>示意图</strong>：</p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/BubbleSort.gif" alt></p>
<p><strong>鸡尾酒排序</strong></p>
<p>鸡尾酒排序属于冒泡排序的一种变形，不同的是冒泡每次循环是单向，但鸡尾酒是双向。</p>
<p>大部分特点与冒泡排序一样。若排序是大部分已经排序过的话，会接近$O(n)$。</p>
<p><strong>示意图</strong>：</p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/CocktailSort.gif" alt></p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<p>算法描述：<br>1、将未排序序列的第一个元素标记为最小值<br>2、遍历当前未排序序列，找出最小值并标记<br>3、将最小值放至已排序序列末尾<br>4、重复1、2、3，直至未排序序列为空</p>
<p><strong>计算的时间复杂度</strong>：</p>
<blockquote>
<ul>
<li>最优、最差及平均：$O(n^2)$</li>
</ul>
</blockquote>
<p><strong>内存使用量</strong>：</p>
<blockquote>
<ul>
<li>空间复杂度：需要辅助空间$O(1)$</li>
</ul>
</blockquote>
<p><strong>稳定性</strong>：<strong>不稳定</strong></p>
<p><strong>特点</strong>：数据量较小时，选择排序比冒泡排序要快。原地操作几乎是选择排序的唯一优点，空间复杂度要求较高时，可选择此排序；然而实际应用比较罕见。</p>
<p>Java代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void selectionSort(int[] arr) &#123;</span><br><span class="line">        int i, j, min, temp, len &#x3D; arr.length;</span><br><span class="line">        for (i &#x3D; 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">            min &#x3D; i;&#x2F;&#x2F;未排序序列中最小数据数组下标</span><br><span class="line">            for (j &#x3D; i + 1; j &lt; len; j++)&#x2F;&#x2F;在未排序元素中继续寻找最小元素，并保存其下标</span><br><span class="line">                if (arr[min] &gt; arr[j]) &#123;</span><br><span class="line">                    min &#x3D; j;</span><br><span class="line">                &#125;</span><br><span class="line">            temp &#x3D; arr[min]; &#x2F;&#x2F;将最小元素放到已排序序列的末尾</span><br><span class="line">            arr[min] &#x3D; arr[i];</span><br><span class="line">            arr[i] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>示意图</strong>：</p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/SelectionSort.gif" alt></p>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>工作原理：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。其实插入排序的过程与玩手牌一样，从后往前查看比较，找到相应的位置插入即可。</p>
<p>算法描述：<br>1、从第一个元素开始，可以认为它已被排序<br>2、取出下一个元素，在已排序序列中从后往前扫描<br>3、若某元素大于新元素，将该元素移至下一位置，如此重复，直至找到小于新元素的位置，将新元素插入该位置后<br>4、重复操作3</p>
<p><strong>计算的时间复杂度</strong>：</p>
<blockquote>
<ul>
<li>最坏：$O(n^2)$</li>
<li>最优：$O(n)$</li>
<li>平均：$O(n^2)$</li>
</ul>
</blockquote>
<p><strong>内存使用量</strong>：</p>
<blockquote>
<ul>
<li>空间复杂度：需要辅助空间$O(1)$</li>
</ul>
</blockquote>
<p><strong>稳定性</strong>：<strong>稳定</strong></p>
<p><strong>特点</strong>：不适合数据量比较大的排序应用。如果数据量小于千，或输入元素大致上按顺序排列，那么插入排序是一个不错的选择。</p>
<p>Java代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void insertionSort(int[] arr) &#123;</span><br><span class="line">        for(int i &#x3D; 0; i&lt;arr.length-1; i++) &#123;</span><br><span class="line">            for(int j &#x3D; i + 1; j &gt; 0; j--) &#123;</span><br><span class="line">                if(arr[j - 1] &lt;&#x3D; arr[j])</span><br><span class="line">                    break;</span><br><span class="line">                int temp &#x3D; arr[j];</span><br><span class="line">                arr[j] &#x3D; arr[j - 1];</span><br><span class="line">                arr[j - 1] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>示意图</strong>：</p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/InsertionSort-example.gif" alt></p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/InsertionSort.gif" alt></p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>也称递减增量排序算法，是插入排序的一种更高效的改进版本。</p>
<p>工作原理：将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素一次性地朝最终位置前进一大步，然后算法再取越来越小的步长进行排序，到最后一步，即变成了普通的插入排序。不过在最后，所有数据基本已经排序好了。</p>
<p>算法描述：<br>例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13 14 94 33 82</span><br><span class="line">25 59 94 65 23</span><br><span class="line">45 27 73 25 39</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>然后我们对<strong>每列</strong>进行排序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 14 73 25 23</span><br><span class="line">13 27 94 33 39</span><br><span class="line">25 59 94 65 82</span><br><span class="line">45</span><br></pre></td></tr></table></figure>
<p>然后再以3为步长进行划分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 14 73</span><br><span class="line">25 23 13</span><br><span class="line">27 94 33</span><br><span class="line">39 25 59</span><br><span class="line">94 65 82</span><br><span class="line">45</span><br></pre></td></tr></table></figure>
<p>排序后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 14 13</span><br><span class="line">25 23 33</span><br><span class="line">27 25 59</span><br><span class="line">39 65 73</span><br><span class="line">45 94 82</span><br><span class="line">94</span><br></pre></td></tr></table></figure>
<p>最后再以1为步长进行排序，此时就是简单的插入排序了</p>
<p><strong>重点</strong>：步长的选择是希尔排序的重要部分</p>
<p>Donald Shell(设计者)最初建议选择步长为$\frac {n}{2}$</p>
<p>已知的最好步长序列是（1，5，19，41，109，……）（详情见<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a>）</p>
<p><strong>计算的时间复杂度</strong>：</p>
<blockquote>
<ul>
<li>最优：$O(n)$</li>
<li>最差：$O((nlogn)^2)$</li>
<li>平均：$O((nlogn)^2)$</li>
</ul>
</blockquote>
<p><strong>内存使用量</strong>：</p>
<blockquote>
<ul>
<li>空间复杂度：需要辅助空间$O(1)$</li>
</ul>
</blockquote>
<p><strong>稳定性</strong>：<strong>不稳定</strong></p>
<p><strong>特点</strong>：在使用最优步长序列时，比插入排序快。在较小数组中，比快速排序和堆排序还要快。但若涉及大量数据，速度依旧不及快速排序。</p>
<p>Java代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void shellSort(int[] arr) &#123;</span><br><span class="line">	int gap &#x3D; 1, i, j, len &#x3D; arr.length;</span><br><span class="line">	int temp;</span><br><span class="line">	while (gap &lt; len &#x2F; 3)</span><br><span class="line">		gap &#x3D; gap * 3 + 1; </span><br><span class="line">	for (; gap &gt; 0; gap &#x2F;&#x3D; 3)</span><br><span class="line">		for (i &#x3D; gap; i &lt; len; i++) &#123;</span><br><span class="line">			temp &#x3D; arr[i];</span><br><span class="line">			for (j &#x3D; i - gap; j &gt;&#x3D; 0 &amp;&amp; arr[j] &gt; temp; j -&#x3D; gap)</span><br><span class="line">				arr[j + gap] &#x3D; arr[j];</span><br><span class="line">			arr[j + gap] &#x3D; temp;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的代码中的步长取$\frac {n}{3}$</p>
<p><strong>示意图</strong>：</p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/ShellSort.gif" alt></p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>工作原理：归并排序是采用<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95">分治法</a>的一个非常典型的应用。归并排序的思想是先递归分解数组，再合并数组。</p>
<p>算法描述（迭代法）：<br>1、申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>2、设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>3、比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>4、重复步骤3直到某一指针到达序列尾<br>5、将另一序列剩下的所有元素直接复制到合并序列尾</p>
<p>合并：基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。</p>
<p>分解：基本思路是将数组分解成left和right，如果这两个数组内部数据是有序的，那么就可以用上面合并数组的方法将这两个数组合并排序。如何让这两个数组内部是有序的？可以再二分，直至分解出的小组只含有一个元素时为止，此时认为该小组内部已有序。然后合并排序相邻二个小组即可。</p>
<p><strong>计算的时间复杂度</strong>：</p>
<blockquote>
<ul>
<li>最优、最差及平均：$O(nlogn)$</li>
</ul>
</blockquote>
<p><strong>内存使用量</strong>：</p>
<blockquote>
<ul>
<li>空间复杂度：所需辅助空间$O(n)$</li>
</ul>
</blockquote>
<p><strong>稳定性</strong>：<strong>稳定</strong></p>
<p>Java代码（迭代版）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void mergeSort(int[] arr) &#123;</span><br><span class="line">    int len &#x3D; arr.length;</span><br><span class="line">    int[] result &#x3D; new int[len];</span><br><span class="line">    int block, start;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 原版代码的迭代次数少了一次，没有考虑到奇数列数组的情况</span><br><span class="line">    for(block &#x3D; 1; block &lt; len; block *&#x3D; 2) &#123;</span><br><span class="line">        for(start &#x3D; 0; start &lt;len; start +&#x3D; 2 * block) &#123;</span><br><span class="line">            int low &#x3D; start;</span><br><span class="line">            int mid &#x3D; (start + block) &lt; len ? (start + block) : len;</span><br><span class="line">            int high &#x3D; (start + 2 * block) &lt; len ? (start + 2 * block) : len;</span><br><span class="line">            &#x2F;&#x2F;两个块的起始下标及结束下标</span><br><span class="line">            int start1 &#x3D; low, end1 &#x3D; mid;</span><br><span class="line">            int start2 &#x3D; mid, end2 &#x3D; high;</span><br><span class="line">            &#x2F;&#x2F;开始对两个block进行归并排序</span><br><span class="line">            while (start1 &lt; end1 &amp;&amp; start2 &lt; end2) &#123;</span><br><span class="line">	        result[low++] &#x3D; arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</span><br><span class="line">            &#125;</span><br><span class="line">            while(start1 &lt; end1) &#123;</span><br><span class="line">	        result[low++] &#x3D; arr[start1++];</span><br><span class="line">            &#125;</span><br><span class="line">            while(start2 &lt; end2) &#123;</span><br><span class="line">	        result[low++] &#x3D; arr[start2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	int[] temp &#x3D; arr;</span><br><span class="line">	arr &#x3D; result;</span><br><span class="line">	result &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    result &#x3D; arr;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示意图</strong>：</p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/MergeSort-example.gif" alt></p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/MergeSort.gif" alt></p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>工作原理：快速排序主要采取分治法，将大问题逐步划分为小问题，逐个解决。</p>
<p>算法描述：<br>1、从数列中挑出一个元素，称为“基准”。<br>2、分区：所有比基准值小的元素摆在基准前面，所有比基准值大的元素摆在基准后面。分区结束时，基准应位于数列中间。<br>3、对左右区间递归执行操作2，直至各区间只有一个数。</p>
<p><strong>计算的时间复杂度</strong>：</p>
<blockquote>
<ul>
<li>最坏：$O(n^2)$</li>
<li>最优：$O(nlogn)$</li>
<li>平均：$O(nlogn)$</li>
</ul>
</blockquote>
<p><strong>内存使用量</strong>：</p>
<blockquote>
<ul>
<li>空间复杂度：需要辅助空间$O(logn)$</li>
</ul>
</blockquote>
<p><strong>稳定性</strong>：<strong>不稳定</strong></p>
<p><strong>特点</strong>：通常情况下，快速排序比其他$O(nlogn)$算法更快。</p>
<p>Java代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void quickSort(int arr[],int head,int tail) &#123;</span><br><span class="line">        if (head &gt;&#x3D; tail || arr &#x3D;&#x3D; null || arr.length &lt;&#x3D; 1) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int i &#x3D; head, j &#x3D; tail, pivot &#x3D; arr[(head + tail) &#x2F; 2];</span><br><span class="line">        while (i &lt;&#x3D; j) &#123;</span><br><span class="line">            while (arr[i] &lt; pivot) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            while (arr[j] &gt; pivot) &#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &lt; j) &#123;</span><br><span class="line">                int t &#x3D; arr[i];</span><br><span class="line">                arr[i] &#x3D; arr[j];</span><br><span class="line">                arr[j] &#x3D; t;</span><br><span class="line">                ++i;</span><br><span class="line">                --j;</span><br><span class="line">            &#125; else if (i &#x3D;&#x3D; j) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        quickSort(arr, head, j);</span><br><span class="line">        quickSort(arr, i, tail);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>示意图</strong>：</p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/QuickSort-example.gif" alt></p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/QuickSort.gif" alt></p>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>顾名思义，堆排序是利用堆这种数据结构所设计的一种排序算法，采用的是<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E5%A0%86">二叉堆</a>。</p>
<p><strong>二叉堆性质</strong>：<br>1、父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。<br>2、每个节点的左右子树都是一个二叉堆（都是最大堆或最小堆）。</p>
<p>算法描述：<br>1、构造最大堆（Build_Max_Heap）：若数组下标范围为0~$n$，考虑到单独一个元素是大根堆，则从下标$\frac {n}{2}$开始的元素均为大根堆。于是只要从$\frac {n}{2}-1$开始，向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。</p>
<p>2、堆排序（HeapSort）：由于堆是用数组模拟的。得到一个大根堆后，数组内部并不是有序的。因此需要将堆化数组有序化。思想是移除根节点，并做最大堆调整的递归运算。第一次将heap[0]与heap[$n$-1]交换，再对heap[0…$n$-2]做最大堆调整。第二次将heap[0]与heap[$n$-2]交换，再对heap[0…$n$-3]做最大堆调整。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。</p>
<p>3、最大堆调整（Max_Heapify）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点 。</p>
<p>上面这个是从大佬的博客拷来的步骤，说实话，太官方太仔细了些，我看不太懂。不过我看了几遍大佬博客下面的示意图后，明白了大概步骤，下面就整理一下。</p>
<p>步骤：<br>1、将数组构造为最大堆，在构造的过程中每一步都要检测当前堆是否为最大堆，如果不是，则进行调整<br>2、将第一个根节点与末节点互换后，移除末节点。移除出的末节点，就是堆中的最大数。<br>3、重新构建最大堆<br>4、重复步骤2、3，直至堆只有一个节点后再移除，则得到排列好的序列</p>
<p><strong>计算的时间复杂度</strong>：</p>
<blockquote>
<ul>
<li>最优、最差及平均：$O(nlogn)$</li>
</ul>
</blockquote>
<p><strong>内存使用量</strong>：</p>
<blockquote>
<ul>
<li>空间复杂度：所需辅助空间$O(n)$</li>
</ul>
</blockquote>
<p><strong>稳定性</strong>：<strong>不稳定</strong></p>
<p>Java代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HeapSort &#123;</span><br><span class="line">    </span><br><span class="line">    private int[] arr;</span><br><span class="line">    </span><br><span class="line">    public HeapSort(int[] arr)&#123;</span><br><span class="line">        this.arr &#x3D; arr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 堆排序的主要入口方法，共两步。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void sort()&#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         *  第一步：将数组堆化</span><br><span class="line">         *  beginIndex &#x3D; 第一个非叶子节点。</span><br><span class="line">         *  从第一个非叶子节点开始即可。无需从最后一个叶子节点开始。</span><br><span class="line">         *  叶子节点可以看作已符合堆要求的节点，根节点就是它自己且自己以下值为最大。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        int len &#x3D; arr.length - 1;</span><br><span class="line">        int beginIndex &#x3D; (len - 1) &gt;&gt; 1; </span><br><span class="line">        for(int i &#x3D; beginIndex; i &gt;&#x3D; 0; i--)&#123;</span><br><span class="line">            maxHeapify(i, len);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;*</span><br><span class="line">         * 第二步：对堆化数据排序</span><br><span class="line">         * 每次都是移出最顶层的根节点A[0]，与最尾部节点位置调换，同时遍历长度 - 1。</span><br><span class="line">         * 然后从新整理被换到根节点的末尾元素，使其符合堆的特性。</span><br><span class="line">         * 直至未排序的堆长度为 0。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        for(int i &#x3D; len; i &gt; 0; i--)&#123;</span><br><span class="line">            swap(0, i);</span><br><span class="line">            maxHeapify(0, i - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void swap(int i,int j)&#123;</span><br><span class="line">        int temp &#x3D; arr[i];</span><br><span class="line">        arr[i] &#x3D; arr[j];</span><br><span class="line">        arr[j] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 调整索引为 index 处的数据，使其符合堆的特性。</span><br><span class="line">     * </span><br><span class="line">     * @param index 需要堆化处理的数据的索引</span><br><span class="line">     * @param len 未排序的堆（数组）的长度</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void maxHeapify(int index,int len)&#123;</span><br><span class="line">        int li &#x3D; (index &lt;&lt; 1) + 1; &#x2F;&#x2F; 左子节点索引</span><br><span class="line">        int ri &#x3D; li + 1;           &#x2F;&#x2F; 右子节点索引</span><br><span class="line">        int cMax &#x3D; li;             &#x2F;&#x2F; 子节点值最大索引，默认左子节点。</span><br><span class="line">        </span><br><span class="line">        if(li &gt; len) return;       &#x2F;&#x2F; 左子节点索引超出计算范围，直接返回。</span><br><span class="line">        if(ri &lt;&#x3D; len &amp;&amp; arr[ri] &gt; arr[li]) &#x2F;&#x2F; 先判断左右子节点，哪个较大。</span><br><span class="line">            cMax &#x3D; ri;</span><br><span class="line">        if(arr[cMax] &gt; arr[index])&#123;</span><br><span class="line">            swap(cMax, index);      &#x2F;&#x2F; 如果父节点被子节点调换，</span><br><span class="line">            maxHeapify(cMax, len);  &#x2F;&#x2F; 则需要继续判断换下后的父节点是否符合堆的特性。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 测试用例</span><br><span class="line">     * </span><br><span class="line">     * 输出：</span><br><span class="line">     * [0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9]</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; new int[]&#123;3,5,3,0,8,6,1,5,8,6,2,4,9,4,7,0,1,8,9,7,3,1,2,5,9,7,4,0,2,6&#125;;        </span><br><span class="line">        new HeapSort(arr).sort();        </span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示意图</strong>：</p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Heapsort-example.gif" alt></p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/HeapSort.gif" alt></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/sort.png" alt></p>
<p>PS：</p>
<blockquote>
<ul>
<li>Timsort是结合了合并排序与插入排序的算法，效率很好Java SE7、Android与python均采用Timsort算法对数组排列。（后续会更新此算法介绍）</li>
</ul>
</blockquote>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><blockquote>
<ul>
<li><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/">经典排序算法总结与实现</a></li>
<li><a href="http://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">排序算法可视化</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>文件Uri解析</title>
    <url>/2019/09/05/%E6%96%87%E4%BB%B6Uri%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>很早就想对音视频的uri做一个很认真的归纳分析，但一直觉得没有必要，直到遇到越来越多的不同机型的返回路径，搞得我一塌糊涂却又似懂非懂的，所以这一次就对手上现有的机型的返回路径和解析做一个归纳总结。</p>
<a id="more"></a>
<p>机型统计</p>
<blockquote>
<ul>
<li>小米4</li>
</ul>
</blockquote>
<pre><code>已刷为Android9.0原生系统，但我有安装小米国际版文件管理。选择文件时不同的文件管理系统会返回不同的路径。
</code></pre><blockquote>
<ul>
<li>华为</li>
</ul>
</blockquote>
<pre><code>公司的平板，EMUI3.1系统，Android版本5.1.1。
</code></pre><blockquote>
<ul>
<li>一加7</li>
</ul>
</blockquote>
<pre><code>氢OS9.5.7.GM57系统，Android版本9.0。
</code></pre><p>但其实归根结底，uri返回类型的内容取决于Android的版本以及所用的文件管理系统。原生系统中，Android4.4之前返回的uri就是路径；4.4之后，uri统一开始变为文件资源标识符。而且，受于不同软件的文件标识方法，返回的uri也会有不同。</p>
<h1 id="Uri组成"><a href="#Uri组成" class="headerlink" title="Uri组成"></a>Uri组成</h1><p>uri一般由以下几个部分构成：</p>
<p>[scheme:][//authority][path][?query][#fragment]</p>
<p>或者说</p>
<p>[scheme:][//host:port][path][?query][#fragment]</p>
<p>针对返回的uri，我取其中的getPath()、getAuthority()和getScheme()方法做一些比较。</p>
<h1 id="文件选择测试"><a href="#文件选择测试" class="headerlink" title="文件选择测试"></a>文件选择测试</h1><h2 id="小米4（选择了同一张图片）"><a href="#小米4（选择了同一张图片）" class="headerlink" title="小米4（选择了同一张图片）"></a>小米4（选择了同一张图片）</h2><blockquote>
<ul>
<li>9.0 文件系统</li>
</ul>
</blockquote>
<pre><code>path：/document/image:3180
authority：com.android.providers.media.documents
</code></pre><blockquote>
<ul>
<li>小米国际版文件管理</li>
</ul>
</blockquote>
<pre><code>path：/external_files/AchievemeentApp/Avatar.jpg
authority：com.mi.android.globalFileexplorer.myprovider
</code></pre><h2 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h2><blockquote>
<ul>
<li>图库</li>
</ul>
</blockquote>
<pre><code>path：/external/images/media/44678
authority：media
</code></pre><blockquote>
<ul>
<li>文件管理</li>
</ul>
</blockquote>
<pre><code>path：/storage/emulated/0/AchievementApp/Achievement.xls
authority：
scheme：file
</code></pre><h2 id="一加7"><a href="#一加7" class="headerlink" title="一加7"></a>一加7</h2><blockquote>
<ul>
<li>氢OS 图库</li>
</ul>
</blockquote>
<pre><code>path：/external/file/68400
authority：media
</code></pre><blockquote>
<ul>
<li>氢OS 文件管理</li>
</ul>
</blockquote>
<pre><code>path：/document/primary:AchievementApp/avatar.jpg
authority：com.android.externalstorage.documents
</code></pre><h2 id="Google-相册"><a href="#Google-相册" class="headerlink" title="Google 相册"></a>Google 相册</h2><pre><code>path : /-1/1/content://media/external/images/media/69009/ORIGINAL/NONE/1306754059
authority：com.google.android.apps.photos.contentprovider
</code></pre><h2 id="Google-Drive"><a href="#Google-Drive" class="headerlink" title="Google Drive"></a>Google Drive</h2><pre><code>path：/document/acc=1;doc=encoded=ismNrKUOIBuKKajB8VwcvErY5tVOtHT3P1OhHzic9JbtEmErmSmRRw==
authority：com.google.android.apps.docs.storage
</code></pre><p>除此之外，这些文件uri的scheme大部分是content类型，这一类略去了；个别返回了file类型，这一项有标出。</p>
<p>在使用的过程中，我发现Android系统本身返回的uri，只会是第一个出现的那样，故华为和一加7的Android系统文件返回路径情况我就略去了；而其余的路径，可以说，基本上都是由附加的文件管理软件的差异引起的uri路径差异，尤以Google软件的uri最让人惊异。</p>
<h1 id="Uri解析"><a href="#Uri解析" class="headerlink" title="Uri解析"></a>Uri解析</h1><p>我先给出我之前一段时间所使用到的一段解析uri的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String getFilePathByUri(Context context, Uri uri) &#123;</span><br><span class="line">    String path &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; 以 file:&#x2F;&#x2F; 开头的</span><br><span class="line">    if (ContentResolver.SCHEME_FILE.equals(uri.getScheme())) &#123;</span><br><span class="line">        path &#x3D; uri.getPath();</span><br><span class="line">        return path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 以 content:&#x2F;&#x2F; 开头的，比如 content:&#x2F;&#x2F;media&#x2F;extenral&#x2F;images&#x2F;media&#x2F;17766</span><br><span class="line">    if (ContentResolver.SCHEME_CONTENT.equals(uri.getScheme()) &amp;&amp; Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">        Cursor cursor &#x3D; context.getContentResolver().query(uri, new String[]&#123;MediaStore.Images.Media.DATA&#125;, null, null, null);</span><br><span class="line">        if (cursor !&#x3D; null) &#123;</span><br><span class="line">            if (cursor.moveToFirst()) &#123;</span><br><span class="line">                int columnIndex &#x3D; cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);</span><br><span class="line">                if (columnIndex &gt; -1) &#123;</span><br><span class="line">                    path &#x3D; cursor.getString(columnIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cursor.close();</span><br><span class="line">        &#125;</span><br><span class="line">        return path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 4.4及之后的 是以 content:&#x2F;&#x2F; 开头的，比如 content:&#x2F;&#x2F;com.android.providers.media.documents&#x2F;document&#x2F;image%3A235700</span><br><span class="line">    if (ContentResolver.SCHEME_CONTENT.equals(uri.getScheme()) &amp;&amp; Build.VERSION.SDK_INT &gt;&#x3D; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">        if (DocumentsContract.isDocumentUri(context, uri)) &#123;</span><br><span class="line">            if (isExternalStorageDocument(uri)) &#123;</span><br><span class="line">                &#x2F;&#x2F; ExternalStorageProvider</span><br><span class="line">                final String docId &#x3D; DocumentsContract.getDocumentId(uri);</span><br><span class="line">                final String[] split &#x3D; docId.split(&quot;:&quot;);</span><br><span class="line">                final String type &#x3D; split[0];</span><br><span class="line">                if (&quot;primary&quot;.equalsIgnoreCase(type)) &#123;</span><br><span class="line">                    path &#x3D; Environment.getExternalStorageDirectory() + &quot;&#x2F;&quot; + split[1];</span><br><span class="line">                    return path;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (isDownloadsDocument(uri)) &#123;</span><br><span class="line">                &#x2F;&#x2F; DownloadsProvider</span><br><span class="line">                final String id &#x3D; DocumentsContract.getDocumentId(uri);</span><br><span class="line">                final Uri contentUri &#x3D; ContentUris.withAppendedId(Uri.parse(&quot;content:&#x2F;&#x2F;downloads&#x2F;public_downloads&quot;), Long.valueOf(id));</span><br><span class="line">                path &#x3D; getDataColumn(context, contentUri, null, null);</span><br><span class="line">                return path;</span><br><span class="line">            &#125; else if (isMediaDocument(uri)) &#123;</span><br><span class="line">                &#x2F;&#x2F; MediaProvider</span><br><span class="line">                final String docId &#x3D; DocumentsContract.getDocumentId(uri);</span><br><span class="line">                final String[] split &#x3D; docId.split(&quot;:&quot;);</span><br><span class="line">                final String type &#x3D; split[0];</span><br><span class="line">                Uri contentUri &#x3D; null;</span><br><span class="line">                if (&quot;image&quot;.equals(type)) &#123;</span><br><span class="line">                    contentUri &#x3D; MediaStore.Images.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">                &#125; else if (&quot;video&quot;.equals(type)) &#123;</span><br><span class="line">                    contentUri &#x3D; MediaStore.Video.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">                &#125; else if (&quot;audio&quot;.equals(type)) &#123;</span><br><span class="line">                    contentUri &#x3D; MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">                &#125;</span><br><span class="line">                final String selection &#x3D; &quot;_id&#x3D;?&quot;;</span><br><span class="line">                final String[] selectionArgs &#x3D; new String[]&#123;split[1]&#125;;</span><br><span class="line">                path &#x3D; getDataColumn(context, contentUri, selection, selectionArgs);</span><br><span class="line">                return path;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static String getDataColumn(Context context, Uri uri, String selection, String[] selectionArgs) &#123;</span><br><span class="line">    Cursor cursor &#x3D; null;</span><br><span class="line">    final String column &#x3D; &quot;_data&quot;;</span><br><span class="line">    final String[] projection &#x3D; &#123;column&#125;;</span><br><span class="line">    try &#123;</span><br><span class="line">        cursor &#x3D; context.getContentResolver().query(uri, projection, selection, selectionArgs, null);</span><br><span class="line">        if (cursor !&#x3D; null &amp;&amp; cursor.moveToFirst()) &#123;</span><br><span class="line">        final int column_index &#x3D; cursor.getColumnIndexOrThrow(column);</span><br><span class="line">            return cursor.getString(column_index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (cursor !&#x3D; null)</span><br><span class="line">        cursor.close();</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static boolean isExternalStorageDocument(Uri uri) &#123;</span><br><span class="line">    return &quot;com.android.externalstorage.documents&quot;.equals(uri.getAuthority());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static boolean isDownloadsDocument(Uri uri) &#123;</span><br><span class="line">    return &quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static boolean isMediaDocument(Uri uri) &#123;</span><br><span class="line">    return &quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来的任务，就是按获取到uri一步一步走下去，看看都走到的是哪一步。</p>
<h2 id="小米4-9-0文件系统"><a href="#小米4-9-0文件系统" class="headerlink" title="小米4 9.0文件系统"></a>小米4 9.0文件系统</h2><p>先前已经说过，获取到的scheme全部为”content”，而且源码中定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static final String SCHEME_CONTENT &#x3D; &quot;content&quot;;</span><br></pre></td></tr></table></figure>
<p>且机型的Android系统最低为5.1的LOLLIPOP，必大于4.4的KITKAT。故判断全部进入了第三个判断方法之中。</p>
<p>接下来再来看源码中的DocumentsContract.isDocumentUri(Context context, Uri uri)方法（记为源方法1）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static boolean isDocumentUri(Context context, @Nullable Uri uri) &#123;</span><br><span class="line">    if (isContentUri(uri) &amp;&amp; isDocumentsProvider(context, uri.getAuthority())) &#123;</span><br><span class="line">        final List&lt;String&gt; paths &#x3D; uri.getPathSegments();</span><br><span class="line">        if (paths.size() &#x3D;&#x3D; 2) &#123;</span><br><span class="line">            return PATH_DOCUMENT.equals(paths.get(0));</span><br><span class="line">        &#125; else if (paths.size() &#x3D;&#x3D; 4) &#123;</span><br><span class="line">            return PATH_TREE.equals(paths.get(0)) &amp;&amp; PATH_DOCUMENT.equals(paths.get(2));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看源码的方法（记为源方法2）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static boolean isContentUri(@Nullable Uri uri) &#123;</span><br><span class="line">    return uri !&#x3D; null &amp;&amp; ContentResolver.SCHEME_CONTENT.equals(uri.getScheme());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自不用说，返回结果为true。接着下一个方法（记为源方法3）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static boolean isDocumentsProvider(Context context, String authority) &#123;</span><br><span class="line">    final Intent intent &#x3D; new Intent(PROVIDER_INTERFACE);</span><br><span class="line">    final List&lt;ResolveInfo&gt; infos &#x3D; context.getPackageManager().queryIntentContentProviders(intent, 0);</span><br><span class="line">    for (ResolveInfo info : infos) &#123;</span><br><span class="line">        if (authority.equals(info.providerInfo.authority)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法我看不懂，但单独拿出来运行了一遍，获取如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.android.documentsui.archives</span><br><span class="line">com.android.externalstorage.documents</span><br><span class="line">com.android.mtp.documents</span><br><span class="line">com.android.providers.downloads.documents</span><br><span class="line">com.android.providers.media.documents</span><br></pre></td></tr></table></figure>
<p>那么看来这个方法获取到的，就是系统本身所提供的contentProvider类了，不包括后安装的文件管理类软件。因为小米4上我安装了小米国际版文件管理，上面却并未获取到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.mi.android.globalFileexplorer.myprovider</span><br></pre></td></tr></table></figure>
<p>那么现在跳回源方法1，可以看出判断通过，接下来测试uri.getPathSegments方法，循环打印内容得到如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document</span><br><span class="line">image:3180</span><br></pre></td></tr></table></figure>
<p>很明显，此处size为2，paths.get[0]即为document。又因源代码定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static final String PATH_DOCUMENT &#x3D; &quot;document&quot;;</span><br></pre></td></tr></table></figure>
<p>故判断通过，源方法1返回结果为true。那么接下来再看判断的三个方法，均为provider名称匹配，名称依次为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.android.externalstorage.documents</span><br><span class="line">com.android.providers.downloads.documents</span><br><span class="line">com.android.providers.media.documents</span><br></pre></td></tr></table></figure>
<p>很熟悉，是我们在源方法3中打印过的内容之三，按字面意思理解，分别对应外存储文件，下载文件与媒体库文件。在这里，uri跳转至第三个判断方法，媒体库文件。接着往下走，获取文件id（记为源方法4）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String getDocumentId(Uri documentUri) &#123;</span><br><span class="line">    final List&lt;String&gt; paths &#x3D; documentUri.getPathSegments();</span><br><span class="line">    if (paths.size() &gt;&#x3D; 2 &amp;&amp; PATH_DOCUMENT.equals(paths.get(0))) &#123;</span><br><span class="line">        return paths.get(1);</span><br><span class="line">    &#125;</span><br><span class="line">    if (paths.size() &gt;&#x3D; 4 &amp;&amp; PATH_TREE.equals(paths.get(0)) &amp;&amp; PATH_DOCUMENT.equals(paths.get(2))) &#123;</span><br><span class="line">        return paths.get(3);</span><br><span class="line">    &#125;</span><br><span class="line">    throw new IllegalArgumentException(&quot;Invalid URI: &quot; + documentUri);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，此处得到docId为”image：3180”。image表示资源类型，3180表示资源id。</p>
<p>接下来，对文件的类型进行判断，是图片、音频还是视频，分别进入不同的媒体库，按照给出的文件id查询，即可得到真正的文件路径了。这个步骤在选择获取音视频资源时经常用，就不赘述了。</p>
<p>搞懂了流程，接下来就都很简单了。</p>
<h2 id="小米4-小米国际版文件管理"><a href="#小米4-小米国际版文件管理" class="headerlink" title="小米4 小米国际版文件管理"></a>小米4 小米国际版文件管理</h2><p>这一次按上面的方法走一遍后，很明显发现均不符合判断条件，结果也确实拿到的是null，所以这里我就自己补充一下小米机型的uri解析了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int length &#x3D; &quot;&#x2F;external_files&quot; .length();</span><br><span class="line">path &#x3D; Environment.getExternalStorageDirectory() + uri.getPath().substring(length, uri.getPath().length());</span><br></pre></td></tr></table></figure>
<p>这个方法很明显不适用与小米的所有机型，因为我安装的是国际版的文件管理。但是国内版的安装包我竟然找不到，太神奇了，等以后碰到了再说。</p>
<h2 id="华为-文件管理"><a href="#华为-文件管理" class="headerlink" title="华为 文件管理"></a>华为 文件管理</h2><p>这一类不必多说。返回的文件类型为file，用uri.getPath()方法即可获取到真实路径。</p>
<h2 id="一加7-氢OS-图库-与-华为-图库"><a href="#一加7-氢OS-图库-与-华为-图库" class="headerlink" title="一加7 氢OS 图库 与 华为 图库"></a>一加7 氢OS 图库 与 华为 图库</h2><p>这一类的不同首先在于authority为media类。不过这一类也简单，路径是包含资源id的，只要获取到资源id，然后去查询即可拿到相应的文件路径。</p>
<h2 id="一加7-氢OS-文件管理"><a href="#一加7-氢OS-文件管理" class="headerlink" title="一加7 氢OS 文件管理"></a>一加7 氢OS 文件管理</h2><p>这一次的uri，判断成功的是isExternalStorageDocument(uri)方法。这次的判断，有一个让我疑惑的地方，就是getPathSegments的打印内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document</span><br><span class="line">primary:AchievementApp&#x2F;avatar.jpg</span><br></pre></td></tr></table></figure>
<p>此处，size也为2，但很明显，后面的路径不再细分。</p>
<p>接下来，获取到docId为”primary:AchievementApp/avatar.jpg”。以”:”划分字符串，并在后字符串前添加外存储的路径，组成为文件的真实存在路径。</p>
<h2 id="一加7-Google-相册"><a href="#一加7-Google-相册" class="headerlink" title="一加7 Google 相册"></a>一加7 Google 相册</h2><p>我去查了下网上的解析Google相册的方法，凡是中文博客里，清一色的通过uri读取文件内容然后复制到某个目录下的。嗯，真的，服了。</p>
<p>我觉得不必如此。通过path内容和打印segments可以发现，里面其实已经包含了资源id了，取过来path看一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;-1&#x2F;1&#x2F;content:&#x2F;&#x2F;media&#x2F;external&#x2F;images&#x2F;media&#x2F;69009&#x2F;ORIGINAL&#x2F;NONE&#x2F;1306754059</span><br></pre></td></tr></table></figure>
<p>喏，是不是，打印的segments内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1</span><br><span class="line">1</span><br><span class="line">content:&#x2F;&#x2F;media&#x2F;external&#x2F;images&#x2F;media&#x2F;69009</span><br><span class="line">ORIGINAL</span><br><span class="line">NONE</span><br><span class="line">1306754059</span><br></pre></td></tr></table></figure>
<p>只要通过循环判断，取出第三个字符串，就可以作为一个新的uri内容了。接下来的处理，自不必我多说了吧。</p>
<h2 id="一加7-Google-Drive"><a href="#一加7-Google-Drive" class="headerlink" title="一加7 Google Drive"></a>一加7 Google Drive</h2><p>很奇怪，开始的时候我还能拿到文件的uri，但后来测试的过程中，即使挂着VPN也拿不到uri了。即使是拿着之前的uri，看到这个非Base64加密的字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ismNrKUOIBuKKajB8VwcvErY5tVOtHT3P1OhHzic9JbtEmErmSmRRw&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>
<p>算了算了，都加密了，就不管了。而且我看很少人讨论这个问题，就不过多涉及了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次最重要的是，文件uri解析的过程我完全弄懂了，即使以后碰到其他的文件管理软件，我也可以很快的做出解析了。最后贴出来最终完成版的文件解析方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FileUtil &#123;</span><br><span class="line"></span><br><span class="line">    public static String getFilePathByUri(Context context, Uri uri) &#123;</span><br><span class="line">        String path &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 以 file:&#x2F;&#x2F; 开头的</span><br><span class="line">        if (ContentResolver.SCHEME_FILE.equals(uri.getScheme())) &#123;</span><br><span class="line">            path &#x3D; uri.getPath();</span><br><span class="line">            return path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 以 content:&#x2F;&#x2F; 开头的，比如 content:&#x2F;&#x2F;media&#x2F;extenral&#x2F;images&#x2F;media&#x2F;17766</span><br><span class="line">        if (ContentResolver.SCHEME_CONTENT.equals(uri.getScheme()) &amp;&amp; Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            Cursor cursor &#x3D; context.getContentResolver().query(uri, new String[]&#123;MediaStore.Images.Media.DATA&#125;, null, null, null);</span><br><span class="line">            if (cursor !&#x3D; null) &#123;</span><br><span class="line">                if (cursor.moveToFirst()) &#123;</span><br><span class="line">                    int columnIndex &#x3D; cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);</span><br><span class="line">                    if (columnIndex &gt; -1) &#123;</span><br><span class="line">                        path &#x3D; cursor.getString(columnIndex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cursor.close();</span><br><span class="line">            &#125;</span><br><span class="line">            return path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 4.4及之后的 是以 content:&#x2F;&#x2F; 开头的，比如 content:&#x2F;&#x2F;com.android.providers.media.documents&#x2F;document&#x2F;image%3A235700</span><br><span class="line">        if (ContentResolver.SCHEME_CONTENT.equals(uri.getScheme()) &amp;&amp; Build.VERSION.SDK_INT &gt;&#x3D; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果是系统自带五种provider之一</span><br><span class="line">            if (DocumentsContract.isDocumentUri(context, uri)) &#123;</span><br><span class="line">                if (isExternalStorageDocument(uri)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; ExternalStorageProvider</span><br><span class="line">                    final String docId &#x3D; DocumentsContract.getDocumentId(uri);</span><br><span class="line">                    final String[] split &#x3D; docId.split(&quot;:&quot;);</span><br><span class="line">                    final String type &#x3D; split[0];</span><br><span class="line">                    if (&quot;primary&quot;.equalsIgnoreCase(type)) &#123;</span><br><span class="line">                        path &#x3D; Environment.getExternalStorageDirectory() + &quot;&#x2F;&quot; + split[1];</span><br><span class="line">                        return path;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (isDownloadsDocument(uri)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; DownloadsProvider</span><br><span class="line">                    final String id &#x3D; DocumentsContract.getDocumentId(uri);</span><br><span class="line">                    final Uri contentUri &#x3D; ContentUris.withAppendedId(Uri.parse(&quot;content:&#x2F;&#x2F;downloads&#x2F;public_downloads&quot;), Long.valueOf(id));</span><br><span class="line">                    path &#x3D; getDataColumn(context, contentUri, null, null);</span><br><span class="line">                    return path;</span><br><span class="line">                &#125; else if (isMediaDocument(uri)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; MediaProvider</span><br><span class="line">                    final String docId &#x3D; DocumentsContract.getDocumentId(uri);</span><br><span class="line">                    final String[] split &#x3D; docId.split(&quot;:&quot;);</span><br><span class="line">                    final String type &#x3D; split[0];</span><br><span class="line">                    Uri contentUri &#x3D; null;</span><br><span class="line">                    if (&quot;image&quot;.equals(type)) &#123;</span><br><span class="line">                        contentUri &#x3D; MediaStore.Images.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">                    &#125; else if (&quot;video&quot;.equals(type)) &#123;</span><br><span class="line">                        contentUri &#x3D; MediaStore.Video.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">                    &#125; else if (&quot;audio&quot;.equals(type)) &#123;</span><br><span class="line">                        contentUri &#x3D; MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">                    &#125;</span><br><span class="line">                    final String selection &#x3D; &quot;_id&#x3D;?&quot;;</span><br><span class="line">                    final String[] selectionArgs &#x3D; new String[]&#123;split[1]&#125;;</span><br><span class="line">                    path &#x3D; getDataColumn(context, contentUri, selection, selectionArgs);</span><br><span class="line">                    return path;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (isMiGlobalFileDocument(uri))&#123;</span><br><span class="line">                &#x2F;&#x2F;小米国际文件管理器</span><br><span class="line">                int length &#x3D; &quot;&#x2F;external_files&quot; .length();</span><br><span class="line">                path &#x3D; Environment.getExternalStorageDirectory() + uri.getPath().substring(length, uri.getPath().length());</span><br><span class="line">                return path;</span><br><span class="line">            &#125; else if (uri.getAuthority().equals(&quot;media&quot;))&#123;</span><br><span class="line">                path &#x3D; sortUri(context, uri);</span><br><span class="line">                return path;</span><br><span class="line">            &#125; else if (isGooglePhotosUri(uri))&#123;</span><br><span class="line">                &#x2F;&#x2F;Google相册图片</span><br><span class="line">                Uri contentUri &#x3D; null;</span><br><span class="line">                List&lt;String&gt; segments &#x3D; uri.getPathSegments();</span><br><span class="line">                for (String segment : segments)&#123;</span><br><span class="line">                    if (segment.contains(&quot;content&quot;))&#123;</span><br><span class="line">                        contentUri &#x3D; Uri.parse(segment);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (contentUri !&#x3D; null)&#123;</span><br><span class="line">                    path &#x3D; sortUri(context, contentUri);</span><br><span class="line">                &#125;</span><br><span class="line">                return path;</span><br><span class="line">            &#125; else if (isGoogleDriveUri(uri))&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String sortUri(Context context, Uri uri)&#123;</span><br><span class="line">        String path &#x3D; null;</span><br><span class="line">        String id &#x3D; uri.getLastPathSegment();</span><br><span class="line">        Uri contentUri &#x3D; null;</span><br><span class="line">        if (uri.getPath().contains(&quot;images&quot;))&#123;</span><br><span class="line">            contentUri &#x3D; MediaStore.Images.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">        &#125; else if (uri.getPath().contains(&quot;video&quot;))&#123;</span><br><span class="line">            contentUri &#x3D; MediaStore.Video.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">        &#125; else if (uri.getPath().contains(&quot;audio&quot;))&#123;</span><br><span class="line">            contentUri &#x3D; MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">        &#125;</span><br><span class="line">        if (contentUri !&#x3D; null)&#123;</span><br><span class="line">            path &#x3D; getDataColumn(context, contentUri, &quot;_id &#x3D; ?&quot;, new String[]&#123;id&#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;根据id查询文件(不限类)</span><br><span class="line">            Cursor cursor &#x3D; context.getContentResolver().query(uri, new String[]&#123;&quot;_data&quot;&#125;, &quot;_id &#x3D; ?&quot;, new String[]&#123;id&#125;, null, null);</span><br><span class="line">            if (cursor !&#x3D; null &amp;&amp; cursor.moveToFirst())&#123;</span><br><span class="line">                int index &#x3D; cursor.getColumnIndexOrThrow(&quot;_data&quot;);</span><br><span class="line">                path &#x3D; cursor.getString(index);</span><br><span class="line">            &#125;</span><br><span class="line">            cursor.close();</span><br><span class="line">        &#125;</span><br><span class="line">        return path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String getDataColumn(Context context, Uri uri, String selection, String[] selectionArgs) &#123;</span><br><span class="line">        Cursor cursor &#x3D; null;</span><br><span class="line">        final String column &#x3D; &quot;_data&quot;;</span><br><span class="line">        final String[] projection &#x3D; &#123;column&#125;;</span><br><span class="line">        try &#123;</span><br><span class="line">            cursor &#x3D; context.getContentResolver().query(uri, projection, selection, selectionArgs, null);</span><br><span class="line">            if (cursor !&#x3D; null &amp;&amp; cursor.moveToFirst()) &#123;</span><br><span class="line">                final int column_index &#x3D; cursor.getColumnIndexOrThrow(column);</span><br><span class="line">                return cursor.getString(column_index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (cursor !&#x3D; null)</span><br><span class="line">                cursor.close();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean isExternalStorageDocument(Uri uri) &#123;</span><br><span class="line">        return &quot;com.android.externalstorage.documents&quot;.equals(uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean isDownloadsDocument(Uri uri) &#123;</span><br><span class="line">        return &quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean isMediaDocument(Uri uri) &#123;</span><br><span class="line">        return &quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean isMiGlobalFileDocument(Uri uri)&#123;</span><br><span class="line">        return &quot;com.mi.android.globalFileexplorer.myprovider&quot;.equals(uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean isGooglePhotosUri(Uri uri)&#123;</span><br><span class="line">        return &quot;com.google.android.apps.photos.contentprovider&quot;.equals(uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean isGoogleDriveUri(Uri uri)&#123;</span><br><span class="line">        return &quot;com.google.android.apps.docs.storage&quot;.equals(uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
</search>
