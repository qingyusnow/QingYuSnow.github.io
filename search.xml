<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2019总结</title>
    <url>/2019/12/31/2019%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>又到了一年一度的总结时间。其实写多了，也没什么好说的。前年的时候是苦于入职不顺，内心深处有感而发，写了《迷茫》；辞职后买了本心心念念的徐璐的书看，感慨颇多，写了《那些文字》；在杭州鬼混了三个月，回到家思考人生，写了《2018总结》。那时候三个阶段都很迷茫，无所适从，无处可去。如今混的还算可以，起码可以自给自足，整日有活干活，无事划水，且不表入职初始的艰辛，如今也算是个游刃有余了。</p>
<a id="more"></a>
<p>那我现在要考虑什么方面的？职业？感情？兴趣爱好？还有，人生方向？</p>
<h1 id="职业"><a href="#职业" class="headerlink" title="职业"></a>职业</h1><p>职业和工作自不必多说。我确实需要着手准备一些进阶的学习了。我完成了第一个自己的APP，虽然功能简陋，但初步完成了我要的两个标准：Material Design界面标准与符合预期设计的功能。这让我自己还是感到挺满意的。不足之处自然存在，但我在想出下一个很好的idea之前，我是不会改动这个应用了。除此之外，Android和Java方面，我需要学习很多东西：有些是早有耳闻不曾涉及，如今突发兴趣的，还有一些就是职业所必需了。我还是希望，我所学的，是我感兴趣的，这样才会更有动力。</p>
<h1 id="感情"><a href="#感情" class="headerlink" title="感情"></a>感情</h1><p>若是此刻让我在一张白纸上写一个喜欢的人的名字，除了小钰，我怕是写不出其他人了，哈哈。先附一张壁纸：</p>
<p><img src="/2019/12/31/2019%E6%80%BB%E7%BB%93/xiaoyu_bg.jpg" alt></p>
<p>哇，果然，黑长直还是我的最爱啊。要说理想伴侣的话，徐璐笔下的陆希与狄夏，则完全满足了我的所有幻想，这也是我的新网名的由来。</p>
<p><strong>但如果未来想遇到这样的女孩子，我要做到多优秀呢？或者，我又需要去做到什么呢？</strong></p>
<h1 id="兴趣爱好"><a href="#兴趣爱好" class="headerlink" title="兴趣爱好"></a>兴趣爱好</h1><p>我依然还在坚持着去年立下的读书计划，去年只读了15本，距离预期目标差了5本。而且，读什么样的书，很是让我困惑。若要说，这几个月来我读的感触最深的，无疑是柴静的《看见》；但若要我一年内只读这种书，怕是很难顶。上半年内我读的基本都是东野圭吾的书，起初很好看，《解忧杂货店》甚至在我迷茫之时指导了我一二；但在看完《恶意》那本书之后，再读他的其他悬疑向作品，总有一种相形见绌的感觉。所以，我打算换几个作者看了，但外文题材的作品，我也很是忌惮，《哈姆雷特》《乱世佳人》《局外人》，开篇读起来实在是味同嚼蜡。到底还是文化底蕴的不同，完全不能接受西方的文笔描写，所以接下来的时间，我打算挑几部国内作者的书看一看。</p>
<p>至于游戏，在年末，我终于玩到了好评如潮的黑暗之魂3。黑魂大名果真当之无愧！剧情内容磅礴，战斗场面激烈，人物形象立体，称作史诗又未有不可！</p>
<h1 id="人生"><a href="#人生" class="headerlink" title="人生"></a>人生</h1><p>说人生，就要谈一下优秀的人。要说今年令我感触最大的几个人，当属B站的老菊、老番茄和微小微了。</p>
<h2 id="阅历丰富，善于思考，行事踏实有章法"><a href="#阅历丰富，善于思考，行事踏实有章法" class="headerlink" title="阅历丰富，善于思考，行事踏实有章法"></a>阅历丰富，善于思考，行事踏实有章法</h2><p>老菊，很有自己的一套想法，不论是在长篇的游戏视频中的体现，能把rgb游戏kenshi做出一个七月霸权——奴隶阿飞系列，好看到爆，能玩梗，能创造梗，更能把一个生硬的游戏背景故事经营得有血有肉，用自己的理解和想法玩出自己的一套东西；更是在兼顾做视频的同时，迈出自己勇敢的一步——成立工作室，做自己的独立游戏，有自己对于游戏开发的初步预想，好结果坏结果都已经做好承受的准备了。转念一想，老菊的独立游戏计划，从太吾绘卷就开始酝酿了。他从来不缺游戏的创意，缺的是经验，所以才会几度与太吾绘卷的核心人员茄子接触，慢慢敲定了这项计划。</p>
<p>他在年初曾接受过采访，后来有微信号出过一篇文章——<a href="https://mp.weixin.qq.com/s?__biz=MzIzNzM3NzE2MA==&amp;mid=2247526741&amp;idx=1&amp;sn=6e6e8b248d59ab74e89e2dfef5aa24a6&amp;scene=21&amp;token=2118450709&amp;lang=zh_CN#wechat_redirect">《王老菊的多重身份》</a>，这篇文章我很喜欢，读完触动很大。幽默风趣，行事随机，敢于破格，这是老菊在多个系列游戏视频中表现出的一贯形象；严肃认真，行事努力，按部就班，这是文章的采访描述，或者说是老菊对自己的评价。而<strong>我印象最深的还是那句“普通人最多只能做好一件事”</strong>，而他，把自己归为普通人。</p>
<h2 id="认真与幽默两兼顾"><a href="#认真与幽默两兼顾" class="headerlink" title="认真与幽默两兼顾"></a>认真与幽默两兼顾</h2><p>老番茄是我去年才开始关注的，因为之前他发的多是些游戏视频，，做的视频不感冒。我对此人有耳闻，看了b站故事王第二季，他是冠军得主，很有才。毕业之际他发了一个vlog——<a href="https://www.bilibili.com/video/BV1rx411o74x">《我毕业啦》</a>，这个认真优秀又幽默风趣的人一下子就把我吸引到了。之后的个人vlog，深深地让我感慨：这个人怎么会这么优秀又有才华啊！还TM长得帅！惊了！老番茄还有一个视频我也很喜欢，就是他的生日vlog——<a href="https://www.bilibili.com/video/BV1V4411S7Hf">《我过生日啦》</a>。</p>
<p>其实B站也有很多优秀的学霸，老菊，C菌，散人等等，无一不是优秀之才。</p>
<p>我确实看不到，也很难体会得到，他们的努力有多少；<strong>但我很羡慕，老番茄登场的那一瞬间，是多么耀眼</strong>。这，就足以当作我的告诫和动力了。</p>
<p>我不羡人前发光，我只羡能一件事做到自己问心无愧。</p>
<h2 id="自信"><a href="#自信" class="headerlink" title="自信"></a>自信</h2><p>提前微小微，4个字，羞耻女王，经常在公众场合跳舞拍视频，即使是看视频，也不禁让人面红耳搔，“略”感不适。<br>但我在看到她的视频后，就关注了她。<strong>因为我知道，我最缺自信，我需要从她身上，学到这一点。</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看完了自己写的东西，有一种自己根本没有进步的感觉，我依然没有习得良好的语言表达能力，归纳能力。多读点书，多思考罢。</p>
<p><strong>到底还是自己肚子里没东西，孤独时刻的慌张一如既往。</strong></p>
]]></content>
      <categories>
        <category>Book</category>
      </categories>
  </entry>
  <entry>
    <title>2020总结</title>
    <url>/2020/12/08/2020%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>活的太过佛系，生活也便没了乐趣。</p>
<a id="more"></a>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>在前一两个月，我偶然发现了Aeon Timeline这款软件。它完美实现了我的预期效果：能以时间线的方式标注出一件事件的完成跨度，以此方便记录与观察我的行事轨迹。</p>
<h2 id="为什么要记录"><a href="#为什么要记录" class="headerlink" title="为什么要记录"></a>为什么要记录</h2><p>原因很简单：我想通过完成这些事情来给自己一些成就感，以此改善自己单调乏味的生活。</p>
<h2 id="记录什么样的事情"><a href="#记录什么样的事情" class="headerlink" title="记录什么样的事情"></a>记录什么样的事情</h2><p>从起初到现在，我给自己定义的四大分类从未改变，一直都是<strong>游戏</strong>、<strong>阅读</strong>、<strong>影视</strong>、<strong>项目</strong>四项。我曾想把学日语歌的爱好和其他意料之外的事情作为<strong>其他</strong>项，但在2019年末发现多此一举，便不再加设此项。</p>
<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>借助Aeon Timeline，我将这两年记录下来的事件做了两张表：</p>
<blockquote>
<p>强烈建议右键点击图片，在新标签页中查看</p>
</blockquote>
<p><img src="/2020/12/08/2020%E6%80%BB%E7%BB%93/2019-横版.png" alt></p>
<p><img src="/2020/12/08/2020%E6%80%BB%E7%BB%93/2020-横版.png" alt></p>
<h2 id="2019年"><a href="#2019年" class="headerlink" title="2019年"></a>2019年</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类别</th>
<th style="text-align:center">实际完成数量</th>
<th style="text-align:center">计划目标数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">游戏</td>
<td style="text-align:center">14</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:center">阅读</td>
<td style="text-align:center">15</td>
<td style="text-align:center">20</td>
</tr>
<tr>
<td style="text-align:center">影视</td>
<td style="text-align:center">15</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:center">项目</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
</div>
<h2 id="2020年"><a href="#2020年" class="headerlink" title="2020年"></a>2020年</h2><p>(截至12/08)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类别</th>
<th style="text-align:center">实际完成数量</th>
<th style="text-align:center">计划目标数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">游戏</td>
<td style="text-align:center">11</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:center">阅读</td>
<td style="text-align:center">10</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:center">影视</td>
<td style="text-align:center">12</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:center">项目</td>
<td style="text-align:center">0</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
</div>
<h2 id="分析与感受"><a href="#分析与感受" class="headerlink" title="分析与感受"></a>分析与感受</h2><p>图表上显而易见，20年的事件安排比起19年少了很多。那结合图表与实际体验，这两年间存在什么问题呢？</p>
<blockquote>
<ul>
<li><strong>目标数量不明确</strong>。我从未在年初立下过具体目标，都是挑了几个好看的数字而已。</li>
<li><strong>存在空档时期</strong>。我现在已经想不起，在图表中的几个“断崖”式空档时期，究竟做过什么事情。</li>
<li><strong>事件在时间上的跨度重合变高</strong></li>
</ul>
</blockquote>
<p>此外还有一个问题：那就是每一类记录的<strong>事件的标准线</strong>。在19年，我对完成情况比较满意，回避了这个问题。在20年完成情况比较差的情况下，我曾想把一些事件拿出来凑数，但不免有种自欺欺人的感觉，便借此对事件做一些明确的定义。</p>
<h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><blockquote>
<ul>
<li>初玩的<strong>单机游戏</strong>为主，网游和早年玩过的游戏不记录在内</li>
<li>完成度：至少要求<strong>主线通关</strong>。我也曾玩过刺客信条奥德赛、死亡细胞、上古卷轴5等等，但大都中途弃坑，不能作数</li>
</ul>
</blockquote>
<h3 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h3><p>我阅读资历尚浅，还在摸索阶段，要求不高</p>
<blockquote>
<ul>
<li>著作<strong>已出版</strong></li>
<li><strong>已完结</strong>的网文。借出版社之手，可以帮我筛选掉很多质量不过关的小说。实际上，我内心还是比较排斥网文的</li>
</ul>
</blockquote>
<h3 id="影视"><a href="#影视" class="headerlink" title="影视"></a>影视</h3><p>这是我之前定义最模糊的一个分类了</p>
<blockquote>
<ul>
<li><strong>口碑</strong>要好</li>
<li><strong>二次元番剧</strong>。这是我主要想扩展的一个方向</li>
<li>非院线的<strong>电影</strong>。我看电影太太太太少了，因此要求也很低；去影院看的电影不计在内</li>
<li>非国产连续电视剧。主要还是现在的国产剧大部分又臭又长，看的也不爽，时间也浪费了</li>
</ul>
</blockquote>
<p>总体感受上20年比19年要好一些</p>
<blockquote>
<ul>
<li>游戏：20年玩的游戏比19年玩的游戏要高出一个阶层，得益于宫崎英高和任天堂与强力新设备的添置</li>
<li>阅读：20年，我试图跳脱于东野圭吾单个作者，尝试向其他方向扩展</li>
<li>影视：20年比起19年差了很多，二次元番剧看的极少，感觉今年缺失了一些什么</li>
</ul>
</blockquote>
<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>数量上的变少，<strong>主要还是人变懒了。</strong></p>
<p>这没有什么可开脱的。可以看到，疫情在家期间，我基本上没有做什么事情。当然，一方面是在上班，一方面是会有朋友来访，但一个月的晚上没做什么事情也是乏善可陈的。</p>
]]></content>
      <categories>
        <category>Book</category>
      </categories>
  </entry>
  <entry>
    <title>Activity的生命周期</title>
    <url>/2020/06/15/Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p><a href="https://developer.android.google.cn/guide/components/activities/activity-lifecycle">Activity生命周期</a></p>
<p>了解Activity的生命周期，在一定程度上，对修正或完善代码内 <strong>各种情况下</strong> <em>业务的执行顺序与发生时机</em> ，会有很大的帮助。</p>
<a id="more"></a>
<h1 id="先行知识"><a href="#先行知识" class="headerlink" title="先行知识"></a>先行知识</h1><p><img src="/2020/06/15/Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/activity_lifecycle.png" alt="Android开发官网的生命周期图例"></p>
<h2 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate"></a>onCreate</h2><p>在创建activity时触发，生命周期中第一个调用的方法，在整个生命周期内也只应发生一次（存在打破此规则的可行性操作）。<strong>此时还在后台，对用户不可见</strong>。</p>
<p>在这一步，应该初始化布局资源，绑定数据，还有所有静态资源。要注意此时视图还在构建，是无法调用布局动画以及获取或设置布局的长宽及位置信息的。</p>
<h2 id="onStart"><a href="#onStart" class="headerlink" title="onStart"></a>onStart</h2><p>activity进入“已启动”状态。对于这个阶段的描述，各博客的说法不一。我的理解为，<strong>此时对用户可见，但不处于前台，无法与用户进行交互</strong>。这个阶段很短，大概像是activity的整个界面在初现到完整展现中的过渡阶段，这个阶段的确符合“可见，不处于前台，无法交互”三个要素。</p>
<p>在这一步，可以尝试检测一些必要条件，比如检查一些权限等。</p>
<h2 id="onResume"><a href="#onResume" class="headerlink" title="onResume"></a>onResume</h2><p>调用此方法后，activity可与用户进行交互。<strong>此时位于前台，对用户可见，且可进行交互</strong>。</p>
<p>在这一步，初始化一些“独占设备”（比如相机、录音机等）的相关设置。</p>
<h2 id="onPause"><a href="#onPause" class="headerlink" title="onPause"></a>onPause</h2><p>activity失去焦点，并进入“已暂停”状态。<strong>此时尚且位于前台，对用户可见，但已不可进行交互</strong>。一般来说，如果当前方法在500ms内未执行完毕，会强制关闭当前activity。</p>
<p>此时，考虑到<strong>各种情况</strong>，调用的下一个方法会是onResume或onStop；当然，杀进程这种特别少见的情况也是有可能存在的。这里的<strong>各种情况</strong>，会在下面尝试通过操作实现。</p>
<p>在这一步，只能释放一些必要资源，以防下一个activity会用到，比如上文刚提过的“独占设备”资源。考虑到onPause有默认限时，这一步最好不要做很多操作，以防业务提前中断，造成崩溃或数据丢失等。</p>
<h2 id="onStop"><a href="#onStop" class="headerlink" title="onStop"></a>onStop</h2><p>activity已停止。<strong>此时已位于后台，对用户不可见</strong>。但此时activity还存在于内存中，尚未被销毁。</p>
<p>在这一步，可以着重做很多资源的回收工作。阿里巴巴的Android规范手册要求，尽量不要在onDestroy中释放资源，因为onDestroy的执行时机可能较晚。所以，一些线程资源的释放，数据的保存，都可以在这一步做。</p>
<h2 id="onDestroy"><a href="#onDestroy" class="headerlink" title="onDestroy"></a>onDestroy</h2><p>activity被销毁。<strong>此时对用户不可见</strong>。</p>
<p>在这一步，释放其他未释放的资源，特别是onCreate中初始化的静态资源等。</p>
<h2 id="onRestart"><a href="#onRestart" class="headerlink" title="onRestart"></a>onRestart</h2><p>处于“已停止”状态即将重启时，会调用此方法。此回调后面总跟着onStart。</p>
<h1 id="状态变更"><a href="#状态变更" class="headerlink" title="状态变更"></a>状态变更</h1><p>在使用应用的过程中，用户总会做出些令人意想不到的预料外的操作，这样一来，就需要了解一下状态变更的详情，以便开发者整理出一套趋于完美的业务逻辑。</p>
<p>以下是我所能设想到的所有操作。这其中有两种操作，属于配置更改。这类操作会重新创建activity。</p>
<h2 id="activity的切换"><a href="#activity的切换" class="headerlink" title="activity的切换"></a>activity的切换</h2><h3 id="activity-A-启动-activity-B"><a href="#activity-A-启动-activity-B" class="headerlink" title="activity A 启动 activity B"></a>activity A 启动 activity B</h3><p>onPause()(A) -&gt; onCreate()(B) -&gt; onStart()(B) -&gt; onResume()(B) -&gt; onStop()(A) -&gt; onSaveInstanceState()(A)</p>
<h3 id="activity-B-返回-activity-A"><a href="#activity-B-返回-activity-A" class="headerlink" title="activity B 返回 activity A"></a>activity B 返回 activity A</h3><p>onPause()(B) -&gt; onRestart()(A) -&gt; onStart()(A) -&gt; onResume()(A) -&gt; onStop()(B) -&gt; onDestroy()(B)</p>
<h2 id="息亮屏"><a href="#息亮屏" class="headerlink" title="息亮屏"></a>息亮屏</h2><h3 id="息屏"><a href="#息屏" class="headerlink" title="息屏"></a>息屏</h3><p>onPause() -&gt; onStop() -&gt; onSaveInstanceState()</p>
<h3 id="亮屏"><a href="#亮屏" class="headerlink" title="亮屏"></a>亮屏</h3><p>onRestart() -&gt; onStart() -&gt; onResume()</p>
<h2 id="来电"><a href="#来电" class="headerlink" title="来电"></a>来电</h2><p>一般来说，现在的手机系统很少会有不经用户允许直接切换至电话接听界面的操作了。相对以往来说，这里的操作其实也无特别之处了。</p>
<h3 id="切换至接听界面"><a href="#切换至接听界面" class="headerlink" title="切换至接听界面"></a>切换至接听界面</h3><p>onPause() -&gt; onStop() -&gt; onSaveInstanceState()</p>
<h3 id="拒绝来电"><a href="#拒绝来电" class="headerlink" title="拒绝来电"></a>拒绝来电</h3><p>onRestart() -&gt; onStart() -&gt; onResume()</p>
<h2 id="横竖屏切换（第一类配置更改操作）"><a href="#横竖屏切换（第一类配置更改操作）" class="headerlink" title="横竖屏切换（第一类配置更改操作）"></a>横竖屏切换（第一类配置更改操作）</h2><p>onPause() -&gt; onStop() -&gt; onSaveInstanceState() -&gt; onDestroy() -&gt; onCreate() -&gt; onStart() -&gt; onRestoreInstanceState() -&gt; onResume()</p>
<h2 id="窗口模式"><a href="#窗口模式" class="headerlink" title="窗口模式"></a>窗口模式</h2><h3 id="按下任务键，应用变为窗口"><a href="#按下任务键，应用变为窗口" class="headerlink" title="按下任务键，应用变为窗口"></a>按下任务键，应用变为窗口</h3><p>onPause() -&gt; onStop() -&gt; onSaveInstanceState()</p>
<h3 id="选中窗口，应用变为全屏"><a href="#选中窗口，应用变为全屏" class="headerlink" title="选中窗口，应用变为全屏"></a>选中窗口，应用变为全屏</h3><p>onRestart() -&gt; onStart() -&gt; onResume()</p>
<h3 id="切换至多窗口（即分屏）模式（第二类配置更改操作）"><a href="#切换至多窗口（即分屏）模式（第二类配置更改操作）" class="headerlink" title="切换至多窗口（即分屏）模式（第二类配置更改操作）"></a>切换至多窗口（即分屏）模式（第二类配置更改操作）</h3><p>onDestroy() -&gt; onCreate() -&gt; onStart() -&gt; onRestoreInstanceState() -&gt; onResume() -&gt; onPause()</p>
<p>这让我发现了一个有趣的东西。在切换至分屏且未添加第二个分屏应用时，主activity的生命周期会运行至onPause()。此时若是点击应用，会发现应用不响应点击事件，似是获取不到用户输入，即失去焦点。</p>
<p><strong>添加第二个分屏应用之后，测试应用调用 onResume()</strong>，此时可以响应点击事件。</p>
<p>接下来可有两种操作。</p>
<h4 id="1、将测试应用拉至全屏"><a href="#1、将测试应用拉至全屏" class="headerlink" title="1、将测试应用拉至全屏"></a>1、将测试应用拉至全屏</h4><p>onPause() -&gt; onStop() -&gt; onSaveInstanceState() -&gt; onDestroy() -&gt; onCreate() -&gt; onStart() -&gt; onRestoreInstanceState() -&gt; onResume()</p>
<h4 id="2-1、将另一个分屏应用拉至全屏"><a href="#2-1、将另一个分屏应用拉至全屏" class="headerlink" title="2-1、将另一个分屏应用拉至全屏"></a>2-1、将另一个分屏应用拉至全屏</h4><p>onPause() -&gt; onStop() -&gt; onSaveInstanceState()</p>
<h4 id="2-2、再切换至测试应用"><a href="#2-2、再切换至测试应用" class="headerlink" title="2-2、再切换至测试应用"></a>2-2、再切换至测试应用</h4><p>onDestroy() -&gt; onCreate() -&gt; onStart() -&gt; onRestoreInstanceState() -&gt; onResume()</p>
<h1 id="本章相关知识点"><a href="#本章相关知识点" class="headerlink" title="本章相关知识点"></a>本章相关知识点</h1><blockquote>
<ul>
<li><a href="https://developer.android.google.cn/topic/libraries/architecture/saving-states">保存界面状态</a></li>
<li><a href="https://developer.android.google.cn/guide/topics/ui/multi-window">多窗口支持</a></li>
<li><a href="https://developer.android.google.cn/topic/libraries/architecture/lifecycle">生命周期感知能力的组件</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android时钟动画实现</title>
    <url>/2018/11/21/Android%E6%97%B6%E9%92%9F%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>依自己的使用来看，小米手机的自身很多应用在动画处理和界面处理上都很圆滑舒服，所以估计在未来一段时间内，我都会以小米应用作为模仿练手的目标，这次就先模仿实现一下小米时钟的动画。小米时钟有很多动画，我暂时只完成了一个界面，而且还不完善，所以还会持续改进。</p>
<a id="more"></a>
<p>先放上我已经实现的效果图<del>(录制采用的是免费版的icecream，功能很不错，就是水印有点大）</del>。</p>
<p><img src="/2018/11/21/Android%E6%97%B6%E9%92%9F%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/1.gif" alt></p>
<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>这个动画中需要绘制的一共有6个部分：中心环，时针，分针，秒针，内环，外环刻度盘，如下图：</p>
<p><img src="/2018/11/21/Android%E6%97%B6%E9%92%9F%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/2.jpg" alt></p>
<p>在这6个部分中，中心环、内环属于静态，一经绘制便不需要再作处理；时针、分针、秒针和外环刻度盘则是属于时时刻刻都在运动的部分，是需要重点处理的部分。</p>
<h1 id="代码实现部分"><a href="#代码实现部分" class="headerlink" title="代码实现部分"></a>代码实现部分</h1><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>既然是要绘制时钟，就一定需要获取到时间。时间的精度一定要高，要以毫秒为单位，这样才能使动画的变化更加圆滑一些，而不是一秒一跳那样的动画。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获取当前总时间（超出1970年1月1日的时间）</span><br><span class="line">long time &#x3D; System.currentTimeMilllis();</span><br><span class="line">&#x2F;&#x2F;获取当前时间（超出当天0点的时间）</span><br><span class="line">long overtime;</span><br><span class="line">&#x2F;&#x2F;获取当前系统时间</span><br><span class="line">SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">&#x2F;&#x2F;除以1000，得到的会是以秒为单位的时间；不除，则以毫秒为单位</span><br><span class="line">try &#123;</span><br><span class="line">	overtime &#x3D; (time - (simpleDateFormat.parse(simpleDateFormat.format(time)).getTime()));</span><br><span class="line">&#125;catch (Exception e)&#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;时钟最多展示12个小时的时间，所以只需要留下一个小于12个小时的数据；一天共有12x60x60&#x3D;86400秒，半天则为43200秒</span><br><span class="line">if(overtime &gt;&#x3D; 43200000) &#123;</span><br><span class="line">	overtime &#x3D; overtime - 43200000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中心环与内环"><a href="#中心环与内环" class="headerlink" title="中心环与内环"></a>中心环与内环</h2><p>中心环与内环的实现很简单，只需要绘制两个中心圆就可以了，一个半径小一些且画笔宽度粗一些，一个半径大一些且画笔宽度细一些：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;绘制中心环画笔</span><br><span class="line">paints[0].setStyle(Paint.Style.STROKE);</span><br><span class="line">paints[0].setStrokeWidth(centerCircleWidth);</span><br><span class="line">paints[0].setColor(Color.WHITE);</span><br><span class="line">paints[0].setAntiAlias(true);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;绘制内环画笔</span><br><span class="line">paints[1].setStyle(Paint.Style.STROKE);</span><br><span class="line">paints[1].setStrokeWidth(innerCircleWidth);</span><br><span class="line">paints[1].setColor(Color.WHITE);</span><br><span class="line">paints[1].setAntiAlias(true);</span><br><span class="line"></span><br><span class="line">······</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;绘制中心环</span><br><span class="line">canvas.drawCircle(centerX,centerY,centerCircleRadius,paints[0]);</span><br><span class="line">&#x2F;&#x2F;绘制内环</span><br><span class="line">canvas.drawCircle(centerX,centerY,innerCircleRadius,paints[1]);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/11/21/Android%E6%97%B6%E9%92%9F%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/3.jpg" alt></p>
<h2 id="时针"><a href="#时针" class="headerlink" title="时针"></a>时针</h2><p>时针的实现有两点：1、时针的形状绘制；2、时针的指向角度绘制</p>
<p>时针的形状，我采用了一个等腰三角形来绘制。绘制等腰三角形，需要计算出三个点的位置。考虑到点的位置是时刻都在变化的，所以要先计算出指针应当指向的角度。</p>
<p><img src="/2018/11/21/Android%E6%97%B6%E9%92%9F%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/4.jpg" alt></p>
<p>如图所示，A点是左底点，B点是右底点，C点是顶点。其中，∠β是偏差角度，我设定为60度，∠α是时针整体的指向角度，底距是两个底点距原点的距离，时针的臂长则是顶点C距原点的距离。有了这些参数，计算各个点的变化规律就简单多了。比如：</p>
<p>$A_x = O_x + 底距 * sin(∠α - ∠β)$</p>
<p>$A_y = O_y + 底距 * cos(∠α - ∠β)$</p>
<p><strong>但是，Android界面的坐标系y轴与数学系的y轴在正方向上是相反的。所以，第二个算式中，要把”+”变为”-“。</strong></p>
<p>底点的计算已经有了，顶点的计算更简单了，自不用说。不过，计算中的∠β是个未知数，是需要我们自己去计算的。</p>
<p>前面代码中已经给过了overtime这个变量的计算，它代表的是超出当天0点的时间。计算时针的角度，只需要计算overtime能占到一个表格所表示的最大时间的比例，即占12个小时的比例。要注意的是，这里的比例计算要以毫秒为考虑角度，才能使计算出的角度尽可能的细致入微，而不是每过一个小时，跳格30度。代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;绘制时针底部时用到的偏差角度，用于计算底部点</span><br><span class="line">hourHandDeviation &#x3D; 60;</span><br><span class="line">······</span><br><span class="line">&#x2F;&#x2F;绘制时针</span><br><span class="line">&#x2F;&#x2F;以下是简化的公式，原公式为overtime&#x2F;(12 * 3600 * 1000) * (360 &#x2F; 1000)</span><br><span class="line">&#x2F;&#x2F;即先计算当前时间（单位为秒）占12个小时的总时间的多少，再乘以整个圈的度数，即可得到当前时针应该指向的角度</span><br><span class="line">double degree &#x3D; Math.toRadians(((double)overtime) &#x2F; 120000.00);</span><br><span class="line">double leftPointX &#x3D; centerX + handRadius * Math.sin(degree - Math.toRadians(hourHandDeviation));</span><br><span class="line">double leftPointY &#x3D; centerY - handRadius * Math.cos(degree - Math.toRadians(hourHandDeviation));</span><br><span class="line">double rightPointX &#x3D; centerX + handRadius * Math.sin(degree + Math.toRadians(hourHandDeviation));</span><br><span class="line">double rightPointY &#x3D; centerY - handRadius * Math.cos(degree + Math.toRadians(hourHandDeviation));</span><br><span class="line">double topPointX &#x3D; centerX + hourHandLength * Math.sin(degree);</span><br><span class="line">double topPointY &#x3D; centerY - hourHandLength * Math.cos(degree);</span><br><span class="line">&#x2F;&#x2F;通过绘制一个等腰三角形的类似图形来绘制时针</span><br><span class="line">Path path &#x3D; new Path();</span><br><span class="line">path.moveTo((float)leftPointX,(float)leftPointY);</span><br><span class="line">path.lineTo((float)topPointX,(float)topPointY);</span><br><span class="line">path.lineTo((float)rightPointX,(float)rightPointY);</span><br><span class="line">path.close();</span><br><span class="line">canvas.drawPath(path,paints[3]);</span><br></pre></td></tr></table></figure>
<h2 id="分针"><a href="#分针" class="headerlink" title="分针"></a>分针</h2><p>分针的绘制如同时针，只不过偏差角度小一些，臂长长一些，原理上都是一样的。代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;绘制分针</span><br><span class="line">&#x2F;&#x2F;以下为简化的公式，原公式为overtime mod (3600 * 1000) &#x2F; 3600 * (360 &#x2F; 1000)，计算当前时间除去小时后，剩余时间占一个小时的多少，再乘以总度数</span><br><span class="line">degree &#x3D; Math.toRadians(overtime % 3600000 * 0.0001);</span><br><span class="line">leftPointX &#x3D; centerX + handRadius * Math.sin(degree - Math.toRadians(minuteHandDeviation));</span><br><span class="line">leftPointY &#x3D; centerY - handRadius * Math.cos(degree - Math.toRadians(minuteHandDeviation));</span><br><span class="line">rightPointX &#x3D; centerX + handRadius * Math.sin(degree + Math.toRadians(minuteHandDeviation));</span><br><span class="line">rightPointY &#x3D; centerY - handRadius * Math.cos(degree + Math.toRadians(minuteHandDeviation));</span><br><span class="line">topPointX &#x3D; centerX + minuteHandLength * Math.sin(degree);</span><br><span class="line">topPointY &#x3D; centerY - minuteHandLength * Math.cos(degree);</span><br><span class="line">path &#x3D; new Path();</span><br><span class="line">path.moveTo((float)leftPointX,(float)leftPointY);</span><br><span class="line">path.lineTo((float)topPointX,(float)topPointY);</span><br><span class="line">path.lineTo((float)rightPointX,(float)rightPointY);</span><br><span class="line">path.close();</span><br><span class="line">canvas.drawPath(path,paints[4]);</span><br></pre></td></tr></table></figure>
<h2 id="秒针"><a href="#秒针" class="headerlink" title="秒针"></a>秒针</h2><p>秒针的绘制实际上也可以跟以上两个是一样的，不过我为了绘制一个等边三角形，本可以直接给定值的底距，在这里我是通过给定的秒针三角形的高secondHandHeight和底边中心到原点的距离secondHandRadius，间接计算而得出。这样的计算比较麻烦，但能得到一个等边三角形，我觉得还是可以的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;绘制一个三角形指针</span><br><span class="line">&#x2F;&#x2F;以下为简化的公式，原公式为overtime mod (60 * 1000) &#x2F; 60 * (360 &#x2F; 1000)</span><br><span class="line">degree &#x3D; Math.toRadians(overtime % 60000 * 0.006);</span><br><span class="line">&#x2F;&#x2F;计算三角形另外两顶点的偏差角度</span><br><span class="line">double deviation &#x3D; Math.atan(Math.tan(Math.toRadians(30))*secondHandHeight&#x2F;secondHandRadius);</span><br><span class="line">&#x2F;&#x2F;计算三个顶点的坐标变化</span><br><span class="line">topPointX &#x3D; centerX + (secondHandRadius + secondHandHeight) * Math.sin(degree);</span><br><span class="line">topPointY &#x3D; centerY - (secondHandRadius + secondHandHeight) * Math.cos(degree);</span><br><span class="line">double secondRadius &#x3D; Math.tan(Math.toRadians(30))*secondHandHeight&#x2F;Math.sin(deviation);</span><br><span class="line">leftPointX &#x3D; centerX + secondRadius * Math.sin(degree - deviation);</span><br><span class="line">leftPointY &#x3D; centerY - secondRadius * Math.cos(degree - deviation);</span><br><span class="line">rightPointX &#x3D; centerX + secondRadius * Math.sin(degree + deviation);</span><br><span class="line">rightPointY &#x3D; centerY - secondRadius * Math.cos(degree + deviation);</span><br><span class="line">path &#x3D; new Path();</span><br><span class="line">path.moveTo((float)topPointX,(float)topPointY);</span><br><span class="line">path.lineTo((float)leftPointX,(float)leftPointY);</span><br><span class="line">path.lineTo((float)rightPointX,(float)rightPointY);</span><br><span class="line">path.close();</span><br></pre></td></tr></table></figure>
<p>这里有一个小插曲：我这里直接简化了公式，得到的角度是精度很高，类型为double的度数，所以动画看起来很平滑，但最开始的时候，我的算式是这样的:overtime % 60000 * 6 / 1000 ，得到的是这样的：</p>
<p><img src="/2018/11/21/Android%E6%97%B6%E9%92%9F%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/8.gif" alt></p>
<p>由于gif的丢帧问题，这里表现的不是很明显，但可以告知的是，因为这样的算式最后计算出的值类型为int，所以表现上会是那种持续跳动的动画，而不是圆滑过渡的动画。这给了我一个教训：<strong>动画的过渡要想平滑，数值的精度一定要高</strong>。</p>
<h2 id="外环刻度盘"><a href="#外环刻度盘" class="headerlink" title="外环刻度盘"></a>外环刻度盘</h2><p>外环刻度盘有两种实现方法，一是通过设定绘制区域不变，边旋转画布边绘制刻度的方法；二是通过计算每个刻度的起点和终点并绘制来实现。讲道理按实现容易度来讲，应该按第一种来实现比较简单，不过因为我前几个实现全采用的三角函数计算，所以这里我的思维还是采用三角函数的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;绘制外环刻度</span><br><span class="line">for(float i &#x3D;0;i&lt;360;i&#x3D;i+2)&#123;</span><br><span class="line">	degree &#x3D; Math.toRadians(i);</span><br><span class="line">    double x1 &#x3D; centerX + outerCircleRadius * Math.sin(degree);</span><br><span class="line">    double y1 &#x3D; centerY - outerCircleRadius * Math.cos(degree);</span><br><span class="line">    double x2 &#x3D; centerX + (outerCircleRadius - outerCircleWidth) * Math.sin(degree);</span><br><span class="line">    double y2 &#x3D; centerY - (outerCircleRadius - outerCircleWidth) * Math.cos(degree);</span><br><span class="line">    if(i &gt;&#x3D; 270 &amp;&amp; i &lt;&#x3D; 360)&#123;</span><br><span class="line">    	paints[2].setAlpha((int)((i-270)*1.5+100));</span><br><span class="line">	&#125;else if(i &#x3D;&#x3D; 0)&#123;</span><br><span class="line">    	paints[2].setAlpha(240);</span><br><span class="line">	&#125;else &#123;</span><br><span class="line">    	paints[2].setAlpha(100);</span><br><span class="line">	&#125;</span><br><span class="line">    canvas.drawLine((float)x1,(float)y1,(float)x2,(float)y2,paints[2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以绘制出来一个静态的刻度盘，这个刻度盘有180道刻度，且为了赋予刻度盘一个动画的效果，最后的45道刻度以及第一道刻度赋予不同的透明度，造成淡化的效果。那么接下来，只要让刻度盘转起来就行了。</p>
<p>在最开始我想仿制分针的转动实现，但想了想，计算量大，考虑的东西有点多，后来就转为了转动画布的想法。不过，刻度盘的绘制以及转动的实现一定要放在其他三个指针的实现之前，不然会带动三个指针一起转动，这样，指针的指向就与当前时间不符了。</p>
<p>有了方向，实现转动效果就可以了。转动效果包括两点：1、每秒转动3次，即每333ms为一次转动契机；2、每次都比上次的转动角度大2度。所以，角度计算如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;计算当前时间是（几时几分）几秒</span><br><span class="line">long overSecond &#x3D; overtime % 60000;</span><br><span class="line">&#x2F;&#x2F;每秒跨格6度，每333ms跨格2度</span><br><span class="line">double degree &#x3D; overSecond &#x2F; 1000 * 6 + overSecond % 1000 &#x2F; 333 * 2;</span><br></pre></td></tr></table></figure>
<p>计算完了，就是画布的旋转。画布的旋转跟想象中的很不一样，但我也不会在这里详解，只贴出来使用流程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas.save();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;计算角度</span><br><span class="line">&#x2F;&#x2F;以圆心为中心旋转</span><br><span class="line">canvas.rotate((float)degree,centerX,centerY);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;绘制刻度盘</span><br><span class="line"></span><br><span class="line">canvas.restore();</span><br></pre></td></tr></table></figure>
<p>这样就可以实现刻度盘的转动了。</p>
<p><del>（神特么这个转动角度让我钻了牛角尖，想了整整一天才想出来怎么计算）</del></p>
<h2 id="3D视角的转动"><a href="#3D视角的转动" class="headerlink" title="3D视角的转动"></a>3D视角的转动</h2><p>3D视角的转动主要借助于camera和matrix的结合实现。这个部分的动画功能设想是，当点击时钟周围，时钟会侧向点击方向；手指松开屏幕时，时钟会重新回到原来的位置，实现效果如下：</p>
<p><img src="/2018/11/21/Android%E6%97%B6%E9%92%9F%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/9.gif" alt></p>
<p>实现思路：给view类添加点击事件的监听，当手指按下时，获取点击点的坐标，与中心点对比后判断时钟旋转方向并旋转；手指松开时，加一个时钟恢复原位的动画，这样就算完成了。</p>
<p>代码实现如下：</p>
<p>1、添加点击事件监听。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private ValueAnimator shakeAnim;</span><br><span class="line">...</span><br><span class="line">@Override</span><br><span class="line">public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">	switch (event.getAction())&#123;</span><br><span class="line">    	case MotionEvent.ACTION_DOWN:       &#x2F;&#x2F;手指按下时，而非向下的手势</span><br><span class="line">        	if(shakeAnim !&#x3D; null &amp;&amp; shakeAnim.isRunning())&#123;</span><br><span class="line">            	shakeAnim.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">			&#x2F;&#x2F;获取点击点的坐标并进行处理</span><br><span class="line">            getCameraRotate(event);</span><br><span class="line">            break;</span><br><span class="line">        case MotionEvent.ACTION_MOVE:       &#x2F;&#x2F;手指移动时</span><br><span class="line">            getCameraRotate(event);</span><br><span class="line">            break;</span><br><span class="line">        case MotionEvent.ACTION_UP:         &#x2F;&#x2F;手指抬起时，而非向上的手势</span><br><span class="line">			&#x2F;&#x2F;抬起后进行时钟恢复原位的动画</span><br><span class="line">            startShakeAnim();</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、获取点击点坐标并进行角度判断。与中心点坐标进行对比，为防止时钟偏移角度过大，设定最大旋转角度为30度，最后获取到角度后，在onDraw()方法中对视图进行视角的旋转操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private float cameraRotateX;				&#x2F;&#x2F;camera视角中x轴转动的角度</span><br><span class="line">private float cameraRotateY;				&#x2F;&#x2F;camera视角中y轴转动的角度</span><br><span class="line">private final maxCameraRotate &#x3D; 30;			&#x2F;&#x2F;最大旋转角度</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F;获取点击点</span><br><span class="line">private void getCameraRotate(MotionEvent event)&#123;</span><br><span class="line">	if(shakeAnim !&#x3D; null &amp;&amp; shakeAnim.isRunning())&#123;</span><br><span class="line">    	shakeAnim.cancel();</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;与中心点坐标进行对比</span><br><span class="line">    float rotateX &#x3D; -(event.getY() - 640);</span><br><span class="line">    float rotateY &#x3D; (event.getX() - 360);</span><br><span class="line">    &#x2F;&#x2F;求出此时旋转的大小与半径之比</span><br><span class="line">    float percentX &#x3D; rotateX &#x2F; outerCircleRadius;</span><br><span class="line">    float percentY &#x3D; rotateY &#x2F; outerCircleRadius;</span><br><span class="line">    if(percentX &gt; 1)&#123;</span><br><span class="line">    	percentX &#x3D; 1;</span><br><span class="line">	&#125;else if(percentX &lt; -1)&#123;</span><br><span class="line">    	percentX &#x3D; -1;</span><br><span class="line">	&#125;</span><br><span class="line">    if(percentY &gt; 1)&#123;</span><br><span class="line">    	percentX &#x3D; 1;</span><br><span class="line">	&#125;else if(percentY &lt; -1)&#123;</span><br><span class="line">    	percentY &#x3D; -1;</span><br><span class="line">	&#125;</span><br><span class="line">    &#x2F;&#x2F;最终旋转的大小按比例匀称改变</span><br><span class="line">    cameraRotateX &#x3D; percentX * maxCameraRotate;</span><br><span class="line">    cameraRotateY &#x3D; percentY * maxCameraRotate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置3D时钟效果</span><br><span class="line">private void setCameraRotate()&#123;</span><br><span class="line">    cameraMatrix.reset();</span><br><span class="line">	&#x2F;&#x2F;camera的旋转与canvas的旋转用法很相似，先save()再旋转最后restore()</span><br><span class="line">    camera.save();</span><br><span class="line">    camera.rotateX(cameraRotateX);</span><br><span class="line">    camera.rotateY(cameraRotateY);</span><br><span class="line">    camera.getMatrix(cameraMatrix);</span><br><span class="line">    camera.restore();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;时钟旋转后视图会发生很大的视角偏差，所以需要通过平移来设定旋转后的时钟中心点</span><br><span class="line">    cameraMatrix.preTranslate(-getWidth()&#x2F;2,-getHeight()&#x2F;2);</span><br><span class="line">    cameraMatrix.postTranslate(getWidth()&#x2F;2,getHeight()&#x2F;2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、时钟恢复原位的动画。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void startShakeAnim()&#123;</span><br><span class="line">    PropertyValuesHolder cameraRotateXHolder &#x3D; PropertyValuesHolder.ofFloat(&quot;cameraRotateX&quot;,cameraRotateX,0);</span><br><span class="line">    PropertyValuesHolder cameraRotateYHolder &#x3D; PropertyValuesHolder.ofFloat(&quot;cameraRotateY&quot;,cameraRotateY,0);</span><br><span class="line">    shakeAnim &#x3D; ValueAnimator.ofPropertyValuesHolder(cameraRotateXHolder,cameraRotateYHolder);</span><br><span class="line">    shakeAnim.setInterpolator(new OvershootInterpolator(10));</span><br><span class="line">    shakeAnim.setDuration(500);</span><br><span class="line">    shakeAnim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">            cameraRotateX &#x3D; (float) animation.getAnimatedValue(&quot;cameraRotateX&quot;);</span><br><span class="line">            cameraRotateY &#x3D; (float) animation.getAnimatedValue(&quot;cameraRotateY&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    shakeAnim.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的ValueAnimator.ofPropertyValuesHolder(PropertyValuesHolder… values)方法可以同时管理多个动画属性，比起之前的分散式管理，代码量少，也更好阅读。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>终于把3D效果的实现部分补上了。沉迷了几天的Win10 UWP应用，这才回来补上没写完的部分。</p>
<p>哦对了，PPT的绘画真好用，以后就用PPT画图好了。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android盖章动画实现</title>
    <url>/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>毕设做完这么久了，我终于回来填我自己挖下的第一个坑了。话不多说，直奔主题。</p>
<a id="more"></a>
<p>在毕设中，有一个模块是赛程数据模块,如下图：</p>
<p><img src="/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/lol_match_data.png" alt></p>
<p>那个胜利图标的显示，其实我是想用一个章印落下的动画来实现的，只不过那时忙于后台，没来得及去细看动画方面的学习。不过这几天得了些兴致，就回来填一下坑。</p>
<p>先贴效果图，如下：</p>
<p><img src="/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/sample.gif" alt></p>
<p>接下来就讲一下实现的过程。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Android动画分为视图动画与属性动画，视图动画又分为逐帧动画与补间动画。逐帧动画的工作原理类似于动画片，将一张张拆分开来的动画通过连续播放的操作，形成动画的效果。补间动画则是对view进行一系列动画操作，包括平移（Translate）、透明度（Alpha）、旋转度（Rotate）与缩放（Scale）。属性动画与补间动画类似，但是这两者有一个最大的不同。比如说，一个仅占手机界面中间一部分的按钮，我们对它进行两种动画操作：一，补间动画，将按钮放大至铺满屏幕，点击屏幕边缘，发现并没有触发按钮点击事件，这是因为补间动画仅仅是将按钮绘制为铺满屏幕而已，按钮本身的大小、位置属性并没有发生变化；而第二种，属性动画，就是为了弥补补间动画的这一缺点，属性动画放大的按钮，大小和位置属性也会发生变化，铺满屏幕后仍然可以点击。</p>
<p>除此之外，补间动画只能实现上述的四种操作，且对象仅针对于可写于布局中的view对象。属性动画可以实现背景颜色的渐变等，且对canvas、point等有一定的支持。所以，说属性动画在一定程度上可以代替补间动画。</p>
<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>先搞清楚这个动画过程中都用到了什么操作，操作的顺序或触发时机是怎样的。</p>
<ul>
<li><p>章印本身是从无到有的，即透明度是从透明过渡到不透明的。</p>
</li>
<li><p>章印是从大到小落下去的，即用到了缩放。</p>
</li>
<li><p>章印在这个过程中有一定角度的旋转。</p>
</li>
<li><p>章印落下后，为给人一种有力的感觉，整个页面布局需要有一定的抖动效果实现，而抖动，就是多个方向的平移的组合实现。</p>
</li>
</ul>
<p>这下就很清楚了。章印在落下的过程中，调用了透明度、缩放、旋转的属性动画；落下后，整个布局调用了平移的属性动画。那么接下来，只要搞清楚每个属性动画怎么实现就行了。</p>
<h1 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h1><h2 id="ValueAnimator"><a href="#ValueAnimator" class="headerlink" title="ValueAnimator"></a>ValueAnimator</h2><p>这个类是Android的属性动画机制中最核心的一个类。属性动画的运行机制，是通过对变化属性的值进行不断的运算，并赋予视图属性来实现的。它使得整个动画过程过渡得比较平滑，使人看起来很舒服。我们可以通过调用这个类，来观察值的变化规律。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ValueAnimator anim &#x3D; ValueAnimator.ofFloat(0f, 1f);</span><br><span class="line">                anim.setDuration(500);</span><br><span class="line">                anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">                        float currentValue &#x3D; (float) animation.getAnimatedValue();</span><br><span class="line">                        Log.d(&quot;TAG&quot;, &quot;cuurent value is &quot; + currentValue);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                anim.start();</span><br></pre></td></tr></table></figure>
<p>值的变化如下：</p>
<p><img src="/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/1.png" alt></p>
<p>通过值的变化可以看出，类似于正弦函数y=sinx位于-π/2到π/2之间的曲线图的变化，很贴近，起步缓，中期变化快，最后缓。不过，ofFloat方法中不止可以只传入两个值，大家可以自行传入更多的值观察变化。</p>
<p>这个类相比于表层的ObjectAnimator类，我们对后者会接触的更多一些。下面就会对效果做一些实现和演示。</p>
<h2 id="透明度-Alpha"><a href="#透明度-Alpha" class="headerlink" title="透明度 Alpha"></a>透明度 Alpha</h2><p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectAnimator animator &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;alpha&quot;,1f,0f,1f,0f,1f);</span><br><span class="line">animator.setDuration(5000);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure>
<p>实现效果：</p>
<p><img src="/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/2.gif" alt></p>
<p>可以看到，这里通过调用ofFloat()方法创建了一个ObjectAnimator的实例，其他效果的实现也大多与此类似。对于alpha属性来说，0表示透明，1表示不透明。对于ofFloat来说，属性后的数值个数传入是没有限制的。这里传入三个值是可以的，传入五个或者更多也是可以的。setDuration方法设置整个动画的时长，注意，是整个，而不是每个变化之间的时长。</p>
<p>还有，在这次实现效果中，可以看到第一次隐去和第二次显现的过程较长，而第一次显示和第二次隐去的过程较短。这就与上面提到的ValueAnimator的值的变化规律有关了。</p>
<h2 id="旋转-rotation"><a href="#旋转-rotation" class="headerlink" title="旋转 rotation"></a>旋转 rotation</h2><p>接下来的其他属性动画代码，不一样的大概就是关键字了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectAnimator animator &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;rotation&quot;,0f,360f);</span><br><span class="line">                animator.setDuration(5000);</span><br><span class="line">                animator.start();</span><br></pre></td></tr></table></figure>
<p>实现效果：</p>
<p><img src="/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/3.gif" alt></p>
<h2 id="平移-translation"><a href="#平移-translation" class="headerlink" title="平移 translation"></a>平移 translation</h2><p>这就要先说一下Android的坐标系了，如下：</p>
<p><img src="/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/4.jpg" alt></p>
<p>以我们要操作的view控件为中心，向右x增加，向下y增加。掌握这个规律后，对view操作就比较好用了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float curTranslationX &#x3D; vicImg.getTranslationX();</span><br><span class="line">                float curTranslationY &#x3D; vicImg.getTranslationY();</span><br><span class="line">                ObjectAnimator animatorX &#x3D; ObjectAnimator.ofFloat(vicImg, &quot;translationX&quot;, curTranslationX, -500f, curTranslationX);</span><br><span class="line">                ObjectAnimator animatorY &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;translationY&quot;, curTranslationY, -500f,curTranslationY);</span><br><span class="line">                animatorX.setDuration(5000);</span><br><span class="line">                animatorY.setDuration(5000);</span><br><span class="line">                animatorX.start();</span><br><span class="line">                animatorY.start();</span><br></pre></td></tr></table></figure>
<p>实现效果：</p>
<p><img src="/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/5.gif" alt></p>
<h2 id="缩放-scale"><a href="#缩放-scale" class="headerlink" title="缩放 scale"></a>缩放 scale</h2><p>缩放也同平移一样，也有x方向和y方向上的缩放。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectAnimator animatorX &#x3D; ObjectAnimator.ofFloat(vicImg, &quot;scaleX&quot;, 1f,3f,1f);</span><br><span class="line">                ObjectAnimator animatorY &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;scaleY&quot;, 1f,3f,1f);</span><br><span class="line">                animatorX.setDuration(2000);</span><br><span class="line">                animatorY.setDuration(2000);</span><br><span class="line">                animatorX.start();</span><br><span class="line">                animatorY.start();</span><br></pre></td></tr></table></figure>
<p>实现效果：</p>
<p><img src="/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/6.gif" alt></p>
<p>这样，基本就学到了每个属性动画的简单用法。</p>
<h2 id="动画组合"><a href="#动画组合" class="headerlink" title="动画组合"></a>动画组合</h2><p>独立的属性动画很难出彩，但如果将多个结合到一起，那就很不错了。而AnimatorSet类整合实现了组合动画的功能。它主要包括了以下四个方法：</p>
<ul>
<li><p>after(Animator anim)：将现有动画插入到传入的动画之后执行</p>
</li>
<li><p>after(long delay)：将现有动画延迟指定时间后执行</p>
</li>
<li><p>before(Animator anim)：将现有动画插入到传入的动画之前执行</p>
</li>
<li><p>with(Animator anim)：将现有动画与传入动画同时执行</p>
</li>
</ul>
<p>有了这个类，我们就可以完成组合动画了。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectAnimator animatorAlpha &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;alpha&quot;,1f,0f,1f);</span><br><span class="line">                ObjectAnimator rotationAnimator &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;rotation&quot;,0f,360f);</span><br><span class="line">                ObjectAnimator animatorX &#x3D; ObjectAnimator.ofFloat(vicImg, &quot;scaleX&quot;, 1f,3f,1f);</span><br><span class="line">                ObjectAnimator animatorY &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;scaleY&quot;, 1f,3f,1f);</span><br><span class="line">                AnimatorSet animatorSet &#x3D; new AnimatorSet();</span><br><span class="line">                animatorSet.play(animatorX).with(animatorY).with(animatorAlpha).before(rotationAnimator);</span><br><span class="line">                animatorSet.setDuration(2000);</span><br><span class="line">                animatorSet.start();</span><br></pre></td></tr></table></figure>
<p>代码可以看出来，组合出来的动画是，x方向和y方向同时放大3倍再缩小回原大小，同时还由不透明变为透明再变为不透明。这三个动画组合播放结束后，再旋转360度。<strong>注意，before和after是相对play和with的动画而言的，传入before的动画，会在最后执行，传入after的动画，会在最开始执行。</strong></p>
<p>效果如下：</p>
<p><img src="/2018/08/02/Android%E7%9B%96%E7%AB%A0%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/7.gif" alt></p>
<h2 id="Xml动画配置"><a href="#Xml动画配置" class="headerlink" title="Xml动画配置"></a>Xml动画配置</h2><p>通过ObjectAnimator类可以完成动画编写，xml格式也可以完成。对于属性配置，我们优先选择xml文件进行编写。我们也可以写动画静态类，不过一般静态类我们用来写业务方面的方法。所以，xml格式的配置学习也是必要的。</p>
<ul>
<li>scale</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;set xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;</span><br><span class="line">    &lt;scale android:duration&#x3D;&quot;2000&quot;</span><br><span class="line">        android:fromXScale&#x3D;&quot;1.0&quot;</span><br><span class="line">        android:fromYScale&#x3D;&quot;1.0&quot;</span><br><span class="line">        android:toXScale&#x3D;&quot;2.0&quot;</span><br><span class="line">        android:toYScale&#x3D;&quot;2.0&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;set&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>rotate</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;set xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;</span><br><span class="line">    &lt;rotate android:duration&#x3D;&quot;2000&quot;</span><br><span class="line">        android:fromDegrees&#x3D;&quot;0&quot;</span><br><span class="line">        android:toDegrees&#x3D;&quot;30&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;set&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>translate</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;set xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;</span><br><span class="line">    &lt;translate android:duration&#x3D;&quot;2000&quot;</span><br><span class="line">        android:fromXDelta&#x3D;&quot;-50&quot;</span><br><span class="line">        android:fromYDelta&#x3D;&quot;-50&quot;</span><br><span class="line">        android:toXDelta&#x3D;&quot;50&quot;</span><br><span class="line">        android:toYDelta&#x3D;&quot;50&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;set&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>alpha</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;set xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;</span><br><span class="line">    &lt;translate android:duration&#x3D;&quot;2000&quot;</span><br><span class="line">        android:fromXDelta&#x3D;&quot;-50&quot;</span><br><span class="line">        android:fromYDelta&#x3D;&quot;-50&quot;</span><br><span class="line">        android:toXDelta&#x3D;&quot;50&quot;</span><br><span class="line">        android:toYDelta&#x3D;&quot;50&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;set&gt;</span><br></pre></td></tr></table></figure>
<p>四种标签属性的代码的基本属性代码如上所示（效果图我就不贴出了，太麻烦了，录制MP4还得转换在线格式）。</p>
<p>不过，在查资料的过程中，还有这么一个基本属性：pivotX、pivotY</p>
<p>这个属性的值有三种：数值、百分数、百分数p，分别比如：50、50%、50%p。当为数值时，表示在当前View的左上角，即原点处加上50px，做为起始缩放点；如果是50%，表示在当前View的左上角加上自己宽度的50%做为起始点；如果是50%p，那么就是表示在当前的左上角加上父控件宽度的50%做为起始点x轴坐标，这个父控件，可以是整个布局，也可以只是一个横行布局等。</p>
<p>标签属性毕竟是跟Animation类一样的，所以它也有如下属性：</p>
<ul>
<li><p>duration：动画时长，单位毫秒</p>
</li>
<li><p>fillAfter：可设置，若为true，则动画结束时，保持动画的结束状态</p>
</li>
<li><p>fillBefore：可设置，若为true，则动画结束时，还原到动画开始前的状态</p>
</li>
<li><p>repeatMode：重复类型，有reverse和restart两个值，前者表示倒序回放，后者表示重放一遍。</p>
</li>
<li><p>interpolator：设定插值器，即指定的动画效果。在此处只用到了CycleInterpolator，用于指定动画循环次数。</p>
</li>
</ul>
<p>其他博客上挂出来的其他属性，我在当前版本的AndroidStudio上是没办法使用的。这种情况遇到过很多次了，很多别人挂出来的代码并不能用，自己还得去找新的实现办法。所以以后如果我觉得有必要的话，挂一下开发环境，省的自己和别人为不能重用代码的问题烦恼。</p>
<p>话题说远了，不过用到的知识差不多也就剩下CycleInterpolator和别的一点东西了。它的用法也很简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;cycleInterpolator xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    android:cycles&#x3D;&quot;2&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>一目了然。cycles属性指定重复动作次数，且这个插值器使用时，动画的值会按照正弦函数一样变化。以后若是需要用到其他的插值器，我再去做深入的了解。</p>
<p>对了，差点忘记了set标签。在单个动画动作xml文件中，其实可以存放多组动作标签，而set就负责对它们的执行顺序进行排列和组合。主要属性：ordering，值有两种：Sequentially（顺序执行）和together（同时执行）。用法也很简单，会直接在实现代码中贴出来。</p>
<h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><p>我采用了两种代码结合的办法。<del>别问我为什么，我也想只用xml，但特喵的就是不抖动，只好还是用原来的两种形式结合的代码了</del></p>
<p>Activity.java:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void gaizhang()&#123;</span><br><span class="line">        &#x2F;&#x2F;透明度渐变动画</span><br><span class="line">        ObjectAnimator alphaAnimator &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;alpha&quot;,0f,1f,1f);</span><br><span class="line">        alphaAnimator.setDuration(1000);</span><br><span class="line">        alphaAnimator.start();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;旋转渐变动画</span><br><span class="line">        ObjectAnimator rotationAnimator &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;rotation&quot;,-30f,0f);</span><br><span class="line">        rotationAnimator.setDuration(500);</span><br><span class="line">        rotationAnimator.start();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;大小变化动画</span><br><span class="line">        ObjectAnimator yAnimator &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;scaleY&quot;,5f,1f,1f);</span><br><span class="line">        ObjectAnimator xAnimator &#x3D; ObjectAnimator.ofFloat(vicImg,&quot;scaleX&quot;,5f,1f,1f);</span><br><span class="line">        yAnimator.setDuration(1000);</span><br><span class="line">        xAnimator.setDuration(1000);</span><br><span class="line">        yAnimator.start();</span><br><span class="line">        xAnimator.start();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;界面抖动动画</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(500);</span><br><span class="line">                &#125;catch (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                handler.sendEmptyMessage(20);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private Handler handler &#x3D; new Handler()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            switch (msg.what)&#123;</span><br><span class="line">                case 20:</span><br><span class="line">                    &#x2F;&#x2F;界面抖动动画</span><br><span class="line">                    Animation shake &#x3D; AnimationUtils.loadAnimation(getApplicationContext(),R.anim.myanim);</span><br><span class="line">                    constraintLayout.startAnimation(shake);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>shake_anim.xml:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;set xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    android:interpolator&#x3D;&quot;@anim&#x2F;cycle_2&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration&#x3D;&quot;100&quot;</span><br><span class="line">        android:fromXDelta&#x3D;&quot;-10&quot;</span><br><span class="line">        android:fromYDelta&#x3D;&quot;0&quot;</span><br><span class="line">        android:toXDelta&#x3D;&quot;0&quot;</span><br><span class="line">        android:toYDelta&#x3D;&quot;-10&quot; &#x2F;&gt;&lt;!--向上十个单位--&gt;</span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration&#x3D;&quot;100&quot;</span><br><span class="line">        android:fromXDelta&#x3D;&quot;0&quot;</span><br><span class="line">        android:fromYDelta&#x3D;&quot;-10&quot;</span><br><span class="line">        android:startOffset&#x3D;&quot;100&quot;</span><br><span class="line">        android:toXDelta&#x3D;&quot;10&quot;</span><br><span class="line">        android:toYDelta&#x3D;&quot;0&quot; &#x2F;&gt;&lt;!--向右十个单位--&gt;</span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration&#x3D;&quot;100&quot;</span><br><span class="line">        android:fromXDelta&#x3D;&quot;10&quot;</span><br><span class="line">        android:fromYDelta&#x3D;&quot;0&quot;</span><br><span class="line">        android:startOffset&#x3D;&quot;200&quot;</span><br><span class="line">        android:toXDelta&#x3D;&quot;0&quot;</span><br><span class="line">        android:toYDelta&#x3D;&quot;10&quot; &#x2F;&gt;&lt;!--向下十个单位--&gt;</span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration&#x3D;&quot;100&quot;</span><br><span class="line">        android:fromXDelta&#x3D;&quot;0&quot;</span><br><span class="line">        android:fromYDelta&#x3D;&quot;10&quot;</span><br><span class="line">        android:startOffset&#x3D;&quot;300&quot;</span><br><span class="line">        android:toXDelta&#x3D;&quot;-10&quot;</span><br><span class="line">        android:toYDelta&#x3D;&quot;0&quot; &#x2F;&gt;&lt;!--向左是个单位--&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;set&gt;</span><br></pre></td></tr></table></figure>
<p>cycleIntepolator.xml：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;cycleInterpolator xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">android:cycles&#x3D;&quot;2&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这篇博客前半部分，即xml属性章节之前，我花了一天就写出来了，但因为个人极度讨厌网页标签这种代码（布局代码还行，但属性xml就特别烦），xml一直拖着不想写，9号了才耐着性子把它写出来。希望，之后的动画学习，不会有太多的xml文件代码。</p>
<p>参考博客：<a href="https://blog.csdn.net/guolin_blog/article/details/43536355">Android属性动画完全解析(上)，初识属性动画的基本用法</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>lemon</title>
    <url>/2020/06/24/lemon/</url>
    <content><![CDATA[<p>歌名：lemon</p>
<a id="more"></a>
<p>应好友的要求，第二首就写一下lemon。<strong>第三行注音是日语注音</strong>。</p>
<h1 id="歌"><a href="#歌" class="headerlink" title="歌"></a>歌</h1><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="430" height="86" src="//music.163.com/outchain/player?type=2&id=536622304&auto=0&height=66"></iframe>

<p>（网易版权原因，无法播放）</p>
<h1 id="MV"><a href="#MV" class="headerlink" title="MV"></a>MV</h1><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
    <iframe src="//player.bilibili.com/player.html?aid=88558801&bvid=BV1e7411V75v&cid=155163214&page=1&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe>
</div>

<h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>１</p>
<p>ゆめ<br>夢　ならばどれほどよかったでしょう<br>yu me na ra ba do re ho do yo ka tta de shou</p>
<p>いま　　　　　　　　　ゆめ<br>未　だにあなたのことを夢　にみる<br>i ma da ni a na ta no ko to wo yu me ni mi ru</p>
<p>わす　　もの　と　　かえ　<br>忘　れた物　を取りに帰　るように<br>wa su re ta mo no wo to ri ni ka e ru yo u ni</p>
<p>ふる　　おも　で　ほこり　はら<br>古　びた思　い出の埃　　を払　う<br>fu ru bi ta o mo i de no ho ko ri wo ha ra u</p>
<p>もど　　　しあわ<br>戻　らない幸　　せがあることを<br>mo do ra na i shi a wa se ga a ru ko to wo</p>
<p>さいご         おし<br>最後　にあなたが教　えてくれた<br>sa i go ni a na ta ga o shi e te ku re ta</p>
<p>い　　　かく　　　くら　かこ<br>言えずに隠　してた昏　い過去も<br>i e zu ni ka ku shi te ta ku ra i ka ko mo</p>
<p>　　　　　　　　えいえん　くら<br>あなたがいなきゃ永遠　　に昏　いまま<br>a na ta ga i na ki ya e i e n ni ku ra i ma ma</p>
<p>　　　　　　　いじょうきず<br>きっともうこれ以上　　傷　つくことなど<br>ki tto mo u ko re i jyou ki zu tsu ku ko to na do</p>
<p>ありはしないとわかっている<br>a ri wa shi na i to wa ka tte i ru</p>
<p>　　ひ　かな　　　　　　　ひ　くる<br>あの日の悲　しみさえ　あの日の苦　しみさえ<br>a no hi no ka na shi mi sa e   a no hi no ku ru shi mi sa e</p>
<p>　　　　　　あい<br>そのすべてを愛　してた　あなたとともに<br>so no su be te wo a i shi te ta  a na ta to to mo ni</p>
<p>むね　のこ　はな　　　　にが　　　　　にお<br>胸　に残　り離　れない　苦　いレモンの匂　い<br>mu ne ni no ko ri ha na re na i   ni ga i remon no ni o i</p>
<p>あめ　ふ　や　　　かえ<br>雨　が降り止むでは帰　れない<br>a me ga fu ri ya mu ma de wa ka e re na i</p>
<p>いま　　　　　　　　　　ひかり<br>今　でもあなたはわたしの光<br>i ma te mo a na ta wa wa ta shi no hi ka ri</p>
<p>２</p>
<p>くらやみ　　　　　せ<br>暗闇　　であなたの背をなぞった<br>ku ra ya mi te a na ta no se wo na zo tta</p>
<p>　　りんかく　せんめい　おぼ<br>その輪郭　　を鮮明　　に覚　えている<br>so no ri n ka ku wo se n me i ni o bo e te i ru</p>
<p>う　と　　　　　　　　であ<br>受け止めきらないものと出会うたび<br>u ke to me ki ra n i mo no to de a u ta bi</p>
<p>あふ　　　　　　　　なみだ<br>溢　れてやまないのは涙　　だけ<br>a fu re te ya ma na i no wa na mi da da ke</p>
<p>なに　　　　　　　なに　み<br>何　をしていたの　何　を見ていたの<br>na ni wo shi te i ta no   na ni wo mi te i ta no</p>
<p>　　　　し　　　よこがお<br>わたしの知らない横顔　　で<br>wa ta shi no shi ra na i yo ko ga o de</p>
<p>　　　　　　　　いま　　　　　おな　よう<br>どこかであなたが今　　わたしと同　じ様　な<br>do ko ka de a na ta ga i ma    wa ta shi to o na ji yo u na</p>
<p>なみだ　　　　さび　　　なか<br>涙　　にくれ　淋　しさの中　にいるなら<br>na mi da ni ku re   sa bi shi sa no na ka ni i so na ra</p>
<p>　　　　　　　　　　　　わす<br>わたしのことなどどうか　忘　れてください<br>wa ta shi no ko to na do do so ka    wa su re te ku da sa i</p>
<p>　　　　　　こころ　　ねが<br>そんなことを心　　から願　うほどに<br>so n na ko to wo ko ko ro ka ra ne ga u ho do ni</p>
<p>いま　　　　　　わたし　ひかり<br>今　でもあなたは私　　の光<br>i ma de mo a na ta wa wa ta shi no hi ka ri</p>
<p>３</p>
<p>じぶん　おも<br>自分　か思　うより<br>ji bu n ka o mo u yo ri</p>
<p>こい<br>恋　をしていたあなたに<br>ko i wo shi te i ta a na ta ni</p>
<p>　　　　おも<br>あれから思　うように<br>a re ka ra o mo u yo u ni</p>
<p>いき<br>息　ができない<br>i ki ga de ki na i </p>
<p>　　　　そば<br>あんなに側　にいたのに<br>a n na ni so ba ni i ta no ni</p>
<p>　　　うそ<br>まるで噓　みたい<br>ma ru de u so mi ta i </p>
<p>　　　わす<br>とても忘　れらない<br>to te mo wa su re ra na i</p>
<p>　　　　　たし<br>それだけが確　か<br>so re da ke ga ta shi ka</p>
<p>　　ひ　かな　　　　　　　ひ　くる<br>あの日の悲　しみさえ　あの日の苦　しみさえ<br>a no hi no ka na shi mi sa e   a no hi no ku ru shi mi sa e</p>
<p>　　　　　　あい<br>そのすべてを愛　してた　あなたとともに<br>so no su be te wo a i shi te ta  a na ta to to mo ni</p>
<p>むね　のこ　はな　　　　にが　　　　　にお<br>胸　に残　り離　れない　苦　いレモンの匂　い<br>mu ne ni no ko ri ha na re na i   ni ga i remon no ni o i</p>
<p>あめ　ふ　や　　　かえ<br>雨　が降り止むでは帰　れない<br>a me ga fu ri ya mu ma de wa ka e re na i</p>
<p>き　わ　　かじつ　かたほう　よう<br>切り分けた果実　の片方　　の様　に<br>ki ri wa ke ta ka ji tsu no ka ta ho u no yo u ni</p>
<p>いま　　　　　　　　　　ひかり<br>今　でもあなたはわたしの光<br>i ma de mo a na ta wa wa ta shi no hi ka ri</p>
]]></content>
      <categories>
        <category>Song</category>
      </categories>
  </entry>
  <entry>
    <title>《小情歌》读后感</title>
    <url>/2018/09/22/%E3%80%8A%E5%B0%8F%E6%83%85%E6%AD%8C%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<p>（此文写于2018年，早于新博客建成时间。想不到还能找到最初的备份博客，就搬过来了）</p>
<a id="more"></a>
<p>（愿你能听着这首我最喜欢的钢琴曲读这篇文章）</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="430" height="86" src="//music.163.com/outchain/player?type=2&id=22829937&auto=0&height=66"></iframe>

<p>辞职几天后，我买的《小情歌》终于到手了，花了四天时间，我终于读完了这本本该高中就应该拜读的作品。</p>
<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>我一向不喜欢谈到我的高中青春，只因我的高中生活过得实在不是很欢喜，或者说，至今为止，我看待高中生活的角度，也只有情愫而已。我知道自己的眼光狭隘了些，大概是因为此事有逆所以格外上心。在那段时间内，我曾有幸读到徐璐的一篇文章《忽然长大》。那是迄今为止我读过的，描述那时我的心境最细腻贴切，最能打动我的文字。文中的陆希，遥远地，怯懦地，卑微地，喜欢着她所欣赏的高远。她有过初次谈话时的欢喜，有过期盼却不得的失落，有过遇见心上人与他人约会时的难过，有过日日夜夜的自我折磨，也有时间磨平后的淡然心态。最后，大概为了迎合那些俗套的桥段，陆希和高远重逢后在一起了（笑）。后来我曾找到这篇文章的出处，是徐璐的大学毕设自选的自写短篇小说集《从此尽情飞翔》（真是羡慕作者的勇气）。可失望的是，我通读了全文，再没能看到一篇能更打动我的文章。这怪不得徐璐，我想只是时间久了，对初尝的感动的愿望太过强烈，反复回味后，便尝不出当初的味道。</p>
<p>是我感情类小说读的太少，也或是我已经拿不出全部精力去揣摩所有角色的心境，读完全书，我竟觉得这本书像是在记流水账，得不出一丝真情实感；但这账目的条款却写的细致分明，比我记忆中的高中青春更像是一个真实世界。高中同学的身影，在这些角色的故事中重现，但我的脑袋里一片混沌，始终想不起所有人；我活在了自己的世界中，只想找到像极了自己的那一个角色，寻求一丝丝最后的触感和安慰。</p>
<h1 id="缘生"><a href="#缘生" class="headerlink" title="缘生"></a>缘生</h1><p>《忽然长大》是一篇美好的，包含遗憾与圆满的童话故事；《小情歌》是一篇人物色彩与情感丰富、有血有肉的现实故事。《忽然长大》，只是《小情歌》中那一个，女主角最符合我的扮演角色的，缩影而已。</p>
<p>一谈到感情，我就会把世界过的很独。段晴、柳清清、尹冰心等等角色，不过是高中那些同学的一个个写照，这些与我无甚关系。我只关心自己，和她而已。可偏偏最不幸的是，从高二开始，我的眼界就变得愈发狭隘，只剩下了自己的感情世界。</p>
<p>每每此时，思绪乱做一团，我不知道故事该从哪里讲起，也不知道情绪该怎么宣泄才算合理。</p>
<p>像陆希一样，高远足够优秀，才吸引了她的注意力。《忽然长大》的故事过于真实，即使是暗恋的陆希，也会被高远和韩若雪的暧昧伤到痛彻心扉；但结局也过于美好，两个几年不见的人，会因为当初两个人埋在心底的相互喜欢而在一起。当然，我后来去拜读《似是故人来》，才知道陆希和高远最后还是曲终人散。不过，他们也算是圆了当初的这一份遗憾；但会不会，他们也正是因为遗憾的实现，而淡了感情呢？这些我就难以知道了。</p>
<p>最让我意外的，发展却又在情理之中的角色，是费鸣飞这个人。他平常那么大大咧咧，爱打听别人的八卦，跟同学都玩的很开，却不想，他也是一个把心事藏在肚子里的家伙。《忽然长大》里，他只是一个喜欢嘲笑陆希，跟陆希打闹的一个路人角色。可在《小情歌》里，他的形象，真正的饱满了起来。他在很早的时候，就喜欢陆希了，但却埋在心里，从来不说。高三出国临走前半年，他向陆希表白，陆希碍于友谊，也或许有些许的原因是碍于还喜欢着高远，没有接受他。费鸣飞因此沉沦半个月，但很快就恢复了当初的模样。一张写有“I like Lucy”的纸条，会藏在一张书桌里两年，直到他出国后，才告诉陆希这个秘密。他也像那些诗一样，“看你看过的风景”，陆希说过的喜欢的国外的词句，他会去细致的拜读一遍出处。表面看起来粗犷的男孩，竟然也会有如此细腻的心思，真是叫我惊诧不已。</p>
<p>到底还是过于自我，整本书我只记得了与陆希感情直接相关的人，其他人已经淡去了我的记忆。</p>
<h1 id="缘落"><a href="#缘落" class="headerlink" title="缘落"></a>缘落</h1><p>我像极了陆希。我不觉得说自己像一个女孩有什么羞愧，我和陆希一样内向，远观所喜欢的人却不敢靠近。我与她的想法都很多，很相近，甚至有时候我的想法会变得更快，委实不是一个男子汉的作风。</p>
<p>在某个晚上，我曾做过一个梦。在梦里，喜欢的女孩却反过来向我委婉表白。一时间，梦里的我竟然被这突如其来的幸福感击昏了头脑。她说出那句话的那一刻，我简直不敢置信，吃惊地望向她。她也显得慌乱了些，马上说“那要不算了……”。我反抱住她，说“我接受”。</p>
<p>梦醒了，现实与梦境的割裂感猛地向我袭来，一时间不禁淌了几滴泪。</p>
<p>我从来没有像身边的人一样，能体验一次恋爱的感觉。从高中刚懂得喜欢一个人开始，围绕着我的主题，就只有卑微的单相思。喜欢一个人，从来不难；可对我来说，若是要走下一步，往往只有碰壁而已。</p>
<p>我也曾为情流泪有几回，但这些不过都是一个人的孤单罢了。</p>
<p>一次是晚上听许嵩的《幻听》；两次是表白被拒后；而最凶狠的一次，呵，竟然是在梦里，醒来以后，发现枕头竟然湿了大半，可梦里的事情，我现在已经全然不记得了。</p>
<p>呵，原来我自己不止是忽略了别人的世界，连自以为重视的自己的事情，都开始渐渐淡忘了。呵，还真是讽刺。</p>
<p>我很想讲述自己喜欢的女生的故事，但这段文字敲写了多遍后，我决定不写的那么详细。</p>
<p>我第一个喜欢的女孩A，把我曾经鼓足勇气送的几瓶饮料，在高中毕业那天，如数奉还。她的婉拒之意已经很明显了，现在仔细想来，很感激她的做法，她不想影响到我学习的注意力吧；可她不知道的是，但我想她又不会看不出来，整个高三，我根本没有办法把所有的精力放在学习上。那时候每天回去宿舍，晚上开着台灯，一个人对着日记本，写下了很多挣扎难过的文字。</p>
<p>啊~，很多不美好的回忆都浮现了出来，令我现在很不愉快。</p>
<p>那时候身边的朋友估计已经察觉到了我的异变，想来也是，不可能察觉不到。那时候的我，表现得的确很不正常，整天沉迷于听BigBang的歌，写自己的东西，课也不会好好听。那时候的我，有没有现在这般颓废，我不清楚；我很羡慕费鸣飞，他的心态调整能力很强，半个月而已，就恢复如初；而我，不知不觉已经颓废几年有余了。</p>
<p>高三时，我拜读了太宰治的《人间失格》。心之所想，目之所见。因我整个高三的情绪基调是低落的，整本小说读下来，我感受到的，只是满溢而出的绝望。不，不是绝望，倒不如说，那是一潭死水。整本书在我看来，主人公根本像是逆来顺受，或是“心安理得”地接受着发生在身边的所有糟糕的事情，尤其在妻子被拜访的商人凌辱，不，也可能是通奸，他竟也能很快接受。整本书用一个成语来形容最适合不过了，“味同嚼蜡”。</p>
<p>我不想去讲我在喜欢A的过程中有过多少令人失落的事情，即使是现在，我也能感受得到当初的那份痛苦。失落到一定深处，就会变成绝望。绝望是会积攒的。它从来不会消失，只是被暂时掩埋。不确定哪一次，也许只是被挖开了一角，就会整个爆发出来。慢慢地，我开始怀疑自己。我始终觉得，是我自己不够优秀。我渐渐地丢掉了自信，慢慢开始变得自卑自微。</p>
<p>我为A做过的最后一件事情，就是那该死的一百道C语言指针练习题了。</p>
<p>那时候是大一末了，6月份。我很清楚地记着，达哥、祥哥和茂江三个人在玩内测的天涯明月刀，而我，用了一个星期，从早到晚，都在做那一百道指针题。那是她的期末作业，而那段时间她很忙，无暇顾及。虽然那时候我指针学得很烂，当然现在不用也忘得差不多了，但我还是“主动请缨”（呵，想来自己有点好笑），接下了这个任务。那个星期，我跟玩游戏的达哥他们一样很忙，我也像达哥他们一样，忙得很开心。</p>
<p>交完任务之后没几天，我就把A的所有联系方式都删掉了。</p>
<p>那一次帮忙，是我最后对A的一点补偿。那时候的我，比现在的我，要直男得多。我自觉之前说了很多对不起A的话，在几次挣扎之后，觉得无颜面对，完成任务之后，就再无联系了。</p>
<p>依我这优柔寡断的性格，我竟然也会有说离开就离开的一次。</p>
<p>现在想来，那时候少了一句“对不起”。</p>
<h1 id="缘灭"><a href="#缘灭" class="headerlink" title="缘灭"></a>缘灭</h1><p>第一次看完《秒速五厘米》、《言叶之庭》和《你的名字》的我，我的内心没有一丝波动。我的确已经变成了自己当初想要的模样。</p>
<p>任何一个脑子清醒的人，都不应该，也不会选择爱这个时候的我，包括现在。</p>
<p>我不是丧失了喜欢一个人的能力，恰恰相反，我很容易喜欢上一个人，但时间都不会长久了。可能一天，一周，一个月，但决计不会再是三年。我已经没有了全部气力，去投入到下一份喜欢了。</p>
<p>而且，自此之后，我都在怀疑自己的每一份喜欢，到底有没有资格，称得上是“喜欢”。</p>
<p>我没那么乐观。既然我已经认为自己不够资格，我就不应该再去喜欢什么人。只是这颗心一直无所适从，也想有处地方，能让我觉得舒适，觉得温暖。</p>
<p>我知道逃避不是最好的方法，可我自甘逃避。就像那句话，明知堕落误人，却自甘堕落。</p>
<p>实在是没有面对的勇气。</p>
<p>躲在角落自生自灭罢了。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>很久没有写过这样的东西了，兜兜转转竟然写了一个月，写完竟然还觉得有一点酸爽。大概自己真的是一个喜欢心理自虐、自我沉沦与自我麻痹的人吧。</p>
]]></content>
      <categories>
        <category>Book</category>
      </categories>
  </entry>
  <entry>
    <title>任务和返回堆栈</title>
    <url>/2020/07/08/%E4%BB%BB%E5%8A%A1%E5%92%8C%E8%BF%94%E5%9B%9E%E5%A0%86%E6%A0%88/</url>
    <content><![CDATA[<p>了解任务与返回堆栈的内容，对于合适地设置activity的启动模式，有很大的启发作用。</p>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>任务</strong>，是用户在使用时，产生的一系列activity的集合。一般来说，当启动一个新的activity时，系统会创建一个activity的新实例，并将这个实例放到一个堆栈中，这个堆栈即是<strong>返回堆栈</strong>。一般情况下，在第一次启动应用时，一个应用会创建一个相对应的任务和返回堆栈；同时，该应用的主activity也会作为返回堆栈的根activity。</p>
<p>返回堆栈的特点是，activity遵循<strong>“先进后出”（也可为“后进先出”）</strong>的原则，而且不会被重新排列。</p>
<p><img src="/2020/07/08/%E4%BB%BB%E5%8A%A1%E5%92%8C%E8%BF%94%E5%9B%9E%E5%A0%86%E6%A0%88/1.png" alt></p>
<p>图示即演示了新activity是如何添加到返回堆栈的。当用户按返回按钮时，当前activity会销毁，上一个activity将恢复。当堆栈中所有activity被移除后，任务也将不复存在。</p>
<p>Activity和任务的默认行为总结如下：（这段官网的描述很详细）</p>
<ul>
<li><p>当 Activity A 启动 Activity B 时，Activity A 会停止，但系统会保留其状态（例如滚动位置和输入到表单中的文本）。如果用户在 Activity B 中按返回按钮，系统会恢复 Activity A 及其状态。</p>
</li>
<li><p>当用户通过按主屏幕按钮离开任务时，当前 Activity 会停止，其任务会转到后台。系统会保留任务中每个 Activity 的状态。如果用户稍后通过点按该任务的启动器图标来恢复该任务，该任务会进入前台并恢复堆栈顶部的 Activity。</p>
</li>
<li><p>如果用户按返回按钮，当前 Activity 将从堆栈中退出并销毁。堆栈中的上一个 Activity 将恢复。Activity 被销毁后，系统不会保留该 Activity 的状态。</p>
</li>
<li><p>Activity 可以多次实例化，甚至是从其他任务对其进行实例化。</p>
</li>
</ul>
<h1 id="launchMode"><a href="#launchMode" class="headerlink" title="launchMode"></a>launchMode</h1><h2 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h2><p><strong>Activity的默认模式</strong>，这种模式下activity可以多次实例化。<strong>每个实例可以属于不同的任务，一个任务可以拥有多个实例。</strong></p>
<p>适用场景：大多数应用场景</p>
<h2 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h2><p><strong>栈顶复用模式</strong>。若堆栈的顶部已为当前activity实例，系统则会调用onNewIntent()方法获取已有实例；若栈顶不为当前activity实例，则会创建新的activity实例。</p>
<p>适用场景：通知消息打开的页面；登录页面等。</p>
<p>反面教材：<strong>微博</strong>：在A用户主页，<em>不进入单条微博详情</em>，点击任意一条微博的A用户头像，都会再次进入A用户主页，即生成新的Activity实例，进入一种“俄罗斯套娃”的怪圈。</p>
<p>正面教材：<strong>QQ</strong>和<strong>微博国际版</strong>：同样是在主页进行以上操作，QQ不会再次进入用户主页，微博国际版更是有屏幕抖动的效果来提醒当前已是目标用户主页。</p>
<h2 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h2><p><strong>栈内复用模式</strong>。与singleTop不同的是，此模式会检索栈内所有activity实例，而非仅限于栈顶。若存在对应实例，则调用onNewIntent()方法获取已有实例，并将其之上的所有activity实例出栈；若不存在对应实例，则新建实例。</p>
<p>适用场景：大多数APP的主页。这样的话，在退至主页时，之上的activity都会出栈，保证了退出应用时所有activity都会被销毁。</p>
<h2 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h2><p><strong>单一实例模式</strong>。这种模式下，activity实例会<strong>单独占用一个栈</strong>，在系统中具有全局唯一性。与前两者的区别在于，此模式的检索范围要扩大至整个系统。</p>
<p>适用场景：呼叫来电、闹钟响铃等界面。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>僕らの手には何もないけど、</title>
    <url>/2020/06/19/%E5%83%95%E3%82%89%E3%81%AE%E6%89%8B%E3%81%AB%E3%81%AF%E4%BD%95%E3%82%82%E3%81%AA%E3%81%84%E3%81%91%E3%81%A9%E3%80%81/</url>
    <content><![CDATA[<p>歌名：尽管我们手中空无一物</p>
<a id="more"></a>
<p>其实这类博客，严格来说也不算是在学日语，只是在学日语歌。我只是对将日语歌词，换成平假名和片假名。这样的话，一定程度上，可以加深我对这些音节的记忆。仅此而已。</p>
<h1 id="歌"><a href="#歌" class="headerlink" title="歌"></a>歌</h1><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="430" height="86" src="//music.163.com/outchain/player?type=2&id=32317208&auto=0&height=66"></iframe>

<h1 id="MV"><a href="#MV" class="headerlink" title="MV"></a>MV</h1><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
    <iframe src="//player.bilibili.com/player.html?aid=2361621&bvid=BV1Js411U7d5&cid=3691844&page=1&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe>
</div>

<h1 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h1><p>１</p>
<p>きみ　み<br>君　に見せたいものがあるんだ</p>
<p>こどく　よる<br>孤独　な夜　にもきっと</p>
<p>とお　　かがや　つづ<br>遠　くて輝　　き続　ける</p>
<p>いくせん　ほし<br>幾千　　の星　を</p>
<p>うしな<br>失　　うこと</p>
<p>わ　き<br>割り切れぬこと</p>
<p>はじ<br>弾　かれること</p>
<p>かの<br>叶　わないこと</p>
<p>　　あが<br>でも足掻くこと</p>
<p>しん<br>信　じぬくこと</p>
<p>うえ　む<br>上　を向いて</p>
<p>ある　だ<br>歩　き出すこと</p>
<p>ぼく　　て　　なに<br>僕　らの手には何　もないけど</p>
<p>かわりに　つなきあえるから</p>
<p>　　　　　　　まよ<br>ひとりきりで　迷　わないで</p>
<p>　　　ひ　　　て　はな<br>どんな日もこの手を離　さないから</p>
<p>２</p>
<p>きみ<br>君　にあげたいものがあるんだ</p>
<p>こご　　よる<br>凍　える夜　にはいつも</p>
<p>　　なに　しんぱなる(?)<br>もう何　も心配　等     せず</p>
<p>ねむ　　もうふ<br>眠　れる毛布　を</p>
<p>わす<br>忘　れられぬこと</p>
<p>た<br>耐えきれぬこと</p>
<p>すべ<br>術　がないこと</p>
<p>うば<br>奪　われること</p>
<p>　　きづ<br>でも気付くこと</p>
<p>きみ<br>君　がいること</p>
<p>まも<br>守　りたいものが</p>
<p>つよ<br>強　くさせること</p>
<p>じぶん　いろ　ほこ<br>自分　の色　を誇　れるうよに</p>
<p>じゆう　いろ　た<br>自由　に色　を足せばいい</p>
<p>　　　　　　　　　せかい<br>ぼやけていた　この世界　を</p>
<p>　　て　あや<br>この手が彩　ってゆくんだ</p>
<p>３</p>
<p>みと　　　　　ひと<br>認　めてくれる人　がいなくても</p>
<p>　　　　　かたが<br>サマになる肩書　きがなくても</p>
<p>ぼく　　ちさい　て　あした<br>僕　らの小　さな手は明日　きっと</p>
<p>だれ　　えがお<br>誰　かを笑顔　にできるから</p>
<h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>如果“君の日本语本当上手”的话，那么这段话请大佬自动跳过，若有兴趣还望指点一二。</p>
<p>在通过“一字一句一翻译”对比纠正发音的过程中，发现有些单词在结合某些单字的情况下，发音会发生变化。这一点在大学上日语选修课的时候就有了解，只不过当时没认真学，不知道这些变化的缘由及规则。</p>
<p>比如，“孤独”读作“さびしい”，但“孤独な”却又读作“こどくな”；“向”单字读“こ”，“向いて”又读作“むいて”。哦对了，还有“もう何も心配等せず”的“等”的读音也很让我迷惑，我用日语输入法没打出来这个字……</p>
<p><img src="/2020/06/19/%E5%83%95%E3%82%89%E3%81%AE%E6%89%8B%E3%81%AB%E3%81%AF%E4%BD%95%E3%82%82%E3%81%AA%E3%81%84%E3%81%91%E3%81%A9%E3%80%81/让人头大.jpg" alt></p>
]]></content>
      <categories>
        <category>Song</category>
      </categories>
  </entry>
  <entry>
    <title>牧场物语：重聚矿石镇个人记</title>
    <url>/2020/08/25/%E9%87%8D%E8%81%9A%E7%9F%BF%E7%9F%B3%E9%95%87/</url>
    <content><![CDATA[<p>游玩日期：2020-07-20 —— 2020-08-18</p>
<a id="more"></a>
<p>之前一段时间，突然对任天堂感兴趣了起来，就去买了几本关于任天堂的书，读完之后好感大增，于是来体验一下任天堂的游戏。</p>
<p>牧场物语确实挺好玩的，剧情上要比星露谷更生动一些。很感谢牧场物语，让我重拾了当年玩星露谷的快乐和悸动（牧场物语竟然还能磕CP，太甜了，多来几对不要停）。</p>
<p>放一些我家兰的图：</p>
<p>告白：<br><img src="/2020/08/25/%E9%87%8D%E8%81%9A%E7%9F%BF%E7%9F%B3%E9%95%87/1.jpg" alt></p>
<p>情侣事件：<br><img src="/2020/08/25/%E9%87%8D%E8%81%9A%E7%9F%BF%E7%9F%B3%E9%95%87/2.jpg" alt></p>
<p>求婚：<br><img src="/2020/08/25/%E9%87%8D%E8%81%9A%E7%9F%BF%E7%9F%B3%E9%95%87/3.jpg" alt></p>
<p><img src="/2020/08/25/%E9%87%8D%E8%81%9A%E7%9F%BF%E7%9F%B3%E9%95%87/4.jpg" alt></p>
<p><img src="/2020/08/25/%E9%87%8D%E8%81%9A%E7%9F%BF%E7%9F%B3%E9%95%87/5.jpg" alt></p>
<p>结婚前：<br><img src="/2020/08/25/%E9%87%8D%E8%81%9A%E7%9F%BF%E7%9F%B3%E9%95%87/6.jpg" alt></p>
<p>婚礼：<br><img src="/2020/08/25/%E9%87%8D%E8%81%9A%E7%9F%BF%E7%9F%B3%E9%95%87/7.jpg" alt></p>
<p>（这一张兰的立绘实在是太美了）<br><img src="/2020/08/25/%E9%87%8D%E8%81%9A%E7%9F%BF%E7%9F%B3%E9%95%87/8.jpg" alt></p>
<p>婚礼当天晚上：<br><img src="/2020/08/25/%E9%87%8D%E8%81%9A%E7%9F%BF%E7%9F%B3%E9%95%87/9.jpg" alt></p>
<p><img src="/2020/08/25/%E9%87%8D%E8%81%9A%E7%9F%BF%E7%9F%B3%E9%95%87/10.jpg" alt></p>
<p>幸福生活第一天：<br><img src="/2020/08/25/%E9%87%8D%E8%81%9A%E7%9F%BF%E7%9F%B3%E9%95%87/11.jpg" alt></p>
]]></content>
      <categories>
        <category>Game</category>
      </categories>
  </entry>
  <entry>
    <title>Android绘画学习-Paint相关</title>
    <url>/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>想做Android动画的时候，有的时候又需要自己画一些图形，比如自定义的进度条这样的。所以，学一些基础的绘画代码也是必要的。</p>
<a id="more"></a>
<p>我这里的Androi动画学习笔记是从CSDN的一位大佬的动画博客教程那里学来的，其实很多部分都与原博客相似，且内容不如原博客详细。这里直接贴上原博客，原博客有更丰富、更全面的教程，以方便大家学习，毕竟我自己的学习习惯有些问题，笔记并不一定全面。</p>
<p>原博客：<a href="https://blog.csdn.net/harvic880925/article/details/50995268">Android自定义控件学习三部曲</a></p>
<h1 id="Paint与Canvas"><a href="#Paint与Canvas" class="headerlink" title="Paint与Canvas"></a>Paint与Canvas</h1><p>Paint是画笔，Canvas是画布。画笔可以负责的，比如颜色，粗细，透明度等；而画布负责的，是画笔在画布上画的位置，大小，形状等。所以，搞清楚各部分负责的职能，逻辑会更清晰些。</p>
<p>参数稍后再写，先写怎么能让应用运行起来，这样，在改一些参数设置的时候，就用不着只是看，可以亲自感受变化了。</p>
<h2 id="基本实现方法"><a href="#基本实现方法" class="headerlink" title="基本实现方法"></a>基本实现方法</h2><p>1、先将布局更换为FrameLayout，并添加id，用于添加视图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;FrameLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class="line">    android:id&#x3D;&quot;@+id&#x2F;main_frame&quot;</span><br><span class="line">    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">    tools:context&#x3D;&quot;com.example.administrator.animationtest.activity.MainActivity&quot;&gt;</span><br><span class="line">&lt;&#x2F;FrameLayout&gt;</span><br></pre></td></tr></table></figure>
<p>2、创建一个自定义视图类，继承自View类。在这个类中，重点在于重写OnDraw()函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CustomView extends View &#123;</span><br><span class="line"></span><br><span class="line">    Context context;</span><br><span class="line"></span><br><span class="line">    public CustomView(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        this.context &#x3D; context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">        super.onDraw(canvas);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;示例代码</span><br><span class="line">		&#x2F;&#x2F;设置画笔基本属性</span><br><span class="line">        Paint paint &#x3D; new Paint();</span><br><span class="line">        paint.setAntiAlias(true);           &#x2F;&#x2F;抗锯齿</span><br><span class="line">        paint.setColor(Color.RED);          &#x2F;&#x2F;画笔颜色</span><br><span class="line">        paint.setStyle(Paint.Style.FILL);   &#x2F;&#x2F;填充样式</span><br><span class="line">        paint.setStrokeWidth(5);            &#x2F;&#x2F;画笔宽度</span><br><span class="line">        &#x2F;&#x2F;paint.setShadowLayer(1,15,15,Color.GREEN);      &#x2F;&#x2F;设置阴影</span><br><span class="line"></span><br><span class="line">        canvas.drawRGB(255,255,255);</span><br><span class="line">        &#x2F;&#x2F;画图</span><br><span class="line">        canvas.drawCircle(200,200,150,paint);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、在Activity类中添加绘画显示代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bind(R.id.main_frame) FrameLayout mainFrame;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mainFrame.addView(new CustomView(MainActivity.this));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行效果如下：</p>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/1.jpg" alt></p>
<p>我记得还有一个实现方法，是在布局文件中直接引用view类，不通过addView()方法也可以显示view。但由于忘了一些细节，没办法实现这个操作，所以在这里插个眼，等找到实现方法了TP回来。</p>
<h2 id="Paint的基本参数设置"><a href="#Paint的基本参数设置" class="headerlink" title="Paint的基本参数设置"></a>Paint的基本参数设置</h2><ul>
<li><p>setAntiAlias(Boolean boolean)    设置是否开启抗锯齿</p>
</li>
<li><p>setColor(int color)                设置画笔颜色</p>
</li>
<li><p>setStrokeWidth(int width)        设置画笔宽度</p>
</li>
<li><p>setStyle(Paint.Style style)        设置填充样式</p>
</li>
</ul>
<p>样式有三种：</p>
<p>Paint.Style.FILL                  填充内部</p>
<p>Paint.Style.FILL_AND_STROKE        填充内部以及描边</p>
<p>Paint.STyle.STROKE                仅描边</p>
<p>其中一和二其实没有什么区别。（起初我以为画笔如果够宽，一和二就会有明显的内部、边框之分，但实验过后发现并没有区别）</p>
<ul>
<li>setShadowLayer(float radius, float dx, float dy, int shadowColor)        设置阴影（对图形无效，对字体有效）</li>
</ul>
<p>其中radius指角度，即阴影倾斜度，dx水平位移，dy垂直位移</p>
<h2 id="基本几何图形绘制"><a href="#基本几何图形绘制" class="headerlink" title="基本几何图形绘制"></a>基本几何图形绘制</h2><p>canvas本身就提供了一些基础图形的绘制方法，接下来就是各个方法的使用设置。</p>
<h3 id="一条直线"><a href="#一条直线" class="headerlink" title="一条直线"></a>一条直线</h3><p>方法：drawLine (float startX, float startY, float stopX, float stopY, Paint paint)</p>
<p>参数不用多解释，起点的横纵坐标，终点的横纵坐标，最后就是已经设置好参数的画笔。最后一项参数，在后面的绘制方法里也会有，就不再赘述了。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas.drawLine(100,200,300,400,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/2.png" alt></p>
<h3 id="多条直线"><a href="#多条直线" class="headerlink" title="多条直线"></a>多条直线</h3><ul>
<li>方法：drawLines (float[] pts, Paint paint)</li>
</ul>
<p>由于每个pts的元素，都必须是以四个数，即一组点，即一条线为单位的，所以，在写多条直线的数组时，要<strong>注意数组的元素个数是否符合标准，即数的个数是否能被4整除</strong>。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float []opts&#x3D;&#123;10,10,100,100,200,200,300,300,400,400,500,500&#125;;</span><br><span class="line">canvas.drawLines(opts,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/3.png" alt></p>
<ul>
<li>方法：drawLines (float[] pts, int offset, int count, Paint paint)</li>
</ul>
<p>这个方法与上个方法相比，多出来两个不同的参数。offset表示跳过的数据个数，count表示实际参与绘制的数据个数。什么意思呢？就是在绘制的时候，会先跳过已设置的offset个数的点，只将接下来的count个数的点所构成的直线绘制出来。由此可以得知，两个参数均必须是4的倍数，且两者之和不超过数据的长度。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float []opts&#x3D;&#123;10,10,100,100,200,200,300,300,400,400,500,500&#125;;</span><br><span class="line">canvas.drawLines(opts,4,8,paint);</span><br><span class="line">&#x2F;&#x2F;canvas.drawLines(opts,4,4,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/4.png" alt></p>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/5.png" alt></p>
<p>可以看出来，第一行的运行效果，跳过了第一条直线，显示了第二、三条直线；第二行的运行效果，跳过了第一条直线，只显示了接下来四个点，也就是第二条直线；第三条直线则不再计入绘制。</p>
<h3 id="单个点"><a href="#单个点" class="headerlink" title="单个点"></a>单个点</h3><p>方法：drawPoint (float x, float y, Paint paint)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas.drawPoint(100,100,paint);</span><br></pre></td></tr></table></figure>
<h3 id="多个点"><a href="#多个点" class="headerlink" title="多个点"></a>多个点</h3><ul>
<li><p>方法：drawPoints (float[] pts, Paint paint)</p>
</li>
<li><p>方法：drawPoints (float[] pts, int offset, int count, Paint paint)</p>
</li>
</ul>
<p>这里的方法就跟直线的很类似了，就不再赘述了。</p>
<h3 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h3><p>绘制矩形有两个类：RectF类与Rect类。两个类的区别不大，目前看来的区别是构造参数类型不同。如下：</p>
<ul>
<li><p>RectF(float left, float top, float right, float bottom)</p>
</li>
<li><p>Rect(int left, int top, int right, int bottom)</p>
</li>
</ul>
<p>绘制方法：</p>
<ul>
<li><p>方法：drawRect (float left, float top, float right, float bottom, Paint paint)</p>
</li>
<li><p>方法：drawRect (RectF rect, Paint paint)</p>
</li>
<li><p>方法：drawRect (Rect r, Paint paint)</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas.drawRect(10,10,100,100,paint);</span><br><span class="line">canvas.drawRect(new Rect(120,10,210,100),paint);</span><br><span class="line">canvas.drawRect(new RectF(230,10,320,100),paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/6.png" alt></p>
<h3 id="圆角矩形"><a href="#圆角矩形" class="headerlink" title="圆角矩形"></a>圆角矩形</h3><p>方法：drawRoundRect (RectF rect, float rx, float ry, Paint paint)</p>
<p>这里的rx与ry是指矩形四角生成的椭圆的x轴半径与y轴半径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RectF rectF &#x3D; new RectF(100,100,300,300);</span><br><span class="line">canvas.drawRoundRect(rectF,20,20,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/7.png" alt></p>
<h3 id="圆形"><a href="#圆形" class="headerlink" title="圆形"></a>圆形</h3><p>方法：drawCircle (float cx, float cy, float radius, Paint paint)</p>
<p>这里的cx与cy是指圆心点的x轴与y轴坐标,radius则是圆的半径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas.drawCircle(200,200,100,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/8.png" alt></p>
<h3 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h3><p>椭圆是根据矩形生成的，根据矩形的左顶点与右底点坐标，决定了椭圆的x轴与y轴半径，以及中心点。</p>
<p>方法：drawOval (RectF oval, Paint paint)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RectF rectF &#x3D; new RectF(100,100,300,200);</span><br><span class="line">canvas.drawRect(rectF,paint);</span><br><span class="line"></span><br><span class="line">paint.setColor(Color.RED);</span><br><span class="line">canvas.drawOval(rectF,paint);</span><br></pre></td></tr></table></figure>
<p>为了直观些观察，这里临时将填充样式改为了描边，且将绘制第二个图形的画笔颜色改变一下。</p>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/9.png" alt></p>
<h3 id="弧"><a href="#弧" class="headerlink" title="弧"></a>弧</h3><p>弧是椭圆的一部分，椭圆与矩形相关，所以弧也与矩形相关。</p>
<p>方法：drawArc (RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint)</p>
<p>startAngle是弧开始的角度，sweepAngle是弧持续的角度，useCenter是是否需要弧的两边（详见例图）。<strong>注意，开始角度的起始位置是建立在Android的界面坐标系上的，而不是数学上的坐标系。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">paint.setStyle(Paint.Style.FILL);   &#x2F;&#x2F;填充样式</span><br><span class="line">RectF rectF &#x3D; new RectF(100,100,300,300);</span><br><span class="line">canvas.drawArc(rectF,0,70,true,paint);</span><br><span class="line"></span><br><span class="line">RectF rectF2 &#x3D; new RectF(400,100,600,300);</span><br><span class="line">canvas.drawArc(rectF2,0,70,false,paint);</span><br><span class="line"></span><br><span class="line">paint.setStyle(Paint.Style.STROKE);     &#x2F;&#x2F;描边样式</span><br><span class="line">RectF rectF3 &#x3D; new RectF(100,300,300,500);</span><br><span class="line">canvas.drawArc(rectF3,0,70,true,paint);</span><br><span class="line"></span><br><span class="line">RectF rectF4 &#x3D; new RectF(400,300,600,500);</span><br><span class="line">canvas.drawArc(rectF4,0,70,false,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/10.png" alt></p>
<h2 id="路径绘制图形"><a href="#路径绘制图形" class="headerlink" title="路径绘制图形"></a>路径绘制图形</h2><p>除了通过canvas直接调用绘制图形的专用方法外，还可以通过对path的参数编写并调用drawPath方法，画出想要绘制的图形。其实path有很多方法的参数跟上面的方法都很相似，这下面我就不赘述参数了。</p>
<p>方法：drawPath (Path path, Paint paint)</p>
<h3 id="直线"><a href="#直线" class="headerlink" title="直线"></a>直线</h3><ul>
<li>方法：moveTo (float x, float y)</li>
</ul>
<p>设定直线的起始点</p>
<ul>
<li>方法：lineTo (float x, float y)</li>
</ul>
<p>设定当前直线的终点，也是下一条直线的起始点</p>
<ul>
<li>方法：close ()</li>
</ul>
<p>闭环，即将最后一条直线的终点与第一条的起点连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">paint.setStyle(Paint.Style.FILL);   &#x2F;&#x2F;填充样式</span><br><span class="line"></span><br><span class="line">Path path &#x3D; new Path();</span><br><span class="line">path.moveTo(10,10);</span><br><span class="line">path.lineTo(10,100);</span><br><span class="line">path.lineTo(300,100);</span><br><span class="line">path.lineTo(500,50);</span><br><span class="line">path.close();</span><br><span class="line"></span><br><span class="line">canvas.drawPath(path,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/11.png" alt></p>
<h3 id="矩形-1"><a href="#矩形-1" class="headerlink" title="矩形"></a>矩形</h3><p>方法：addRect (RectF rect, Path.Direction dir)</p>
<p>矩形生成有两个方法，方法的区别主要在于矩形绘制的方向不同，一个是Path.Direction.CCW，为逆时针方向；另一个是Path.Direction.CW，为顺时针方向。为方便观察，可以通过绘制文字的生成路径来观察。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Path CCWpath &#x3D; new Path();</span><br><span class="line">RectF rectF1 &#x3D; new RectF(50,50,240,200);</span><br><span class="line">CCWpath.addRect(rectF1, Path.Direction.CCW);</span><br><span class="line"></span><br><span class="line">Path CWpath &#x3D; new Path();</span><br><span class="line">RectF rectF2 &#x3D; new RectF(290,50,480,200);</span><br><span class="line">CWpath.addRect(rectF2, Path.Direction.CW);</span><br><span class="line"></span><br><span class="line">canvas.drawPath(CCWpath,paint);</span><br><span class="line">canvas.drawPath(CWpath,paint);</span><br><span class="line"></span><br><span class="line">String text &#x3D; &quot;世间安得双全法，不负如来不负卿&quot;;</span><br><span class="line">paint.setColor(Color.RED);</span><br><span class="line">paint.setTextSize(35);</span><br><span class="line">canvas.drawTextOnPath(text,CCWpath,0,18,paint);</span><br><span class="line">canvas.drawTextOnPath(text,CWpath,0,18,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/12.png" alt></p>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/13.png" alt></p>
<h3 id="圆角矩形-1"><a href="#圆角矩形-1" class="headerlink" title="圆角矩形"></a>圆角矩形</h3><p>方法：addRoundRect (RectF rect, float[] radii, Path.Direction dir)</p>
<p>方法：addRoundRect (RectF rect, float rx, float ry, Path.Direction dir)</p>
<p>两个构造函数的区别主要在于第二个参数，即设定矩形的圆角大小。第一个方法可以对每个圆角进行定制，共8个数，方向则取决于绘制的方向，比如逆时针绘制圆角矩形，圆角则从左上角、左下角到右下角、右上角；而第二个方法则统一了每个圆角的大小。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Path path &#x3D; new Path();</span><br><span class="line">RectF rectF1 &#x3D; new RectF(50,50,240,200);</span><br><span class="line">path.addRoundRect(rectF1,10,15, Path.Direction.CCW);</span><br><span class="line"></span><br><span class="line">RectF rectF2 &#x3D; new RectF(290,50,480,200);</span><br><span class="line">float radius[] &#x3D; &#123;10,10,20,20,30,30,40,40&#125;;</span><br><span class="line">path.addRoundRect(rectF2,radius, Path.Direction.CCW);</span><br><span class="line"></span><br><span class="line">canvas.drawPath(path,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/14.png" alt></p>
<h3 id="圆形路径"><a href="#圆形路径" class="headerlink" title="圆形路径"></a>圆形路径</h3><p>方法：addCircle (float x, float y, float radius, Path.Direction dir)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Path path &#x3D; new Path();</span><br><span class="line">path.addCircle(200,200,100, Path.Direction.CCW);</span><br><span class="line">canvas.drawPath(path,paint);</span><br></pre></td></tr></table></figure>
<h3 id="椭圆路径"><a href="#椭圆路径" class="headerlink" title="椭圆路径"></a>椭圆路径</h3><p>方法：addOval (RectF oval, Path.Direction dir)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Path path &#x3D; new Path();</span><br><span class="line">RectF rectF &#x3D; new RectF(100,100,300,500);</span><br><span class="line">path.addOval(rectF, Path.Direction.CCW);</span><br><span class="line"></span><br><span class="line">canvas.drawPath(path,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/15.png" alt></p>
<h3 id="弧形路径"><a href="#弧形路径" class="headerlink" title="弧形路径"></a>弧形路径</h3><p>方法：addArc (RectF oval, float startAngle, float sweepAngle)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Path path &#x3D; new Path();</span><br><span class="line">RectF rectF &#x3D; new RectF(100,100,300,500);</span><br><span class="line">path.addArc(rectF,0,100);</span><br><span class="line"></span><br><span class="line">canvas.drawPath(path,paint);</span><br></pre></td></tr></table></figure>
<h3 id="线段"><a href="#线段" class="headerlink" title="线段"></a>线段</h3><p>方法：quadTo (float x1, float y1, float x2, float y2)</p>
<p>这个方法的特点是绘制的曲线遵循了“贝塞尔曲线”，所以在连续的绘制时看起来会很平滑，这里我也不多深究，也可能以后专门写个博客来描述一下区别吧。这里就贴一下别人的博客好了。</p>
<p>参考博客：<a href="https://blog.csdn.net/stevenhu_223/article/details/9229337">quadTo()方法与lineTo()方法的区别</a></p>
<h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><p>1、Paint相关设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">paint.setColor(Color.RED);                  &#x2F;&#x2F;画笔颜色</span><br><span class="line">paint.setStrokeWidth(5);                    &#x2F;&#x2F;画笔宽度</span><br><span class="line">paint.setAntiAlias(true);                   &#x2F;&#x2F;抗锯齿</span><br><span class="line">paint.setStyle(Paint.Style.FILL);           &#x2F;&#x2F;绘图样式</span><br><span class="line">paint.setTextSize(80);                      &#x2F;&#x2F;文字大小</span><br><span class="line"></span><br><span class="line">paint.setFakeBoldText(true);                &#x2F;&#x2F;是否为粗体</span><br><span class="line">paint.setTextSkewX((float) -0.25);          &#x2F;&#x2F;字体水平倾斜度</span><br><span class="line"></span><br><span class="line">paint.setUnderlineText(true);               &#x2F;&#x2F;下划线</span><br><span class="line">paint.setStrikeThruText(true);              &#x2F;&#x2F;删除线</span><br><span class="line"></span><br><span class="line">paint.setTextAlign(Paint.Align.CENTER);     &#x2F;&#x2F;对齐方式</span><br><span class="line">paint.setTextScaleX(1);                     &#x2F;&#x2F;只会将水平方向拉伸</span><br></pre></td></tr></table></figure>
<p>这就是paint绘制文字时的几个主要设置选项了。画笔颜色、宽度、抗锯齿、文字大小、下划线、删除线等这些很浅显的就不具体展示了，我只对绘图样式、是否为粗体、水平倾斜度、方向拉伸做一下展示，每行字之间至少有三个设置的不同（不包括最后两行的比较，最好两行是是否为粗体和设置阴影的区别）。示例代码及效果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">paint.setFakeBoldText(false);</span><br><span class="line">paint.setTextSkewX((float) -0.25);</span><br><span class="line">paint.setTextScaleX(1);</span><br><span class="line">canvas.drawText(&quot;おれはおまえが好きだ&quot;,10,100,paint);</span><br><span class="line"></span><br><span class="line">paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">paint.setFakeBoldText(false);</span><br><span class="line">paint.setTextSkewX((float) 0.25);</span><br><span class="line">paint.setTextScaleX((float) 0.75);</span><br><span class="line">canvas.drawText(&quot;わたしはあなたが好きだ&quot;,10,200,paint);</span><br><span class="line"></span><br><span class="line">paint.setStyle(Paint.Style.FILL_AND_STROKE);</span><br><span class="line">paint.setFakeBoldText(false);</span><br><span class="line">paint.setTextSkewX((float) -0.25);</span><br><span class="line">paint.setTextScaleX((float) 1.3);</span><br><span class="line">canvas.drawText(&quot;君の名は。&quot;,10,300,paint);</span><br><span class="line"></span><br><span class="line">paint.setShadowLayer(1,15,15,Color.GRAY);</span><br><span class="line">paint.setStyle(Paint.Style.FILL_AND_STROKE);</span><br><span class="line">paint.setFakeBoldText(true);</span><br><span class="line">paint.setTextSkewX((float) -0.25);</span><br><span class="line">paint.setTextScaleX((float) 1.3);</span><br><span class="line">canvas.drawText(&quot;君の名は。&quot;,10,400,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/16.png" alt></p>
<p>还有一个属性是文字对齐方式的区别。其实这里面细致的东西有很多，我在这里放上一篇讲的很细致的文章以供参考。<a href="https://www.jianshu.com/p/8b97627b21c4">博客链接</a>。我这里就只展示一下效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">paint.setTextAlign(Paint.Align.LEFT);</span><br><span class="line">canvas.drawText(&quot;君の名は。&quot;,360,100,paint);</span><br><span class="line"></span><br><span class="line">paint.setTextAlign(Paint.Align.CENTER);</span><br><span class="line">canvas.drawText(&quot;君の名は。&quot;,360,200,paint);</span><br><span class="line"></span><br><span class="line">paint.setTextAlign(Paint.Align.RIGHT);</span><br><span class="line">canvas.drawText(&quot;君の名は。&quot;,360,300,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/17.png" alt></p>
<p>根据设置的位置、属性以及效果可以看出，如果设置左对齐，则文字会以设置的原点为左基准线临界点，向右展开；如果为居中对齐，则文字以原点为基准线中心点；右对齐则为右基准线临界点。</p>
<p>2、canvas绘制文字的函数</p>
<ul>
<li><p>方法：void drawText (String text, float x, float y, Paint paint)</p>
</li>
<li><p>方法：void drawText (CharSequence text, int start, int end, float x, float y, Paint paint)</p>
</li>
</ul>
<p>第一个方法在上面的示例已经用过了，x和y表示位置，不用多说。而第二个方法，则可以额外对传入的字符串进行截取。不过我觉得也可以对字符串进行提前截取，再放入第一个方法，所以暂时想不到第二个方法的优势之处，可能少一行代码也算优势吧。</p>
<ul>
<li><p>方法：void drawPosText (char[] text, int index, int count, float[] pos, Paint paint)</p>
</li>
<li><p>方法：void drawPosText (String text, float[] pos, Paint paint)</p>
</li>
</ul>
<p>这两个方法可以指定要绘制的文字的位置，跟上面一样，位置也是两两数字一组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float pos[]&#x3D;new float[]&#123;10,200,60,300,110,400,160,500,210,600&#125;;</span><br><span class="line">canvas.drawPosText(&quot;君の名は。&quot;,pos,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/18.png" alt></p>
<ul>
<li><p>方法：void drawTextOnPath (String text, Path path, float hOffset, float vOffset, Paint paint)</p>
</li>
<li><p>方法：void drawTextOnPath (char[] text, int index, int count, Path path, float hOffset, float vOffset, Paint paint)</p>
</li>
</ul>
<p>这两个方法属于沿路径绘制，在上面的示例中也已经见过一次了。这里主要讲hOffset、vOffset，hOffset是与路径起始点的<strong>水平</strong>偏移增量，vOffset是与路径中心的垂直偏移增量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String text &#x3D; &quot;君の名は。&quot;;</span><br><span class="line"></span><br><span class="line">Path circlePath &#x3D; new Path();</span><br><span class="line">RectF rectF &#x3D; new RectF(100,100,300,300);</span><br><span class="line">circlePath.addRoundRect(rectF,10,15,Path.Direction.CCW);</span><br><span class="line">canvas.drawPath(circlePath,paint);</span><br><span class="line"></span><br><span class="line">Path circlePath2 &#x3D; new Path();</span><br><span class="line">RectF rectF2 &#x3D; new RectF(400,100,600,300);</span><br><span class="line">circlePath2.addRoundRect(rectF2,10,15, Path.Direction.CCW);</span><br><span class="line">canvas.drawPath(circlePath2,paint);</span><br><span class="line"></span><br><span class="line">canvas.drawTextOnPath(text,circlePath,0,0,paint);</span><br><span class="line">canvas.drawTextOnPath(text,circlePath2,80,30,paint);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/09/Android%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0-Paint%E7%9B%B8%E5%85%B3/19.png" alt></p>
<p>此外字体还有其他的样式设置等等。个人感觉暂时不会用到，就不做学习了。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>妈耶，我再也不一口气写这么长的博客了。写到后边，总觉得累了，都不想写的很详细了。真佩服那些能写出一本教程书的大佬。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>加密算法初步学习</title>
    <url>/2018/10/16/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>最近发现学的东西杂七杂八的，总是看到什么，觉得有意思，就查一下看看。像这次加密算法也是，这是个我应该不会去涉及的领域，毕竟我也不做后台数据库，也不玩python去破解什么东西，可能学了也没什么用。但兴趣来了，就学一学好了，总比整日一味刷着b站无聊的视频好多了。</p>
<a id="more"></a>
<p>最初用到加密算法，是和锎锎他们做一个英语学习平台应用，在对用户密码进行申请提交的时候，考虑到信息流安全性的问题，对密码进行了一个简单的MD5加密算法加密。我们在加密之前先在密码末尾加一串内部约定的字符串，再对密码进行加密，最后截取其中一部分字符串进行密码提交与登录匹配。这是我第一次对加密算法有了接触。后来在使用支付宝支付SDK集成的过程中，我又知道了Base64、RSA、SHA1、SHA2加密算法，前者是在提交支付信息时有进行加密，后三个则是对商户私钥公钥等的计算加密。不过，我完全不了解这些算法的加密原理和使用领域，今天来了兴趣，就查一下吧。至于加密算法代码的实现，以后再说。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>加密算法主要分为以下三类：</p>
<ul>
<li>对称加密算法</li>
</ul>
<p>包括AES、DES、3DES等。加密和解密用到的密钥相同，加密速度快，适合经常发送数据的场所，但密钥传输需要格外注意。</p>
<ul>
<li>非对称加密\公钥加密算法</li>
</ul>
<p>包括RSA、DSA、ECC等。加密和解密的密钥不同，加密方式通常采用数学难题所构造，加密速度慢，适合偶尔发送数据的场所，密钥传输方便。</p>
<ul>
<li>安全散列算法</li>
</ul>
<p>包括MD5、SHA1、HMAC等。严格意义来说，加密算法需要满足加密与解密两个条件；而安全散列算法是不可逆的算法计算，所以其实不是加密算法之流。</p>
<h1 id="Base64加密算法"><a href="#Base64加密算法" class="headerlink" title="Base64加密算法"></a>Base64加密算法</h1><p>第二次碰到Base64加密算法，是在金云天的个人简历博客看到的。当时不太懂，只是觉得联系方式那串字符串末尾有一个熟悉的“=”号，在查找加密算法的时候歪打正着的查到了Base64加密算法，也就有了初步的认识。起因说完了，现在就来学习一下加密原理。</p>
<h2 id="加密原理"><a href="#加密原理" class="headerlink" title="加密原理"></a>加密原理</h2><p>我们先拿到一个要加密的字符串，将单个字符先按照ASCII码表转换为对应的数字，再将数字转换为8位的二进制数。得到全部的二进制数后，按6位划分开来，得到一个6位二进制数的全新数列，此时，再将数列转换为10进制。转换完毕后，按照Base64索引表，将数字转换为对应的字符，这样就完成了转换。</p>
<p>下面我附上Base64的索引表：</p>
<p><img src="/2018/10/16/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/1.jpg" alt></p>
<h2 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h2><p>举例，以我的博客名称“QingMi”为要加密的字符串。我们先将QingMi转换为ASCII码表对应的数字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">81 105 110 103 77 105</span><br></pre></td></tr></table></figure>
<p>再转换为二进制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01010001 01101001 01101110 01100111 01001101 01101001</span><br></pre></td></tr></table></figure>
<p>将这个数列按6位一组划分开来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">010100 010110 100101 101110 011001 110100 110101 101001</span><br></pre></td></tr></table></figure>
<p>转为十进制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20 22 37 46 25 52 53 41</span><br></pre></td></tr></table></figure>
<p>按照Base64索引表转换为字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UWluZ01p</span><br></pre></td></tr></table></figure>
<p>跟在线转换的网站的结果对比了一下，没有问题。</p>
<p>但是，这个转换过程存在一个问题：8位的二进制按6位划分的时候，最后的末尾不足6位怎么办。不急，这里还是有解决方案的。我们还是拿“QingM”来举例，接着走一遍刚才的步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">81 105 110 103 77</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01010001 01101001 01101110 01100111 01001101</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">010100 010110 100101 101110 011001 110100 1101</span><br></pre></td></tr></table></figure>
<p>走到这一步的时候，我们就需要在末尾补足0了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">010100 010110 100101 101110 011001 110100 110100</span><br></pre></td></tr></table></figure>
<p><strong>但是，还没有结束。</strong>我们还需要对加密的字符串的长度进行一下除3求余计算。这里长度是5，除3余2。如果余2，则在补足0后，<strong>在数列后加一个000000，但此数列不参与索引表转换，在最后只转换为“=”号</strong>；如果余1，<strong>则加两个000000</strong>。</p>
<p>那么此时，应当添加一个000000：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">010100 010110 100101 101110 011001 110100 110100 000000</span><br></pre></td></tr></table></figure>
<p>转换为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20 22 37 46 25 52 52</span><br></pre></td></tr></table></figure>
<p>末尾不参与索引表字符转换，直接在末尾添加一个“=”：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UWluZ00&#x3D;</span><br></pre></td></tr></table></figure>
<p>ok，转换完成。</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p><del>（我本不想讲用途的，但一想到以后若是与人谈论加密算法，却不知道用途，未免也太尴尬了些）</del></p>
<p>Base64编码在Java的Hibernate中有应用，也可用于HTTP环境下传递标识信息，但碍于“/”与“+”号在URL中会发生形式变化，不利于数据库数据的存储，所以有一些改进的Base64编码将最后的“/”与“+”号替换为“-”与“_”等。</p>
<h1 id="RSA加密算法"><a href="#RSA加密算法" class="headerlink" title="RSA加密算法"></a>RSA加密算法</h1><p>在查RSA加密算法之前，我绝没有想到它竟然是如此重量级的安全加密算法。它的加密原理，跟我上一个查过的Base64加密算法原理相差如此之大，涉及了很多高数的算法，让我这个高数一般的人学起来简直头大的不行。但既然已经查了，那我就把看来的东西整理一下。</p>
<p>首先要学习RSA用到的四个数学概念。</p>
<h2 id="理论知识准备"><a href="#理论知识准备" class="headerlink" title="理论知识准备"></a>理论知识准备</h2><p>1、<strong>互质</strong></p>
<p>如果两个正整数，没有除1以外的公约数，则这两个数是互质关系。并不一定只有质数之间才是互质关系，比如8和9，也是互质关系。</p>
<p>2、<strong>欧拉函数</strong></p>
<p>给定一个正整数$n$，求在小于等于$n$的正整数之中，与$n$构成互质关系的数的个数。计算这个数的函数称作欧拉函数，公式用$Φ(n)$表示。</p>
<ul>
<li><p>$n$=1时，$Φ(n)=1$</p>
</li>
<li><p>$n$是质数，则$Φ(n)=n-1$</p>
</li>
<li><p>$n$是质数的某一个次方，则$Φ(p^k)=p^k-p^{k-1}=p^k(1-\cfrac{1}{p})$</p>
</li>
<li><p>$n$可以分解为两互质整数之积，如$n=p_1p_2$，则$Φ(n)=Φ(p_1p_2)=Φ(p_1)Φ(p_2)$</p>
</li>
<li><p>因为任意一个大于1的正整数，都可以写成一系列质数的积，即$n=p_1p_2……p_r$;</p>
</li>
</ul>
<p>转换为$Φ(n)=Φ(p_1)Φ(p_2)……Φ(p_r)$；</p>
<p>最后得出$Φ(n)=n(1-\cfrac{1}{p_1})(1-\cfrac{1}{p_2})……(1-\cfrac{1}{p_r})$。</p>
<p>such as:$Φ(1323)=Φ(3^3*7^2)=1323(1-\cfrac{1}{3})(1-\cfrac{1}{7})=756$</p>
<p>3、<strong>欧拉定理</strong></p>
<p>如果两个正整数$a$与$n$互质，则满足以下等式：</p>
<p>$a^{Φ(n)}≡1\pmod n$</p>
<p>这个等式的意思是，$a$的$Φ(n)$次方被$n$除的余数为1，或者说，$a$的$Φ(n)$次方减去1可以被$n$整除。</p>
<p>当两者互质，且$n$为质数的时候，欧拉定理又可以写成：</p>
<p>$a^{p-1}≡1\pmod p$</p>
<p>这个等式又可以成为费马小定理。</p>
<p>4、<strong>模反元素</strong></p>
<p>如果两个正整数$a$和$n$互质，那么一定可以找到整数$b$，使得$ab-1$被$n$整除，即：</p>
<p>$ab≡1\pmod n$</p>
<p>此时$b$就成为$a$的模反元素。比如4与7互质，那么4的模反元素就是$2+7k$（$k$为整数）。欧拉定理有计算函数如下：</p>
<p>$a^{Φ(n)}=a*a^{Φ(n)-1}≡1\pmod n$</p>
<p>所以，$a^{Φ(n)-1}$就是$a$的模反元素。</p>
<h2 id="秘钥生成步骤"><a href="#秘钥生成步骤" class="headerlink" title="秘钥生成步骤"></a>秘钥生成步骤</h2><p>1、随机选择两个不相等的质数，$p$与$q$</p>
<p>此处取59和83</p>
<p>2、计算这两个数的乘积$n$</p>
<p>$59 * 83 = 4897$</p>
<p>3、计算乘积的欧拉函数$Φ(n)$</p>
<p>$Φ(4897)=58 * 82 = 4756$</p>
<p>4、随机选择一个整数$e$，条件是<strong>1&lt;e&lt;Φ(n)，且e与Φ(n)互质</strong></p>
<p>此处取23</p>
<p>5、计算$e$与$Φ(n)$的模反元素$d$</p>
<p>$ed≡1\pmod Φ(n)$</p>
<p>等价于 $ed - 1 = kΦ(n)$</p>
<p>得到 $ed + kΦ(n) = 1$ （不用在意$k$转换前后的符号，计算的时候代入符号转换即可）</p>
<p>代入数，得到 $23d + 4756k = 1$</p>
<p>采用<a href="https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95">扩展欧几里得算法</a>求解，过程如下：</p>
<p>先用类似辗转相除法，做以下计算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4756&#x3D;23*206+18</span><br><span class="line">23&#x3D;18*1+5</span><br><span class="line">18&#x3D;5*3+3</span><br><span class="line">5&#x3D;3*1+2</span><br><span class="line">3&#x3D;2*1+1</span><br></pre></td></tr></table></figure>
<p>然后改写成“余数等于”的形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18&#x3D;4756+23*(-206)	&#x2F;&#x2F;式1</span><br><span class="line">5&#x3D;23+18*(-1)		&#x2F;&#x2F;式2</span><br><span class="line">3&#x3D;18+5*(-3)			&#x2F;&#x2F;式3</span><br><span class="line">2&#x3D;5+3*(-1)			&#x2F;&#x2F;式4</span><br><span class="line">1&#x3D;3+2*(-1)</span><br></pre></td></tr></table></figure>
<p>然后开始“倒回来：计算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#x3D;3+2*(-1)</span><br><span class="line"> &#x3D;3+[5+3*(-1)]*(-1)				&#x2F;&#x2F;代入式4</span><br><span class="line"> &#x3D;3*2+5*(-1)</span><br><span class="line"> &#x3D;[18+5*(-3)]*2+5*(-1)			&#x2F;&#x2F;代入式3</span><br><span class="line"> &#x3D;18*2+5*(-7)</span><br><span class="line"> &#x3D;18*2+[23+18*(-1)]*(-7)		&#x2F;&#x2F;代入式2</span><br><span class="line"> &#x3D;18*9+23*(-1)</span><br><span class="line"> &#x3D;[4756+23*(-206)]*9+23*(-7)	&#x2F;&#x2F;代入式1</span><br><span class="line"> &#x3D;4756*9+23*(-1861)</span><br></pre></td></tr></table></figure>
<p>到此可以得出，$d=-1861$,$k=9$。</p>
<p><del>（这方法对整数形式的二元一次方程真是一个万能解，流弊）</del></p>
<p>6、将$n$和$e$封装成公钥，$n$和$d$封装成私钥</p>
<p>先回顾一下我们算过的所有有用的数：$p=59$,$q=83$,$n=4897$,$Φ(4897)=4756$,$e=23$,$d=-1861$</p>
<p>公钥用$(n,e)$表达，私钥用$(n,d)$表达，那么计算出来的公钥就是$(4897,23)$，私钥为$(4897,-1861)$</p>
<p>7、加密与解密</p>
<p>费心费力的算了半天，还不知道这公钥私钥怎么用，我都感觉自己差不多白学了，所以这里就讲一下怎么用。</p>
<ul>
<li>加密</li>
</ul>
<p>假设A向B发送信息$m$，A用公钥$(n,e)$进行加密。注意，$m$必须是证书且$m&lt;n$。而加密，就是要算出下式的$c$：</p>
<p>$m^e=c\pmod n$</p>
<p>公钥是$(4897,23)$,取$m$为7,则式为： $7^{23}≡c\pmod {4897}$</p>
<p>计算得出：$c=3855$。那么3855就是加密后的数字，A把它给了B。</p>
<p><del>(这里我只能取个比较小的数。最开始取了个101，然后，101的23次方，计算器炸了，，，，，)</del></p>
<ul>
<li>解密</li>
</ul>
<p>B拿到了3855，又有私钥$(4897,-1861)$，那要怎么解密呢？代入以下等式计算：</p>
<p>$c^d=m\pmod n$</p>
<p>代入得 $3855^{-1861}≡m\pmod {4897}$</p>
<p>emmmmmmm，等等，3855的-1861次方，这尼玛怎么算，等等，参考的博客是2790的2753次方，他怎么算的？芽儿哟，这怎么解啊。。。。。。这特么尴尬了，举了个例子结果有私钥都没法算，嗯……这大概就是RSA的安全性所在吧。。。。。</p>
<p>8、RSA的算法可靠性</p>
<p>维基百科这样说：“对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。”但维基百科又报道，到目前为止，并没有一种固定可靠的算法可以破解RSA算法。尽管如此，曾有暴力破解的方式破解过768位的秘钥，但花费时间漫长，从破解512位到768位花了漫长的10年。不过，普遍建议应将秘钥从1024位升级到2048位。</p>
<p>至于算法的安全性证明，我就不看了，光是上面这个次方计算都有点头疼。我知道有些算法可以优化次方运算，不过那是以后学习其他算法的事情了。原理明白就行了。想看安全性证明的，我在这里挂上参考博客链接：</p>
<p><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">RSA算法原理</a></p>
<h1 id="MD5摘要算法"><a href="#MD5摘要算法" class="headerlink" title="MD5摘要算法"></a>MD5摘要算法</h1><p>好吧，看来是Base64算法过于简单，让我产生了一部分算法都是简单的符号映射的错觉。在查阅MD5加密算法的资料过程中，MD5算法的过程运算让我更加头大。嘛，行吧，加密算法不难的话怎么能称为加密算法呢。</p>
<p>MD5算法是经由MD2、MD3、MD4发展而来。它的最大特点是，可以将任意长度的字节串变换成定长的字符串，现目前流行的有16位与32位。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>MD5算法是将输入的不定长度信息，输出固定长度为128-bits的算法。</p>
<h3 id="数据填充"><a href="#数据填充" class="headerlink" title="数据填充"></a>数据填充</h3><p>MD5算法对数据填充分两个步骤：</p>
<ul>
<li>1、<strong>填充信息至信息长度对512取模得448</strong></li>
</ul>
<p>填充方法：在信息后面填充一个1与无数个0，直至满足第一个条件</p>
<ul>
<li>2、<strong>在信息末尾添加信息长度的信息</strong></li>
</ul>
<p>看起来很绕，其实就是在上一步填充完的信息后，添加一个64位长度的二进制位数信息。这样一来，448+64=512，整个信息的长度还是可以被512整除的。这样做的话，在后面处理信息的时候也比较方便。</p>
<p>MD5会把信息以512位分组，再将每一分组划分为16个32位子分组。</p>
<h3 id="数据计算"><a href="#数据计算" class="headerlink" title="数据计算"></a>数据计算</h3><ul>
<li>四个被称作链接变量的常数：$A=0x67452301$,$B=0xEFCDAB89$,$C=0x98BADCFE$,$D=0x10325476$</li>
</ul>
<p>分别赋予小写$a$、$b$、$c$、$d$</p>
<p><del>(常数值与部分博客有出入，但观察一下，发现四个常数值的数字顺序是有规律的颠倒放置，至于原因还不知道)</del></p>
<ul>
<li>四个非线性函数</li>
</ul>
<p>$F(X,Y,Z)$ = ($X$ &amp; $Y$) | ($~X$ &amp; $Z$)</p>
<p>$G(X,Y,Z)$ = ($X$ &amp; $Z$) | ($Y$ &amp; $~Z$)</p>
<p>$H(X,Y,Z)$ = $X$ ^ $Y$ ^ $Z$</p>
<p>$I(X,Y,Z)$ = $Y$ ^ ($X$ | $~Z$)</p>
<p>准备完毕，下面就开始讲计算过程。</p>
<p>计算过程主要是四轮循环运算；每轮循环运算的次数，是512位信息分组的数目，即多少个32位信息组；每次运算，对$a$、$b$、$c$和$d$的其中三个做一次非线性函数运算，然后将所得结果加上第四个变量，文本信息的一个子分组，一个常数，将结果向右移一个不定的数，加上$a$、$b$、$c$、$d$其中之一，并用结果取代$a$、$b$、$c$、$d$之一。听起来很糊涂，那就看一下算式：</p>
<p>$F(a,b,c,d,M_j,s,t_i)表示a=b+(a+F(b,c,d)+M_j+t_i)&lt;&lt;$</p>
<p>其中$M_j$指文本信息子分组，$t_i$是常数，至于$s$，我猜是位移的数吧</p>
<p>这样经过几轮计算之后，将最后计算出来的$a$、$b$、$c$、$d$输出，就是最后的MD5值了。32位的MD5值是完整的计算结果，而16位的MD5值是截取的32位值的9~24位。</p>
<h2 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h2><p>1、常用作文件下载的核对，用于校验文件在下载过程中是否遭到不法程序篡改。</p>
<p>2、很多网站用来存储用户的密码，鉴于MD5算法的不可逆性，很难算出密码原文内容，所以经常用来做用户注册时密码的存储与登录时密码的核对。</p>
<p>3、数字签名。MD5也经常用作第三方认证机构的文件摘要信息比对，称“数字签名”。</p>
<p>PS：MD5算法现在已经不再完全可靠，已经有国内的科学院研究者破解了MD5的碰撞抵抗。</p>
<h1 id="AES加密算法"><a href="#AES加密算法" class="headerlink" title="AES加密算法"></a>AES加密算法</h1><p>查阅资料的时候，发现DES算法因已遭到破解，不再是安全的加密算法，所以又改换成学习AES加密算法。因为我实在看的有些困难，所以先贴上我参考的两篇比较好的详解博客：</p>
<p><a href="https://blog.csdn.net/qq_28205153/article/details/55798628">AES加密算法的详细介绍与实现</a></p>
<p><a href="https://www.cnblogs.com/luop/p/4334160.html">密码算法详解——AES</a></p>
<h2 id="加密原理-1"><a href="#加密原理-1" class="headerlink" title="加密原理"></a>加密原理</h2><p>AES是一种区块加密算法，即分组加密，将明文分成多个等长的模块，直至加密完所有明文。AES标准规范中，分组只能是128位，即每个分组为16个字节。但密钥的长度可以选择128位、192位或256位，每个选择对应的推荐加密轮数也不同，如下所示：</p>
<p><img src="/2018/10/16/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/3.jpg" alt></p>
<h2 id="加密步骤"><a href="#加密步骤" class="headerlink" title="加密步骤"></a>加密步骤</h2><p>因为过程很长，所以我先对整个过程做一个概要阐述：以AES-128举例，AES算法先将明文分组，每组被分为16个字节，用4x4的明文矩阵表示；然后将每组的明文矩阵转换为状态矩阵；然后进入AES的10轮加密，每轮加密均需要依次进行4个步骤，字节代换、行移位、列混合、轮密钥加（第一轮加密之前需先进行一次轮密钥加，最后一轮加密不需进行列混合）；最后，将输出的加密过后的状态矩阵替换为字符串，得到的即是密文。解密的过程，则是将上述的加密过程逆向进行即可。流程如下图所示：</p>
<p><img src="/2018/10/16/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/2.jpg" alt></p>
<h3 id="矩阵预处理"><a href="#矩阵预处理" class="headerlink" title="矩阵预处理"></a>矩阵预处理</h3><p>假设明文已被分好，第一组如下所示：</p>
<script type="math/tex; mode=display">
  \left[
  \begin{matrix}
   a & e & i & m \\\
   b & f & j & n \\\
   c & g & k & o \\\
   d & h & l & p
  \end{matrix}
  \right] \tag{1}</script><p>先将矩阵转换为状态矩阵，方法是只需将字符串转换为对应的十六进制即可：</p>
<script type="math/tex; mode=display">
  \left[
  \begin{matrix}
   0x61 & 0x65 & 0x69 & 0x6D \\\
   0x62 & 0x66 & 0x6A & 0x6E \\\
   0x63 & 0x67 & 0x6B & 0x6F \\\
   0x64 & 0x68 & 0x6C & 0x70
  \end{matrix}
  \right] \tag{2}</script><p>接下来该进行轮密钥加了。但考虑到我没办法进行10次加密运算，只能将每个步骤的计算方法讲清楚就行了，所以我把轮密钥加放在每轮的加密步骤中讲解。</p>
<h3 id="字节代换"><a href="#字节代换" class="headerlink" title="字节代换"></a>字节代换</h3><p>字节代换其实是一个查表替换字符的操作，AES算法为此定义了一个S盒和逆S盒（S盒与逆S盒的字符位置是固定的，是按照公式<script type="math/tex">GF(2^8) = GF(2)[x]/(x^8 + x^4 + x^3 + x + 1)</script>计算来的，有兴趣的可以去查一下）。表如下所示：</p>
<p><img src="/2018/10/16/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/4.jpg" alt></p>
<p><img src="/2018/10/16/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/5.jpg" alt></p>
<p>替换规则其实很简单：将原文的高4位作为行值，低4位作为列值，找到对应的元素，输出即可：</p>
<script type="math/tex; mode=display">
  \left[
  \begin{matrix}
   0xEF & 0x4D & 0xF9 & 0x3C \\\
   0xAA & 0x33 & 0x02 & 0x9F \\\
   0xFB & 0x85 & 0x7F & 0xA8 \\\
   0x43 & 0x45 & 0x50 & 0x51
  \end{matrix}
  \right] \tag{3}</script><p>逆向解密则从逆S盒取值即可。</p>
<h3 id="行移位"><a href="#行移位" class="headerlink" title="行移位"></a>行移位</h3><p>行移位是一个左循环移位操作。密钥长度为128位时，加密时，矩阵第0行左移0位，第1行左移1位，第2行左移2位，第3行左移3位。同理，解密时逆向即可。</p>
<script type="math/tex; mode=display">
  \left[
  \begin{matrix}
   0xEF & 0x4D & 0xF9 & 0x3C \\\
   0x33 & 0x02 & 0x9F & 0xAA \\\
   0x7F & 0xA8 & 0xFB & 0x85 \\\
   0x51 & 0x43 & 0x45 & 0x50
  \end{matrix}
  \right] \tag{4}</script><h3 id="列混合"><a href="#列混合" class="headerlink" title="列混合"></a>列混合</h3><p>列混合运算是将移位后的状态矩阵与固定的壶镇相乘，得到计算后的状态矩阵。固定矩阵如下：</p>
<script type="math/tex; mode=display">
  \left[
  \begin{matrix}
   02 & 03 & 01 & 01 \\\
   01 & 02 & 03 & 01 \\\
   01 & 01 & 02 & 03 \\\
   03 & 01 & 01 & 02
  \end{matrix}
  \right] \tag{5}</script><p>比如第一行第一列的元素的计算：</p>
<p>$S=(2\times0xEF)\bigotimes 0x4D \bigotimes 0xF9 \bigotimes (3\times0x3C)$</p>
<p>运算规则：1、对于2进制来说，乘以2即是将数左移一位。如果原数最高位为1，则需要在移位后再同（0001 1011）进行异或运算，比如$2\times0xEF$:</p>
<p>EF转换为二进制即为：1110 1111</p>
<p>乘2左移一位：1101 1110</p>
<p>因原最高位为1，故与0001 1011进行异或运算，得到：</p>
<p>1100 0101</p>
<p>这就是$2\times0xEF$的运算结果。</p>
<p>2、对于乘3运算，需要用分配率来进行运算，如$3\times0x3C$：</p>
<p>$3\times0x3C=(2+1)\times0011 1100=0111 1000\bigotimes0011 1100=0100 0100$</p>
<p>3、这样一来，就只剩下异或运算了，这就不用多说了吧：</p>
<p>1100 0101<br>0100 1101<br>1111 1001<br>0100 0100</p>
<p>得到结果：0011 0101</p>
<p>转换为十六进制即为：$0x35$</p>
<p>计算的过程如果手算那就太麻烦了，所以尽管可能多花了点时间，我还是写了点Java代码来实现计算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;存放状态矩阵</span><br><span class="line">        int a[][] &#x3D; new int[][]&#123;&#123;0xEF,0x4D,0xF9,0x3C&#125;,&#123;0x33,0x02,0x9F,0xAA&#125;,&#123;0x7F,0xA8,0xFB,0x85&#125;,&#123;0x51,0x43,0x45,0x50&#125;&#125;;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;存放要相乘的固定矩阵</span><br><span class="line">        int b[][] &#x3D; new int[][]&#123;&#123;2,3,1,1&#125;,&#123;1,2,3,1&#125;,&#123;1,1,2,3&#125;,&#123;3,1,1,2&#125;&#125;;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;存放计算后的状态矩阵</span><br><span class="line">        int c[][] &#x3D; new int[4][4];</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;先将后状态矩阵赋值为0</span><br><span class="line">        for(int i&#x3D;0;i&lt;4;i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;4;j++)&#123;</span><br><span class="line">                c[i][j]&#x3D;0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Main main &#x3D; new Main();</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;0;i&lt;4;i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;4;j++)&#123;</span><br><span class="line">                &#x2F;&#x2F;为方便理解下面的循环，在这里列出16次计算时每次计算的公式</span><br><span class="line">				&#x2F;&#x2F;c[i][j]&#x3D;a[i][0]*b[0][j]+a[i][1]*b[1][j]+a[i][2]*c[2][j]+a[i][3]*b[3][j];</span><br><span class="line">                int res &#x3D; 0;</span><br><span class="line">                for(int k&#x3D;0;k&lt;4;k++)&#123;</span><br><span class="line">                    if(b[k][j]&#x3D;&#x3D;2)&#123;</span><br><span class="line">                        res &#x3D; res ^ main.doubleCal(a[i][k]);</span><br><span class="line">                    &#125;else if(b[k][j]&#x3D;&#x3D;3)&#123;</span><br><span class="line">                        res &#x3D; res ^ main.tripleCal(a[i][k]);</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        res &#x3D; res ^ a[i][k];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                c[i][j]&#x3D;res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;输出计算后的状态矩阵</span><br><span class="line">        for(int i&#x3D;0;i&lt;4;i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;4;j++)&#123;</span><br><span class="line">				&#x2F;&#x2F;Integer.toHexString方法，可将十进制转化为十六进制输出；十六进制转化为十进制则为Integer.parseInt方法</span><br><span class="line">                System.out.print(Integer.toHexString(c[i][j])+&quot;  &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;乘2运算的情况处理</span><br><span class="line">    public int doubleCal(int a)&#123;</span><br><span class="line">		&#x2F;&#x2F;若a的最高位为1，即a大于127，则先移位，但移位不减值，故再减去超出8位的值，再与0001 1011，即27，进行异或运算</span><br><span class="line">        if(a&gt;127)&#123;</span><br><span class="line">            a &#x3D; a &lt;&lt; 1;</span><br><span class="line">            a -&#x3D; 256;</span><br><span class="line">            a &#x3D; a ^ 27;</span><br><span class="line">            return a;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            a &#x3D; a &lt;&lt; 1;</span><br><span class="line">            return a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;乘3运算的情况处理</span><br><span class="line">    public int tripleCal(int a)&#123;</span><br><span class="line">        a &#x3D; doubleCal(a) ^ a;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后计算出的结果是：</p>
<script type="math/tex; mode=display">
  \left[
  \begin{matrix}
   0x35 & 0x75 & 0xED & 0xCA \\\
   0x1E & 0x64 & 0xBA & 0xC4 \\\
   0x39 & 0xB4 & 0xF4 & 0xD0 \\\
   0x54 & 0x60 & 0x4E & 0x7D
  \end{matrix}
  \right] \tag{6}</script><p>逆运算的话，则是乘以上述固定矩阵的逆矩阵即可，该逆矩阵如下：</p>
<script type="math/tex; mode=display">
  \left[
  \begin{matrix}
   0x0E & 0x0B & 0x0D & 0x09 \\\
   0x09 & 0x0E & 0x0B & 0x0D \\\
   0x0D & 0x09 & 0x0E & 0x0B \\\
   0x0B & 0x0D & 0x09 & 0x0E
  \end{matrix}
  \right] \tag{7}</script><h3 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h3><p>轮密钥加则是将128位轮密钥同状态矩阵中的数据进行异或运算。密钥分成4组，每组32位字，状态矩阵取每列四个元素组成的32位字，依次对应进行异或运算，得到加密后的新状态矩阵。</p>
<p>在逆运算时，密钥不需改变，因为异或运算的特性，再次运算即可得到加密前的矩阵。</p>
<h3 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a>密钥扩展</h3><p>有一项事情需要注意：每一轮异或运算的密钥是在不断变化的。接下来就是了解一下，密钥变化的规律。</p>
<p>假设密钥Key为“abcdefghijklmnop”，则有$W[0]=“abcd”$,$W[1]=“efgh”$,$W[2]=“ijkl”$,$w[3]=“mnop”$。这是在进行10轮加密之前，最初的加密密钥。而接下来10轮所用到的40个新列$W[i]$，则以以下的规律计算：</p>
<p>1、如果i不是4的倍数</p>
<p>$W[i]=W[i-4] \bigotimes W[i-1]$</p>
<p>2、如果i是4的倍数</p>
<p>$W[i]=w[i-4] \bigotimes T(W[i-1])$</p>
<p>这里，T是一个由3部分组成的函数，包括字循环、字节代换和轮常量异或，分别如下：</p>
<p>$a$.字循环：将字节循环左移1个字节，如“abcd”变为“bcda”。</p>
<p>$b$.字节代换：这个不用多说，使用表为S盒。</p>
<p>$c$.轮常量异或：将值与轮常量进行异或，每一轮异或的值均不同，其表如下：</p>
<p><img src="/2018/10/16/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/6.jpg" alt></p>
<p>比如上述密钥可转化为“61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F 70”。那么4个初始值为：</p>
<p>$W[0]$=61 62 63 64</p>
<p>$W[1]$=65 66 67 68</p>
<p>$W[2]$=69 6A 6B 6C</p>
<p>$W[3]$=6D 6E 6F 70</p>
<p>求$W[4]$、$W[5]$、$W[6]$、$W[7]$</p>
<p>$W[4]=w[0] \bigotimes T(W[3])$</p>
<p>$T(W[3])$计算步骤：</p>
<p>1、6D 6E 6F 70输出变为6E 6F 70 6D</p>
<p>2、在S盒中找到对应字节，输出9F A8 51 3C</p>
<p>3、第一轮加密异或的数组为01 00 00 00,运算后输出9E A8 51 3C。</p>
<p>所以$T(W[3])$=9E A8 51 3C。</p>
<p>所以$W[4]$=61 62 63 64 $\bigotimes$ 9E A8 51 3C=FF CA 32 58</p>
<p>$W[5]=W[1] \bigotimes W[4]$=65 66 67 68 $\bigotimes$ FF CA 32 58=99 AC 55 30</p>
<p>$W[6]=W[2] \bigotimes W[5]$=69 6A 6B 6C $\bigotimes$ 99 AC 55 30=F0 C6 3E 5C</p>
<p>$W[7]=W[3] \bigotimes W[6]$=6D 6E 6F 70 $\bigotimes$ F0 C6 3E 5C=9D A8 51 2C</p>
<p>将所有结果组合起来，即为第一轮的密钥:FF CA 32 58 99 AC 55 30 F0 C6 3E 5C 9D A8 51 2C</p>
<h2 id="用途-2"><a href="#用途-2" class="headerlink" title="用途"></a>用途</h2><p>介于DES算法已被破解的事实，很多文件开始向3DES和AES加密靠拢。AES加密算法也并非牢不可破，目前已有成功的对AES算法的尝试攻击，不过距离算法的正式破解，还有一些难度。此外也有一些不针对算法，而针对算法系统或是安全系统的旁道攻击，不过这些攻击，就都是算法研究的题外话了。</p>
<p><del>（哇，终于把这个AES写完了，累死了。）</del></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这几章算法我均只讲解了初步原理。在查询及亲自使用在线加密算法的时候，深感每个算法均有很多不同的模式，而这些模式在原理讲解的博客中均未提及，可能是在代码实现的过程中有所差异？不过鉴于目前我还不会过度深入代码的实现，所以就点到为止。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>排序算法一直以来是我学的比较乱的一个部分，分不太清很多常用算法的特点。这次趁着写博客，我仔细捋一捋我听说过的算法。wiki百科上给出了很全的算法目录，我点了点，有一半的算法连名字都没听过，尤其是不实用算法的那五个，就不多做阐述了。</p>
<p>本篇博客排序的适用规模从小到大。</p>
<a id="more"></a>
<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>在讲解算法之前，要先考虑清楚，一个算法孰优孰劣，应该有怎样的评判标准。我觉得wiki百科上给出的几点很明确了，我就在这里直接引用了。</p>
<p>评判标准：</p>
<blockquote>
<ul>
<li><strong>计算的时间复杂度</strong>：（最差、最优及平均），依据列表的大小($n$)。一般而言，好的性能是$O(nlogn)$，坏的性能是$O(n^2)$。</li>
<li><strong>内存使用量</strong>：以及其他电脑资源的使用</li>
<li><strong>稳定性</strong>：稳定排序算法会让原本有相同键值的记录维持相对次序。比如说5，2，5，6，排完序后第一个5依然在第二个5之前，称稳定。但很多情况下，排列的元素并不会只是一个数字，多数为有很多属性的元素，所以稳定性就显得格外重要。</li>
</ul>
</blockquote>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>工作原理：重复走访过要排序的数列，一次比较两个元素，如果顺序错误就把他们交换过来，重复至到没有再需要交换，则排序完成。</p>
<p>算法描述：<br>1、比较相邻元素。如果第一个比第二个大（或小），则交换。<br>2、对当前范围每一对相邻元素做比较。结束时，最后的元素是最大值（或最开始的元素是最小值）。<br>3、缩小比较范围。<br>4、重复操作2、3，直至范围变为1，即不再需要比较。</p>
<p><strong>计算的时间复杂度</strong>：</p>
<blockquote>
<ul>
<li>最坏：$O(n^2)$</li>
<li>最优：$O(n)$</li>
<li>平均：$O(n^2)$</li>
</ul>
</blockquote>
<p><strong>内存使用量</strong>：</p>
<blockquote>
<ul>
<li>空间复杂度：需要辅助空间$O(1)$</li>
</ul>
</blockquote>
<p><strong>稳定性</strong>：<strong>稳定</strong></p>
<p><strong>特点</strong>：简单，稳定，但效率低下。</p>
<p>Java代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void bubbleSort(int arr[]) &#123;</span><br><span class="line">        int len &#x3D; arr.length;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">            for(int j &#x3D; 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class="line">                if(arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                    int temp &#x3D; arr[j];</span><br><span class="line">                    arr[j] &#x3D; arr[j + 1];</span><br><span class="line">                    arr[j + 1] &#x3D; temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>示意图</strong>：</p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/BubbleSort.gif" alt></p>
<p><strong>鸡尾酒排序</strong></p>
<p>鸡尾酒排序属于冒泡排序的一种变形，不同的是冒泡每次循环是单向，但鸡尾酒是双向。</p>
<p>大部分特点与冒泡排序一样。若排序是大部分已经排序过的话，会接近$O(n)$。</p>
<p><strong>示意图</strong>：</p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/CocktailSort.gif" alt></p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<p>算法描述：<br>1、将未排序序列的第一个元素标记为最小值<br>2、遍历当前未排序序列，找出最小值并标记<br>3、将最小值放至已排序序列末尾<br>4、重复1、2、3，直至未排序序列为空</p>
<p><strong>计算的时间复杂度</strong>：</p>
<blockquote>
<ul>
<li>最优、最差及平均：$O(n^2)$</li>
</ul>
</blockquote>
<p><strong>内存使用量</strong>：</p>
<blockquote>
<ul>
<li>空间复杂度：需要辅助空间$O(1)$</li>
</ul>
</blockquote>
<p><strong>稳定性</strong>：<strong>不稳定</strong></p>
<p><strong>特点</strong>：数据量较小时，选择排序比冒泡排序要快。原地操作几乎是选择排序的唯一优点，空间复杂度要求较高时，可选择此排序；然而实际应用比较罕见。</p>
<p>Java代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void selectionSort(int[] arr) &#123;</span><br><span class="line">        int i, j, min, temp, len &#x3D; arr.length;</span><br><span class="line">        for (i &#x3D; 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">            min &#x3D; i;&#x2F;&#x2F;未排序序列中最小数据数组下标</span><br><span class="line">            for (j &#x3D; i + 1; j &lt; len; j++)&#x2F;&#x2F;在未排序元素中继续寻找最小元素，并保存其下标</span><br><span class="line">                if (arr[min] &gt; arr[j]) &#123;</span><br><span class="line">                    min &#x3D; j;</span><br><span class="line">                &#125;</span><br><span class="line">            temp &#x3D; arr[min]; &#x2F;&#x2F;将最小元素放到已排序序列的末尾</span><br><span class="line">            arr[min] &#x3D; arr[i];</span><br><span class="line">            arr[i] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>示意图</strong>：</p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/SelectionSort.gif" alt></p>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>工作原理：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。其实插入排序的过程与玩手牌一样，从后往前查看比较，找到相应的位置插入即可。</p>
<p>算法描述：<br>1、从第一个元素开始，可以认为它已被排序<br>2、取出下一个元素，在已排序序列中从后往前扫描<br>3、若某元素大于新元素，将该元素移至下一位置，如此重复，直至找到小于新元素的位置，将新元素插入该位置后<br>4、重复操作3</p>
<p><strong>计算的时间复杂度</strong>：</p>
<blockquote>
<ul>
<li>最坏：$O(n^2)$</li>
<li>最优：$O(n)$</li>
<li>平均：$O(n^2)$</li>
</ul>
</blockquote>
<p><strong>内存使用量</strong>：</p>
<blockquote>
<ul>
<li>空间复杂度：需要辅助空间$O(1)$</li>
</ul>
</blockquote>
<p><strong>稳定性</strong>：<strong>稳定</strong></p>
<p><strong>特点</strong>：不适合数据量比较大的排序应用。如果数据量小于千，或输入元素大致上按顺序排列，那么插入排序是一个不错的选择。</p>
<p>Java代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void insertionSort(int[] arr) &#123;</span><br><span class="line">        for(int i &#x3D; 0; i&lt;arr.length-1; i++) &#123;</span><br><span class="line">            for(int j &#x3D; i + 1; j &gt; 0; j--) &#123;</span><br><span class="line">                if(arr[j - 1] &lt;&#x3D; arr[j])</span><br><span class="line">                    break;</span><br><span class="line">                int temp &#x3D; arr[j];</span><br><span class="line">                arr[j] &#x3D; arr[j - 1];</span><br><span class="line">                arr[j - 1] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>示意图</strong>：</p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/InsertionSort-example.gif" alt></p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/InsertionSort.gif" alt></p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>也称递减增量排序算法，是插入排序的一种更高效的改进版本。</p>
<p>工作原理：将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素一次性地朝最终位置前进一大步，然后算法再取越来越小的步长进行排序，到最后一步，即变成了普通的插入排序。不过在最后，所有数据基本已经排序好了。</p>
<p>算法描述：<br>例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13 14 94 33 82</span><br><span class="line">25 59 94 65 23</span><br><span class="line">45 27 73 25 39</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>然后我们对<strong>每列</strong>进行排序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 14 73 25 23</span><br><span class="line">13 27 94 33 39</span><br><span class="line">25 59 94 65 82</span><br><span class="line">45</span><br></pre></td></tr></table></figure>
<p>然后再以3为步长进行划分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 14 73</span><br><span class="line">25 23 13</span><br><span class="line">27 94 33</span><br><span class="line">39 25 59</span><br><span class="line">94 65 82</span><br><span class="line">45</span><br></pre></td></tr></table></figure>
<p>排序后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 14 13</span><br><span class="line">25 23 33</span><br><span class="line">27 25 59</span><br><span class="line">39 65 73</span><br><span class="line">45 94 82</span><br><span class="line">94</span><br></pre></td></tr></table></figure>
<p>最后再以1为步长进行排序，此时就是简单的插入排序了</p>
<p><strong>重点</strong>：步长的选择是希尔排序的重要部分</p>
<p>Donald Shell(设计者)最初建议选择步长为$\frac {n}{2}$</p>
<p>已知的最好步长序列是（1，5，19，41，109，……）（详情见<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a>）</p>
<p><strong>计算的时间复杂度</strong>：</p>
<blockquote>
<ul>
<li>最优：$O(n)$</li>
<li>最差：$O((nlogn)^2)$</li>
<li>平均：$O((nlogn)^2)$</li>
</ul>
</blockquote>
<p><strong>内存使用量</strong>：</p>
<blockquote>
<ul>
<li>空间复杂度：需要辅助空间$O(1)$</li>
</ul>
</blockquote>
<p><strong>稳定性</strong>：<strong>不稳定</strong></p>
<p><strong>特点</strong>：在使用最优步长序列时，比插入排序快。在较小数组中，比快速排序和堆排序还要快。但若涉及大量数据，速度依旧不及快速排序。</p>
<p>Java代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void shellSort(int[] arr) &#123;</span><br><span class="line">	int gap &#x3D; 1, i, j, len &#x3D; arr.length;</span><br><span class="line">	int temp;</span><br><span class="line">	while (gap &lt; len &#x2F; 3)</span><br><span class="line">		gap &#x3D; gap * 3 + 1; </span><br><span class="line">	for (; gap &gt; 0; gap &#x2F;&#x3D; 3)</span><br><span class="line">		for (i &#x3D; gap; i &lt; len; i++) &#123;</span><br><span class="line">			temp &#x3D; arr[i];</span><br><span class="line">			for (j &#x3D; i - gap; j &gt;&#x3D; 0 &amp;&amp; arr[j] &gt; temp; j -&#x3D; gap)</span><br><span class="line">				arr[j + gap] &#x3D; arr[j];</span><br><span class="line">			arr[j + gap] &#x3D; temp;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的代码中的步长取$\frac {n}{3}$</p>
<p><strong>示意图</strong>：</p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/ShellSort.gif" alt></p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>工作原理：归并排序是采用<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95">分治法</a>的一个非常典型的应用。归并排序的思想是先递归分解数组，再合并数组。</p>
<p>算法描述（迭代法）：<br>1、申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>2、设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>3、比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>4、重复步骤3直到某一指针到达序列尾<br>5、将另一序列剩下的所有元素直接复制到合并序列尾</p>
<p>合并：基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。</p>
<p>分解：基本思路是将数组分解成left和right，如果这两个数组内部数据是有序的，那么就可以用上面合并数组的方法将这两个数组合并排序。如何让这两个数组内部是有序的？可以再二分，直至分解出的小组只含有一个元素时为止，此时认为该小组内部已有序。然后合并排序相邻二个小组即可。</p>
<p><strong>计算的时间复杂度</strong>：</p>
<blockquote>
<ul>
<li>最优、最差及平均：$O(nlogn)$</li>
</ul>
</blockquote>
<p><strong>内存使用量</strong>：</p>
<blockquote>
<ul>
<li>空间复杂度：所需辅助空间$O(n)$</li>
</ul>
</blockquote>
<p><strong>稳定性</strong>：<strong>稳定</strong></p>
<p>Java代码（迭代版）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void mergeSort(int[] arr) &#123;</span><br><span class="line">    int len &#x3D; arr.length;</span><br><span class="line">    int[] result &#x3D; new int[len];</span><br><span class="line">    int block, start;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 原版代码的迭代次数少了一次，没有考虑到奇数列数组的情况</span><br><span class="line">    for(block &#x3D; 1; block &lt; len; block *&#x3D; 2) &#123;</span><br><span class="line">        for(start &#x3D; 0; start &lt;len; start +&#x3D; 2 * block) &#123;</span><br><span class="line">            int low &#x3D; start;</span><br><span class="line">            int mid &#x3D; (start + block) &lt; len ? (start + block) : len;</span><br><span class="line">            int high &#x3D; (start + 2 * block) &lt; len ? (start + 2 * block) : len;</span><br><span class="line">            &#x2F;&#x2F;两个块的起始下标及结束下标</span><br><span class="line">            int start1 &#x3D; low, end1 &#x3D; mid;</span><br><span class="line">            int start2 &#x3D; mid, end2 &#x3D; high;</span><br><span class="line">            &#x2F;&#x2F;开始对两个block进行归并排序</span><br><span class="line">            while (start1 &lt; end1 &amp;&amp; start2 &lt; end2) &#123;</span><br><span class="line">	        result[low++] &#x3D; arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</span><br><span class="line">            &#125;</span><br><span class="line">            while(start1 &lt; end1) &#123;</span><br><span class="line">	        result[low++] &#x3D; arr[start1++];</span><br><span class="line">            &#125;</span><br><span class="line">            while(start2 &lt; end2) &#123;</span><br><span class="line">	        result[low++] &#x3D; arr[start2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	int[] temp &#x3D; arr;</span><br><span class="line">	arr &#x3D; result;</span><br><span class="line">	result &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    result &#x3D; arr;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示意图</strong>：</p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/MergeSort-example.gif" alt></p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/MergeSort.gif" alt></p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>工作原理：快速排序主要采取分治法，将大问题逐步划分为小问题，逐个解决。</p>
<p>算法描述：<br>1、从数列中挑出一个元素，称为“基准”。<br>2、分区：所有比基准值小的元素摆在基准前面，所有比基准值大的元素摆在基准后面。分区结束时，基准应位于数列中间。<br>3、对左右区间递归执行操作2，直至各区间只有一个数。</p>
<p><strong>计算的时间复杂度</strong>：</p>
<blockquote>
<ul>
<li>最坏：$O(n^2)$</li>
<li>最优：$O(nlogn)$</li>
<li>平均：$O(nlogn)$</li>
</ul>
</blockquote>
<p><strong>内存使用量</strong>：</p>
<blockquote>
<ul>
<li>空间复杂度：需要辅助空间$O(logn)$</li>
</ul>
</blockquote>
<p><strong>稳定性</strong>：<strong>不稳定</strong></p>
<p><strong>特点</strong>：通常情况下，快速排序比其他$O(nlogn)$算法更快。</p>
<p>Java代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void quickSort(int arr[],int head,int tail) &#123;</span><br><span class="line">        if (head &gt;&#x3D; tail || arr &#x3D;&#x3D; null || arr.length &lt;&#x3D; 1) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int i &#x3D; head, j &#x3D; tail, pivot &#x3D; arr[(head + tail) &#x2F; 2];</span><br><span class="line">        while (i &lt;&#x3D; j) &#123;</span><br><span class="line">            while (arr[i] &lt; pivot) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            while (arr[j] &gt; pivot) &#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &lt; j) &#123;</span><br><span class="line">                int t &#x3D; arr[i];</span><br><span class="line">                arr[i] &#x3D; arr[j];</span><br><span class="line">                arr[j] &#x3D; t;</span><br><span class="line">                ++i;</span><br><span class="line">                --j;</span><br><span class="line">            &#125; else if (i &#x3D;&#x3D; j) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        quickSort(arr, head, j);</span><br><span class="line">        quickSort(arr, i, tail);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>示意图</strong>：</p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/QuickSort-example.gif" alt></p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/QuickSort.gif" alt></p>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>顾名思义，堆排序是利用堆这种数据结构所设计的一种排序算法，采用的是<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E5%A0%86">二叉堆</a>。</p>
<p><strong>二叉堆性质</strong>：<br>1、父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。<br>2、每个节点的左右子树都是一个二叉堆（都是最大堆或最小堆）。</p>
<p>算法描述：<br>1、构造最大堆（Build_Max_Heap）：若数组下标范围为0~$n$，考虑到单独一个元素是大根堆，则从下标$\frac {n}{2}$开始的元素均为大根堆。于是只要从$\frac {n}{2}-1$开始，向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。</p>
<p>2、堆排序（HeapSort）：由于堆是用数组模拟的。得到一个大根堆后，数组内部并不是有序的。因此需要将堆化数组有序化。思想是移除根节点，并做最大堆调整的递归运算。第一次将heap[0]与heap[$n$-1]交换，再对heap[0…$n$-2]做最大堆调整。第二次将heap[0]与heap[$n$-2]交换，再对heap[0…$n$-3]做最大堆调整。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。</p>
<p>3、最大堆调整（Max_Heapify）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点 。</p>
<p>上面这个是从大佬的博客拷来的步骤，说实话，太官方太仔细了些，我看不太懂。不过我看了几遍大佬博客下面的示意图后，明白了大概步骤，下面就整理一下。</p>
<p>步骤：<br>1、将数组构造为最大堆，在构造的过程中每一步都要检测当前堆是否为最大堆，如果不是，则进行调整<br>2、将第一个根节点与末节点互换后，移除末节点。移除出的末节点，就是堆中的最大数。<br>3、重新构建最大堆<br>4、重复步骤2、3，直至堆只有一个节点后再移除，则得到排列好的序列</p>
<p><strong>计算的时间复杂度</strong>：</p>
<blockquote>
<ul>
<li>最优、最差及平均：$O(nlogn)$</li>
</ul>
</blockquote>
<p><strong>内存使用量</strong>：</p>
<blockquote>
<ul>
<li>空间复杂度：所需辅助空间$O(n)$</li>
</ul>
</blockquote>
<p><strong>稳定性</strong>：<strong>不稳定</strong></p>
<p>Java代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HeapSort &#123;</span><br><span class="line">    </span><br><span class="line">    private int[] arr;</span><br><span class="line">    </span><br><span class="line">    public HeapSort(int[] arr)&#123;</span><br><span class="line">        this.arr &#x3D; arr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 堆排序的主要入口方法，共两步。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void sort()&#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         *  第一步：将数组堆化</span><br><span class="line">         *  beginIndex &#x3D; 第一个非叶子节点。</span><br><span class="line">         *  从第一个非叶子节点开始即可。无需从最后一个叶子节点开始。</span><br><span class="line">         *  叶子节点可以看作已符合堆要求的节点，根节点就是它自己且自己以下值为最大。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        int len &#x3D; arr.length - 1;</span><br><span class="line">        int beginIndex &#x3D; (len - 1) &gt;&gt; 1; </span><br><span class="line">        for(int i &#x3D; beginIndex; i &gt;&#x3D; 0; i--)&#123;</span><br><span class="line">            maxHeapify(i, len);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;*</span><br><span class="line">         * 第二步：对堆化数据排序</span><br><span class="line">         * 每次都是移出最顶层的根节点A[0]，与最尾部节点位置调换，同时遍历长度 - 1。</span><br><span class="line">         * 然后从新整理被换到根节点的末尾元素，使其符合堆的特性。</span><br><span class="line">         * 直至未排序的堆长度为 0。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        for(int i &#x3D; len; i &gt; 0; i--)&#123;</span><br><span class="line">            swap(0, i);</span><br><span class="line">            maxHeapify(0, i - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void swap(int i,int j)&#123;</span><br><span class="line">        int temp &#x3D; arr[i];</span><br><span class="line">        arr[i] &#x3D; arr[j];</span><br><span class="line">        arr[j] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 调整索引为 index 处的数据，使其符合堆的特性。</span><br><span class="line">     * </span><br><span class="line">     * @param index 需要堆化处理的数据的索引</span><br><span class="line">     * @param len 未排序的堆（数组）的长度</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void maxHeapify(int index,int len)&#123;</span><br><span class="line">        int li &#x3D; (index &lt;&lt; 1) + 1; &#x2F;&#x2F; 左子节点索引</span><br><span class="line">        int ri &#x3D; li + 1;           &#x2F;&#x2F; 右子节点索引</span><br><span class="line">        int cMax &#x3D; li;             &#x2F;&#x2F; 子节点值最大索引，默认左子节点。</span><br><span class="line">        </span><br><span class="line">        if(li &gt; len) return;       &#x2F;&#x2F; 左子节点索引超出计算范围，直接返回。</span><br><span class="line">        if(ri &lt;&#x3D; len &amp;&amp; arr[ri] &gt; arr[li]) &#x2F;&#x2F; 先判断左右子节点，哪个较大。</span><br><span class="line">            cMax &#x3D; ri;</span><br><span class="line">        if(arr[cMax] &gt; arr[index])&#123;</span><br><span class="line">            swap(cMax, index);      &#x2F;&#x2F; 如果父节点被子节点调换，</span><br><span class="line">            maxHeapify(cMax, len);  &#x2F;&#x2F; 则需要继续判断换下后的父节点是否符合堆的特性。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 测试用例</span><br><span class="line">     * </span><br><span class="line">     * 输出：</span><br><span class="line">     * [0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9]</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; new int[]&#123;3,5,3,0,8,6,1,5,8,6,2,4,9,4,7,0,1,8,9,7,3,1,2,5,9,7,4,0,2,6&#125;;        </span><br><span class="line">        new HeapSort(arr).sort();        </span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示意图</strong>：</p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Heapsort-example.gif" alt></p>
<p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/HeapSort.gif" alt></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/2018/01/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/sort.png" alt></p>
<p>PS：</p>
<blockquote>
<ul>
<li>Timsort是结合了合并排序与插入排序的算法，效率很好Java SE7、Android与python均采用Timsort算法对数组排列。（后续会更新此算法介绍）</li>
</ul>
</blockquote>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><blockquote>
<ul>
<li><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/">经典排序算法总结与实现</a></li>
<li><a href="http://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">排序算法可视化</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>文件Uri解析</title>
    <url>/2019/09/05/%E6%96%87%E4%BB%B6Uri%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>很早就想对音视频的uri做一个很认真的归纳分析，但一直觉得没有必要，直到遇到越来越多的不同机型的返回路径，搞得我一塌糊涂却又似懂非懂的，所以这一次就对手上现有的机型的返回路径和解析做一个归纳总结。</p>
<a id="more"></a>
<p>机型统计</p>
<blockquote>
<ul>
<li>小米4</li>
</ul>
</blockquote>
<pre><code>已刷为Android9.0原生系统，但我有安装小米国际版文件管理。选择文件时不同的文件管理系统会返回不同的路径。
</code></pre><blockquote>
<ul>
<li>华为</li>
</ul>
</blockquote>
<pre><code>公司的平板，EMUI3.1系统，Android版本5.1.1。
</code></pre><blockquote>
<ul>
<li>一加7</li>
</ul>
</blockquote>
<pre><code>氢OS9.5.7.GM57系统，Android版本9.0。
</code></pre><p>但其实归根结底，uri返回类型的内容取决于Android的版本以及所用的文件管理系统。原生系统中，Android4.4之前返回的uri就是路径；4.4之后，uri统一开始变为文件资源标识符。而且，受于不同软件的文件标识方法，返回的uri也会有不同。</p>
<h1 id="Uri组成"><a href="#Uri组成" class="headerlink" title="Uri组成"></a>Uri组成</h1><p>uri一般由以下几个部分构成：</p>
<p>[scheme:][//authority][path][?query][#fragment]</p>
<p>或者说</p>
<p>[scheme:][//host:port][path][?query][#fragment]</p>
<p>针对返回的uri，我取其中的getPath()、getAuthority()和getScheme()方法做一些比较。</p>
<h1 id="文件选择测试"><a href="#文件选择测试" class="headerlink" title="文件选择测试"></a>文件选择测试</h1><h2 id="小米4（选择了同一张图片）"><a href="#小米4（选择了同一张图片）" class="headerlink" title="小米4（选择了同一张图片）"></a>小米4（选择了同一张图片）</h2><blockquote>
<ul>
<li>9.0 文件系统</li>
</ul>
</blockquote>
<pre><code>path：/document/image:3180
authority：com.android.providers.media.documents
</code></pre><blockquote>
<ul>
<li>小米国际版文件管理</li>
</ul>
</blockquote>
<pre><code>path：/external_files/AchievemeentApp/Avatar.jpg
authority：com.mi.android.globalFileexplorer.myprovider
</code></pre><h2 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h2><blockquote>
<ul>
<li>图库</li>
</ul>
</blockquote>
<pre><code>path：/external/images/media/44678
authority：media
</code></pre><blockquote>
<ul>
<li>文件管理</li>
</ul>
</blockquote>
<pre><code>path：/storage/emulated/0/AchievementApp/Achievement.xls
authority：
scheme：file
</code></pre><h2 id="一加7"><a href="#一加7" class="headerlink" title="一加7"></a>一加7</h2><blockquote>
<ul>
<li>氢OS 图库</li>
</ul>
</blockquote>
<pre><code>path：/external/file/68400
authority：media
</code></pre><blockquote>
<ul>
<li>氢OS 文件管理</li>
</ul>
</blockquote>
<pre><code>path：/document/primary:AchievementApp/avatar.jpg
authority：com.android.externalstorage.documents
</code></pre><h2 id="Google-相册"><a href="#Google-相册" class="headerlink" title="Google 相册"></a>Google 相册</h2><pre><code>path : /-1/1/content://media/external/images/media/69009/ORIGINAL/NONE/1306754059
authority：com.google.android.apps.photos.contentprovider
</code></pre><h2 id="Google-Drive"><a href="#Google-Drive" class="headerlink" title="Google Drive"></a>Google Drive</h2><pre><code>path：/document/acc=1;doc=encoded=ismNrKUOIBuKKajB8VwcvErY5tVOtHT3P1OhHzic9JbtEmErmSmRRw==
authority：com.google.android.apps.docs.storage
</code></pre><p>除此之外，这些文件uri的scheme大部分是content类型，这一类略去了；个别返回了file类型，这一项有标出。</p>
<p>在使用的过程中，我发现Android系统本身返回的uri，只会是第一个出现的那样，故华为和一加7的Android系统文件返回路径情况我就略去了；而其余的路径，可以说，基本上都是由附加的文件管理软件的差异引起的uri路径差异，尤以Google软件的uri最让人惊异。</p>
<h1 id="Uri解析"><a href="#Uri解析" class="headerlink" title="Uri解析"></a>Uri解析</h1><p>我先给出我之前一段时间所使用到的一段解析uri的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String getFilePathByUri(Context context, Uri uri) &#123;</span><br><span class="line">    String path &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; 以 file:&#x2F;&#x2F; 开头的</span><br><span class="line">    if (ContentResolver.SCHEME_FILE.equals(uri.getScheme())) &#123;</span><br><span class="line">        path &#x3D; uri.getPath();</span><br><span class="line">        return path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 以 content:&#x2F;&#x2F; 开头的，比如 content:&#x2F;&#x2F;media&#x2F;extenral&#x2F;images&#x2F;media&#x2F;17766</span><br><span class="line">    if (ContentResolver.SCHEME_CONTENT.equals(uri.getScheme()) &amp;&amp; Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">        Cursor cursor &#x3D; context.getContentResolver().query(uri, new String[]&#123;MediaStore.Images.Media.DATA&#125;, null, null, null);</span><br><span class="line">        if (cursor !&#x3D; null) &#123;</span><br><span class="line">            if (cursor.moveToFirst()) &#123;</span><br><span class="line">                int columnIndex &#x3D; cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);</span><br><span class="line">                if (columnIndex &gt; -1) &#123;</span><br><span class="line">                    path &#x3D; cursor.getString(columnIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cursor.close();</span><br><span class="line">        &#125;</span><br><span class="line">        return path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 4.4及之后的 是以 content:&#x2F;&#x2F; 开头的，比如 content:&#x2F;&#x2F;com.android.providers.media.documents&#x2F;document&#x2F;image%3A235700</span><br><span class="line">    if (ContentResolver.SCHEME_CONTENT.equals(uri.getScheme()) &amp;&amp; Build.VERSION.SDK_INT &gt;&#x3D; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">        if (DocumentsContract.isDocumentUri(context, uri)) &#123;</span><br><span class="line">            if (isExternalStorageDocument(uri)) &#123;</span><br><span class="line">                &#x2F;&#x2F; ExternalStorageProvider</span><br><span class="line">                final String docId &#x3D; DocumentsContract.getDocumentId(uri);</span><br><span class="line">                final String[] split &#x3D; docId.split(&quot;:&quot;);</span><br><span class="line">                final String type &#x3D; split[0];</span><br><span class="line">                if (&quot;primary&quot;.equalsIgnoreCase(type)) &#123;</span><br><span class="line">                    path &#x3D; Environment.getExternalStorageDirectory() + &quot;&#x2F;&quot; + split[1];</span><br><span class="line">                    return path;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (isDownloadsDocument(uri)) &#123;</span><br><span class="line">                &#x2F;&#x2F; DownloadsProvider</span><br><span class="line">                final String id &#x3D; DocumentsContract.getDocumentId(uri);</span><br><span class="line">                final Uri contentUri &#x3D; ContentUris.withAppendedId(Uri.parse(&quot;content:&#x2F;&#x2F;downloads&#x2F;public_downloads&quot;), Long.valueOf(id));</span><br><span class="line">                path &#x3D; getDataColumn(context, contentUri, null, null);</span><br><span class="line">                return path;</span><br><span class="line">            &#125; else if (isMediaDocument(uri)) &#123;</span><br><span class="line">                &#x2F;&#x2F; MediaProvider</span><br><span class="line">                final String docId &#x3D; DocumentsContract.getDocumentId(uri);</span><br><span class="line">                final String[] split &#x3D; docId.split(&quot;:&quot;);</span><br><span class="line">                final String type &#x3D; split[0];</span><br><span class="line">                Uri contentUri &#x3D; null;</span><br><span class="line">                if (&quot;image&quot;.equals(type)) &#123;</span><br><span class="line">                    contentUri &#x3D; MediaStore.Images.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">                &#125; else if (&quot;video&quot;.equals(type)) &#123;</span><br><span class="line">                    contentUri &#x3D; MediaStore.Video.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">                &#125; else if (&quot;audio&quot;.equals(type)) &#123;</span><br><span class="line">                    contentUri &#x3D; MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">                &#125;</span><br><span class="line">                final String selection &#x3D; &quot;_id&#x3D;?&quot;;</span><br><span class="line">                final String[] selectionArgs &#x3D; new String[]&#123;split[1]&#125;;</span><br><span class="line">                path &#x3D; getDataColumn(context, contentUri, selection, selectionArgs);</span><br><span class="line">                return path;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static String getDataColumn(Context context, Uri uri, String selection, String[] selectionArgs) &#123;</span><br><span class="line">    Cursor cursor &#x3D; null;</span><br><span class="line">    final String column &#x3D; &quot;_data&quot;;</span><br><span class="line">    final String[] projection &#x3D; &#123;column&#125;;</span><br><span class="line">    try &#123;</span><br><span class="line">        cursor &#x3D; context.getContentResolver().query(uri, projection, selection, selectionArgs, null);</span><br><span class="line">        if (cursor !&#x3D; null &amp;&amp; cursor.moveToFirst()) &#123;</span><br><span class="line">        final int column_index &#x3D; cursor.getColumnIndexOrThrow(column);</span><br><span class="line">            return cursor.getString(column_index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (cursor !&#x3D; null)</span><br><span class="line">        cursor.close();</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static boolean isExternalStorageDocument(Uri uri) &#123;</span><br><span class="line">    return &quot;com.android.externalstorage.documents&quot;.equals(uri.getAuthority());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static boolean isDownloadsDocument(Uri uri) &#123;</span><br><span class="line">    return &quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static boolean isMediaDocument(Uri uri) &#123;</span><br><span class="line">    return &quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来的任务，就是按获取到uri一步一步走下去，看看都走到的是哪一步。</p>
<h2 id="小米4-9-0文件系统"><a href="#小米4-9-0文件系统" class="headerlink" title="小米4 9.0文件系统"></a>小米4 9.0文件系统</h2><p>先前已经说过，获取到的scheme全部为”content”，而且源码中定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static final String SCHEME_CONTENT &#x3D; &quot;content&quot;;</span><br></pre></td></tr></table></figure>
<p>且机型的Android系统最低为5.1的LOLLIPOP，必大于4.4的KITKAT。故判断全部进入了第三个判断方法之中。</p>
<p>接下来再来看源码中的DocumentsContract.isDocumentUri(Context context, Uri uri)方法（记为源方法1）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static boolean isDocumentUri(Context context, @Nullable Uri uri) &#123;</span><br><span class="line">    if (isContentUri(uri) &amp;&amp; isDocumentsProvider(context, uri.getAuthority())) &#123;</span><br><span class="line">        final List&lt;String&gt; paths &#x3D; uri.getPathSegments();</span><br><span class="line">        if (paths.size() &#x3D;&#x3D; 2) &#123;</span><br><span class="line">            return PATH_DOCUMENT.equals(paths.get(0));</span><br><span class="line">        &#125; else if (paths.size() &#x3D;&#x3D; 4) &#123;</span><br><span class="line">            return PATH_TREE.equals(paths.get(0)) &amp;&amp; PATH_DOCUMENT.equals(paths.get(2));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看源码的方法（记为源方法2）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static boolean isContentUri(@Nullable Uri uri) &#123;</span><br><span class="line">    return uri !&#x3D; null &amp;&amp; ContentResolver.SCHEME_CONTENT.equals(uri.getScheme());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自不用说，返回结果为true。接着下一个方法（记为源方法3）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static boolean isDocumentsProvider(Context context, String authority) &#123;</span><br><span class="line">    final Intent intent &#x3D; new Intent(PROVIDER_INTERFACE);</span><br><span class="line">    final List&lt;ResolveInfo&gt; infos &#x3D; context.getPackageManager().queryIntentContentProviders(intent, 0);</span><br><span class="line">    for (ResolveInfo info : infos) &#123;</span><br><span class="line">        if (authority.equals(info.providerInfo.authority)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法我看不懂，但单独拿出来运行了一遍，获取如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.android.documentsui.archives</span><br><span class="line">com.android.externalstorage.documents</span><br><span class="line">com.android.mtp.documents</span><br><span class="line">com.android.providers.downloads.documents</span><br><span class="line">com.android.providers.media.documents</span><br></pre></td></tr></table></figure>
<p>那么看来这个方法获取到的，就是系统本身所提供的contentProvider类了，不包括后安装的文件管理类软件。因为小米4上我安装了小米国际版文件管理，上面却并未获取到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.mi.android.globalFileexplorer.myprovider</span><br></pre></td></tr></table></figure>
<p>那么现在跳回源方法1，可以看出判断通过，接下来测试uri.getPathSegments方法，循环打印内容得到如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document</span><br><span class="line">image:3180</span><br></pre></td></tr></table></figure>
<p>很明显，此处size为2，paths.get[0]即为document。又因源代码定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static final String PATH_DOCUMENT &#x3D; &quot;document&quot;;</span><br></pre></td></tr></table></figure>
<p>故判断通过，源方法1返回结果为true。那么接下来再看判断的三个方法，均为provider名称匹配，名称依次为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.android.externalstorage.documents</span><br><span class="line">com.android.providers.downloads.documents</span><br><span class="line">com.android.providers.media.documents</span><br></pre></td></tr></table></figure>
<p>很熟悉，是我们在源方法3中打印过的内容之三，按字面意思理解，分别对应外存储文件，下载文件与媒体库文件。在这里，uri跳转至第三个判断方法，媒体库文件。接着往下走，获取文件id（记为源方法4）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String getDocumentId(Uri documentUri) &#123;</span><br><span class="line">    final List&lt;String&gt; paths &#x3D; documentUri.getPathSegments();</span><br><span class="line">    if (paths.size() &gt;&#x3D; 2 &amp;&amp; PATH_DOCUMENT.equals(paths.get(0))) &#123;</span><br><span class="line">        return paths.get(1);</span><br><span class="line">    &#125;</span><br><span class="line">    if (paths.size() &gt;&#x3D; 4 &amp;&amp; PATH_TREE.equals(paths.get(0)) &amp;&amp; PATH_DOCUMENT.equals(paths.get(2))) &#123;</span><br><span class="line">        return paths.get(3);</span><br><span class="line">    &#125;</span><br><span class="line">    throw new IllegalArgumentException(&quot;Invalid URI: &quot; + documentUri);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，此处得到docId为”image：3180”。image表示资源类型，3180表示资源id。</p>
<p>接下来，对文件的类型进行判断，是图片、音频还是视频，分别进入不同的媒体库，按照给出的文件id查询，即可得到真正的文件路径了。这个步骤在选择获取音视频资源时经常用，就不赘述了。</p>
<p>搞懂了流程，接下来就都很简单了。</p>
<h2 id="小米4-小米国际版文件管理"><a href="#小米4-小米国际版文件管理" class="headerlink" title="小米4 小米国际版文件管理"></a>小米4 小米国际版文件管理</h2><p>这一次按上面的方法走一遍后，很明显发现均不符合判断条件，结果也确实拿到的是null，所以这里我就自己补充一下小米机型的uri解析了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int length &#x3D; &quot;&#x2F;external_files&quot; .length();</span><br><span class="line">path &#x3D; Environment.getExternalStorageDirectory() + uri.getPath().substring(length, uri.getPath().length());</span><br></pre></td></tr></table></figure>
<p>这个方法很明显不适用与小米的所有机型，因为我安装的是国际版的文件管理。但是国内版的安装包我竟然找不到，太神奇了，等以后碰到了再说。</p>
<h2 id="华为-文件管理"><a href="#华为-文件管理" class="headerlink" title="华为 文件管理"></a>华为 文件管理</h2><p>这一类不必多说。返回的文件类型为file，用uri.getPath()方法即可获取到真实路径。</p>
<h2 id="一加7-氢OS-图库-与-华为-图库"><a href="#一加7-氢OS-图库-与-华为-图库" class="headerlink" title="一加7 氢OS 图库 与 华为 图库"></a>一加7 氢OS 图库 与 华为 图库</h2><p>这一类的不同首先在于authority为media类。不过这一类也简单，路径是包含资源id的，只要获取到资源id，然后去查询即可拿到相应的文件路径。</p>
<h2 id="一加7-氢OS-文件管理"><a href="#一加7-氢OS-文件管理" class="headerlink" title="一加7 氢OS 文件管理"></a>一加7 氢OS 文件管理</h2><p>这一次的uri，判断成功的是isExternalStorageDocument(uri)方法。这次的判断，有一个让我疑惑的地方，就是getPathSegments的打印内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document</span><br><span class="line">primary:AchievementApp&#x2F;avatar.jpg</span><br></pre></td></tr></table></figure>
<p>此处，size也为2，但很明显，后面的路径不再细分。</p>
<p>接下来，获取到docId为”primary:AchievementApp/avatar.jpg”。以”:”划分字符串，并在后字符串前添加外存储的路径，组成为文件的真实存在路径。</p>
<h2 id="一加7-Google-相册"><a href="#一加7-Google-相册" class="headerlink" title="一加7 Google 相册"></a>一加7 Google 相册</h2><p>我去查了下网上的解析Google相册的方法，凡是中文博客里，清一色的通过uri读取文件内容然后复制到某个目录下的。嗯，真的，服了。</p>
<p>我觉得不必如此。通过path内容和打印segments可以发现，里面其实已经包含了资源id了，取过来path看一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;-1&#x2F;1&#x2F;content:&#x2F;&#x2F;media&#x2F;external&#x2F;images&#x2F;media&#x2F;69009&#x2F;ORIGINAL&#x2F;NONE&#x2F;1306754059</span><br></pre></td></tr></table></figure>
<p>喏，是不是，打印的segments内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1</span><br><span class="line">1</span><br><span class="line">content:&#x2F;&#x2F;media&#x2F;external&#x2F;images&#x2F;media&#x2F;69009</span><br><span class="line">ORIGINAL</span><br><span class="line">NONE</span><br><span class="line">1306754059</span><br></pre></td></tr></table></figure>
<p>只要通过循环判断，取出第三个字符串，就可以作为一个新的uri内容了。接下来的处理，自不必我多说了吧。</p>
<h2 id="一加7-Google-Drive"><a href="#一加7-Google-Drive" class="headerlink" title="一加7 Google Drive"></a>一加7 Google Drive</h2><p>很奇怪，开始的时候我还能拿到文件的uri，但后来测试的过程中，即使挂着VPN也拿不到uri了。即使是拿着之前的uri，看到这个非Base64加密的字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ismNrKUOIBuKKajB8VwcvErY5tVOtHT3P1OhHzic9JbtEmErmSmRRw&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>
<p>算了算了，都加密了，就不管了。而且我看很少人讨论这个问题，就不过多涉及了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次最重要的是，文件uri解析的过程我完全弄懂了，即使以后碰到其他的文件管理软件，我也可以很快的做出解析了。最后贴出来最终完成版的文件解析方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FileUtil &#123;</span><br><span class="line"></span><br><span class="line">    public static String getFilePathByUri(Context context, Uri uri) &#123;</span><br><span class="line">        String path &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 以 file:&#x2F;&#x2F; 开头的</span><br><span class="line">        if (ContentResolver.SCHEME_FILE.equals(uri.getScheme())) &#123;</span><br><span class="line">            path &#x3D; uri.getPath();</span><br><span class="line">            return path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 以 content:&#x2F;&#x2F; 开头的，比如 content:&#x2F;&#x2F;media&#x2F;extenral&#x2F;images&#x2F;media&#x2F;17766</span><br><span class="line">        if (ContentResolver.SCHEME_CONTENT.equals(uri.getScheme()) &amp;&amp; Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            Cursor cursor &#x3D; context.getContentResolver().query(uri, new String[]&#123;MediaStore.Images.Media.DATA&#125;, null, null, null);</span><br><span class="line">            if (cursor !&#x3D; null) &#123;</span><br><span class="line">                if (cursor.moveToFirst()) &#123;</span><br><span class="line">                    int columnIndex &#x3D; cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);</span><br><span class="line">                    if (columnIndex &gt; -1) &#123;</span><br><span class="line">                        path &#x3D; cursor.getString(columnIndex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cursor.close();</span><br><span class="line">            &#125;</span><br><span class="line">            return path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 4.4及之后的 是以 content:&#x2F;&#x2F; 开头的，比如 content:&#x2F;&#x2F;com.android.providers.media.documents&#x2F;document&#x2F;image%3A235700</span><br><span class="line">        if (ContentResolver.SCHEME_CONTENT.equals(uri.getScheme()) &amp;&amp; Build.VERSION.SDK_INT &gt;&#x3D; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果是系统自带五种provider之一</span><br><span class="line">            if (DocumentsContract.isDocumentUri(context, uri)) &#123;</span><br><span class="line">                if (isExternalStorageDocument(uri)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; ExternalStorageProvider</span><br><span class="line">                    final String docId &#x3D; DocumentsContract.getDocumentId(uri);</span><br><span class="line">                    final String[] split &#x3D; docId.split(&quot;:&quot;);</span><br><span class="line">                    final String type &#x3D; split[0];</span><br><span class="line">                    if (&quot;primary&quot;.equalsIgnoreCase(type)) &#123;</span><br><span class="line">                        path &#x3D; Environment.getExternalStorageDirectory() + &quot;&#x2F;&quot; + split[1];</span><br><span class="line">                        return path;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (isDownloadsDocument(uri)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; DownloadsProvider</span><br><span class="line">                    final String id &#x3D; DocumentsContract.getDocumentId(uri);</span><br><span class="line">                    final Uri contentUri &#x3D; ContentUris.withAppendedId(Uri.parse(&quot;content:&#x2F;&#x2F;downloads&#x2F;public_downloads&quot;), Long.valueOf(id));</span><br><span class="line">                    path &#x3D; getDataColumn(context, contentUri, null, null);</span><br><span class="line">                    return path;</span><br><span class="line">                &#125; else if (isMediaDocument(uri)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; MediaProvider</span><br><span class="line">                    final String docId &#x3D; DocumentsContract.getDocumentId(uri);</span><br><span class="line">                    final String[] split &#x3D; docId.split(&quot;:&quot;);</span><br><span class="line">                    final String type &#x3D; split[0];</span><br><span class="line">                    Uri contentUri &#x3D; null;</span><br><span class="line">                    if (&quot;image&quot;.equals(type)) &#123;</span><br><span class="line">                        contentUri &#x3D; MediaStore.Images.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">                    &#125; else if (&quot;video&quot;.equals(type)) &#123;</span><br><span class="line">                        contentUri &#x3D; MediaStore.Video.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">                    &#125; else if (&quot;audio&quot;.equals(type)) &#123;</span><br><span class="line">                        contentUri &#x3D; MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">                    &#125;</span><br><span class="line">                    final String selection &#x3D; &quot;_id&#x3D;?&quot;;</span><br><span class="line">                    final String[] selectionArgs &#x3D; new String[]&#123;split[1]&#125;;</span><br><span class="line">                    path &#x3D; getDataColumn(context, contentUri, selection, selectionArgs);</span><br><span class="line">                    return path;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (isMiGlobalFileDocument(uri))&#123;</span><br><span class="line">                &#x2F;&#x2F;小米国际文件管理器</span><br><span class="line">                int length &#x3D; &quot;&#x2F;external_files&quot; .length();</span><br><span class="line">                path &#x3D; Environment.getExternalStorageDirectory() + uri.getPath().substring(length, uri.getPath().length());</span><br><span class="line">                return path;</span><br><span class="line">            &#125; else if (uri.getAuthority().equals(&quot;media&quot;))&#123;</span><br><span class="line">                path &#x3D; sortUri(context, uri);</span><br><span class="line">                return path;</span><br><span class="line">            &#125; else if (isGooglePhotosUri(uri))&#123;</span><br><span class="line">                &#x2F;&#x2F;Google相册图片</span><br><span class="line">                Uri contentUri &#x3D; null;</span><br><span class="line">                List&lt;String&gt; segments &#x3D; uri.getPathSegments();</span><br><span class="line">                for (String segment : segments)&#123;</span><br><span class="line">                    if (segment.contains(&quot;content&quot;))&#123;</span><br><span class="line">                        contentUri &#x3D; Uri.parse(segment);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (contentUri !&#x3D; null)&#123;</span><br><span class="line">                    path &#x3D; sortUri(context, contentUri);</span><br><span class="line">                &#125;</span><br><span class="line">                return path;</span><br><span class="line">            &#125; else if (isGoogleDriveUri(uri))&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String sortUri(Context context, Uri uri)&#123;</span><br><span class="line">        String path &#x3D; null;</span><br><span class="line">        String id &#x3D; uri.getLastPathSegment();</span><br><span class="line">        Uri contentUri &#x3D; null;</span><br><span class="line">        if (uri.getPath().contains(&quot;images&quot;))&#123;</span><br><span class="line">            contentUri &#x3D; MediaStore.Images.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">        &#125; else if (uri.getPath().contains(&quot;video&quot;))&#123;</span><br><span class="line">            contentUri &#x3D; MediaStore.Video.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">        &#125; else if (uri.getPath().contains(&quot;audio&quot;))&#123;</span><br><span class="line">            contentUri &#x3D; MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">        &#125;</span><br><span class="line">        if (contentUri !&#x3D; null)&#123;</span><br><span class="line">            path &#x3D; getDataColumn(context, contentUri, &quot;_id &#x3D; ?&quot;, new String[]&#123;id&#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;根据id查询文件(不限类)</span><br><span class="line">            Cursor cursor &#x3D; context.getContentResolver().query(uri, new String[]&#123;&quot;_data&quot;&#125;, &quot;_id &#x3D; ?&quot;, new String[]&#123;id&#125;, null, null);</span><br><span class="line">            if (cursor !&#x3D; null &amp;&amp; cursor.moveToFirst())&#123;</span><br><span class="line">                int index &#x3D; cursor.getColumnIndexOrThrow(&quot;_data&quot;);</span><br><span class="line">                path &#x3D; cursor.getString(index);</span><br><span class="line">            &#125;</span><br><span class="line">            cursor.close();</span><br><span class="line">        &#125;</span><br><span class="line">        return path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String getDataColumn(Context context, Uri uri, String selection, String[] selectionArgs) &#123;</span><br><span class="line">        Cursor cursor &#x3D; null;</span><br><span class="line">        final String column &#x3D; &quot;_data&quot;;</span><br><span class="line">        final String[] projection &#x3D; &#123;column&#125;;</span><br><span class="line">        try &#123;</span><br><span class="line">            cursor &#x3D; context.getContentResolver().query(uri, projection, selection, selectionArgs, null);</span><br><span class="line">            if (cursor !&#x3D; null &amp;&amp; cursor.moveToFirst()) &#123;</span><br><span class="line">                final int column_index &#x3D; cursor.getColumnIndexOrThrow(column);</span><br><span class="line">                return cursor.getString(column_index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (cursor !&#x3D; null)</span><br><span class="line">                cursor.close();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean isExternalStorageDocument(Uri uri) &#123;</span><br><span class="line">        return &quot;com.android.externalstorage.documents&quot;.equals(uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean isDownloadsDocument(Uri uri) &#123;</span><br><span class="line">        return &quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean isMediaDocument(Uri uri) &#123;</span><br><span class="line">        return &quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean isMiGlobalFileDocument(Uri uri)&#123;</span><br><span class="line">        return &quot;com.mi.android.globalFileexplorer.myprovider&quot;.equals(uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean isGooglePhotosUri(Uri uri)&#123;</span><br><span class="line">        return &quot;com.google.android.apps.photos.contentprovider&quot;.equals(uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean isGoogleDriveUri(Uri uri)&#123;</span><br><span class="line">        return &quot;com.google.android.apps.docs.storage&quot;.equals(uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
</search>
